@ifdef ! TRI
   @define TRI @0@
@endifdef
@ifdef ! TRMM
   @define TRMM @0@
@endifdef
@ifdef ! kmaj
   @define kmaj @0@
@endifdef
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@SKIP ************ Adding new bitvectors to parameterized unrolling ************ 
@BEGINSKIP
   Now we created two flags: one for main loop and other for cleanup loop
   bvML : bitvector, default 3, with following meanings:
      0 : no unroll in any dimension
      1 : unroll NU dimension
      2 : unroll KU dimension
      3 : unroll both dimension
   bvCU : bitvector, default 0, with following meanings: 
      0 : no unroll in any dimension
      1 : unroll NU dimension
      2 : unroll KU dimension
      3 : unroll both dimension
@ENDSKIP
@SKIP **** made bvML=3 default case 
@ifdef ! bvML
   @iexp bvML 3  
@endifdef
@SKIP **** made bvCU=3 default case 
@ifdef ! bvCU
   @iexp bvCU 3 
@endifdef
@BEGINSKIP
   to make code more readable, I create two flag to represent to each bits
   ML_KUR, ML_NUR
   CU_KUR, CU_NUR
@ENDSKIP
@iexp ML_NUR @(bvML) 1 &
@iexp ML_KUR @(bvML) 2 &
@iexp ML_NUKU @(bvML) 3 =
@iexp ML_NO @(bvML) 0 = 
@print ML_NUR=@(ML_NUR) ML_KUR=@(ML_KUR) ML_NUKU=@(ML_NUKU) 
@iexp CU_NUR @(bvCU) 1 &
@iexp CU_KUR @(bvCU) 2 &
@iexp CU_NUKU @(bvCU) 3 =
@iexp CU_NO @(bvCU) 0 = 
@SKIP @print CU_NUR = @(CU_NUR) CU_KUR = @(CU_KUR)
@SKIP **************************************************************************
@ROUT ATL_cam2amb ATL_ram2amb ATL_muxnu2mat
#include "atlas_misc.h"
@beginskip
#define TYPE double
#define SCALAR TYPE
#define ATL_INT int
#define ATL_rzero 0.0
#define ATL_CINT const int
@endskip
@ROUT cammmtst
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"
   @ifdef be
      @undef be
   @endifdef
   @define be @0@
   @define nbet @@(be)@
   @define alpha @1@
   @define malp @@
   @define nalp @@(alpha)@
   @define calp @-@
   @define beta @@(be)@
@ROUT blk2C_avx blk2C_sse C2blk_avx C2blk_sse 
@iif @(alpha) = -1
   @define nalp @n@
   @define malp @-@
   @define calp @@
@endiif
@iif @(alpha) = 1 
   @define nalp @1@
   @define malp @@
   @define calp @-@
@endiif
@ifdef ! nalp
   @define nalp @X@
   @define malp @alpha*@
   @define calp @(-alpha)*@
@endifdef
@iif @(beta) = -1
   @define nbet @n@
@endiif
@iif @iexp @(beta) 1 =  @(beta) 0 = |
   @define nbet @@(beta)@
@endiif
@ifdef ! nbet
   @define nbet @X@
@endifdef
#include "atlas_misc.h"
@ROUT ATL_am2rm ATL_am2cm ATL_cm2am ATL_rm2am ATL_ablk2cmat ATL_cmat2ablk @\
      ATL_cam2rm ATL_cam2cm ATL_ccm2am ATL_crm2am ATL_cablk2cmat ATL_ccmat2ablk
#include "atlas_misc.h"
   @ifdef ! alpha
      @define alpha @1@
   @endifdef
   @iif alpha = 1
      @define malp @@
      @define calp @-@
   @endiif
   @iif alpha = -1
      @define malp @-@
      @define calp @@
      @define nalp @n@
   @endiif
   @iif alpha ! -1
      @define nalp @@(alpha)@
      @iif alpha ! 1
         @define malp @alpha*@
         @define calp @(-alpha)*@
         @define nalp @X@
      @endiif
   @endiif
@ROUT ATL_am2cm ATL_cm2am ATL_rm2am cammmtst ammmtst
   @ifdef ! dupB
      @define dupB @1@
   @endifdef
   @iif dupB = 0
      @undef dupB
      @define dupB @1@
   @endiif
   @iif dupB < 2
      @define dsuf @@
      @iexp incdup @(nu) 0 +
   @endiif
   @iif dupB > 1
      @define dsuf @d@(dupB)@
      @iexp incdup @(dupB) @(nu) *
   @endiif
@ROUT ATL_cablk2cmat ATL_ccmat2ablk ATL_ablk2cmat ATL_cmat2ablk
   @iif beta = -1
      @define nbet @n@
   @endiif
   @iif beta ! -1
      @iif beta = 0
         @define nbet @@(beta)@
      @endiif
      @iif beta = 1
         @define nbet @1@
      @endiif
      @ifdef ! nbet
         @define nbet @X@
      @endifdef
   @endiif
@ROUT ammmtst
#include "atlas_misc.h"
   @define alpha @1@
   @define malp @@
   @define nalp @@(alpha)@
@ROUT ammmtst ATL_rm2am ATL_cm2am
   @define cnst @const @
   @define cnstb @@
@ROUT ATL_am2cm ATL_am2rm
   @define cnst @@
   @define cnstb @const @
@ROUT ATL_am2cm ATL_cm2am ammmtst
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@ifdef ! ku
   @iif kmaj = 0
      @define ku @1@
   @endiif
@endifdef
@iif kmaj ! 0
   @define ku @@(kmaj)@
@SKIP *** this proc handles one full block
@BEGINPROC doBlockNuKu
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ib @dum@
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
@ROUT ATL_am2cm
            A@(j)[i+@(k)] = @(malp)b[@(ib)];
@ROUT ATL_cm2am ammmtst
            b[@(ib)] = @(malp)A@(j)[i+@(k)];
@ROUT ATL_am2cm ATL_cm2am ammmtst
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP *** this proc handles one full block with KU unrolled 
@BEGINPROC doBlockKu nu_
   @define k @dum@
            ATL_UINT jj;
            @(cnst)TYPE *rA = A0;
            @(cnstb)TYPE *p = b;
            for (jj=0; jj < @(nu_); jj++, rA += lda, p+=@(ku))
            {
      @iexp k 0 
      @iwhile k < @(ku)
@ROUT ATL_am2cm
               rA[i+@(k)] = @(malp)p[@(k)];
@ROUT ATL_cm2am ammmtst
               p[@(k)] = @(malp)rA[i+@(k)];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         @iexp k @(k) 1 +
      @endiwhile
            }
   @undef k
@ENDPROC
@SKIP *** this proc handles one full block with NU unrolled 
@BEGINPROC doBlockNu ku_
   @define j @dum@
   @define ib @dum@
            ATL_UINT ii;
            for (ii=0; ii < @(ku_); ii++)
            {
      @iexp j 0 
      @iwhile j < @(nu)
            @iexp ib @(j) @(ku) *
@ROUT ATL_am2cm
               A@(j)[i+ii] = @(malp)b[@(ib)+ii];
@ROUT ATL_cm2am ammmtst
               b[@(ib)+ii] = @(malp)A@(j)[i+ii];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
            }
   @undef j
   @undef ib
@ENDPROC
@SKIP *** this proc handles one full block in both rolled 
@BEGINPROC doBlockRolled nu_ ku_
            ATL_UINT jj;
            @(cnst)TYPE *rA = A0;
            @(cnstb)TYPE *p = b;
            for (jj=0; jj < @(nu_); jj++, rA += lda, p+=@(ku))
            {
               ATL_UINT ii;
               for (ii=0; ii < @(ku_); ii++)
               {
@ROUT ATL_am2cm
                  rA[i+ii] = @(malp)p[ii];
@ROUT ATL_cm2am ammmtst
                  p[ii] = @(malp)rA[i+ii];
@ROUT ATL_am2cm ATL_cm2am ammmtst
               }
            }
@ENDPROC
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockNuKu
   @define j @dum@
   @define ib @dum@
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp ib @(j) @(ku) *
@ROUT ATL_am2cm
            A@(j)[i] = @(malp)b[@(ib)];
@ROUT ATL_cm2am ammmtst
            b[@(ib)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef j
@ENDPROC
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockRolled nu_
   @define k @dum@
            ATL_UINT jj;
            @(cnst)TYPE *rA = A0;
            @(cnstb)TYPE *p = b;
            for (jj=0; jj < @(nu_); jj++, rA += lda, p+=@(ku))
            {
@ROUT ATL_am2cm
               rA[i] = @(malp)p[0];
@ROUT ATL_cm2am ammmtst
               p[0] = @(malp)rA[i];
@ROUT ATL_am2cm ATL_cm2am ammmtst
            }
   @undef k
@ENDPROC 
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockNu nu_
   @define j @dum@
   @define ib @dum@
      @iexp j 0 
      @iwhile j < @(nu_)
         @iexp ib @(j) @(ku) *
@ROUT ATL_am2cm
            A@(j)[i] = @(malp)b[@(ib)];
@ROUT ATL_cm2am ammmtst
            b[@(ib)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef j
@ENDPROC 
@ROUT ATL_am2cm
/* 
 * This routine copies from k-vectorized access-major block b to column-major
 * submatrix A.
 */
@skip void Mjoin(PATL,am2cm_a@(nalp)_@(ku)x@(nu))
void ATL_USERCPMM       /* access- to column-major */
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* access-ku-major block holding A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major format */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_cm2am ammmtst
/*
 * This routine copies the KxN submatrix A into access-k-vlen-major storage.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(N/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * the same is true for the NU portion of the last K-panel if nu does not
 * evenly divide N.
 */
@skip void Mjoin(PATL,cm2am_a@(nalp)_@(ku)x@(nu))
@ROUT ammmtst 
#ifdef NO_CM2AM
   void ATL_cm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);
#else
void ATL_cm2am       /* column- to access-major */
@ROUT ATL_cm2am 
void ATL_USERCPMM       /* column- to access-major */
@ROUT ATL_cm2am ammmtst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-ku-major block holding A */
)
@ROUT ATL_am2cm ATL_cm2am ammmtst
{
   ATL_CSZT n = (N/@(nu))*@(nu), k = (K/@(ku))*@(ku), incA = lda*@(nu), nr=N-n;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   ATL_SZT i, j;
@iexp NA1 1
@iif @iexp 0 @(ML_NUR) ! 0 @(CU_NUR) ! |
   @iexp NA1 0
@endiif 
@iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif NA1 ! 0
   @(cnst)TYPE *A0=A;
@endiif
   @iexp binc @(nu) @(ku) *
   /* Main loop */
   for (j=0; j < n; j += @(nu))
   {
      for (i=0; i < k; i += @(ku), b += @(binc))
      {
         @iif ML_NUKU ! 0 
            @callproc doBlockNuKu
         @endiif
         @iif ML_NUKU = 0
            @iif ML_KUR ! 0
               @callproc doBlockKu @(nu)
            @endiif
            @iif ML_NUR ! 0
               @callproc doBlockNu @(ku)
            @endiif
            @iif ML_NO ! 0
               @callproc doBlockRolled @(nu) @(ku)
            @endiif
         @endiif
      }
      if (k != KK) /* K-cleanup */
      {
@ROUT ATL_cm2am ammmtst
      /* zero padding the whole block first*/ 
   @iif CU_NUKU = 0
         ATL_UINT ii, jj;
         TYPE *p = b; 
         for (jj=0; jj < @(nu); jj++, p+=@(ku))
            for (ii=0; ii < @(ku); ii++)
               p[ii] = 0.0;
   @endiif
   @iif CU_NUKU ! 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            b[@(ib)] = 
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
                    0.0;
      @endiwhile
   @endiif
@ROUT ATL_am2cm ATL_cm2am ammmtst
         for (; i < K; i++, b++)
         {
            @iif CU_NUKU ! 0
               @callproc doKCuBlockNuKu
            @endiif
            @iif CU_NUKU = 0
               @iif CU_NUR ! 0
                  @callproc doKCuBlockNu @(nu)
               @endiif
               @iif CU_NUR = 0
                  @callproc doKCuBlockRolled @(nu)
               @endiif
            @endiif
         }
         b += @(binc) - K + k;
      }
   @iif NA1 = 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
      @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif NA1 ! 0
      A0 += incA;
   @endiif
   }
@iif CU_NUKU ! 0 
   switch(nr) /* N-cleanup */
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < k; i += @(ku), b += @(binc))
      {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
@ROUT ATL_am2cm
            A@(j)[i+@(k)] = @(malp)b[@(ib)];
@ROUT ATL_cm2am ammmtst
            b[@(ib)] = @(malp)A@(j)[i+@(k)];
@ROUT ATL_am2cm ATL_cm2am ammmtst
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cm2am ammmtst
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            b[@(ib)] = 0.0;
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_am2cm ATL_cm2am ammmtst
      }
      if (k != KK)
      {
@ROUT ATL_cm2am ammmtst
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            b[@(ib)] = 
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
                    0.0;
      @endiwhile
@ROUT ATL_am2cm ATL_cm2am ammmtst
         for (; i < K; i++, b++)
         {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp ib @(j) @(ku) *
@ROUT ATL_am2cm
             A@(j)[i] = @(malp)b[@(ib)];
@ROUT ATL_cm2am ammmtst
            b[@(ib)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cm2am ammmtst
      @iwhile j < @(nu)
         @iexp ib @(j) @(ku) *
            b[@(ib)] = 0.0;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_am2cm ATL_cm2am ammmtst
         }
         b += @(binc) - K + k;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@iif CU_NUKU = 0
   if (nr) /* N-cleanup */
   {
      for (i=0; i < k; i += @(ku), b += @(binc))
      {
      @iif CU_KUR ! 0
         @callproc doBlockKu nr
      @endiif
      @iif CU_KUR = 0
         @callproc doBlockRolled nr @(ku)
      @endiif
@ROUT ATL_cm2am ammmtst
         /* zero padding */
         for (; jj < @(nu); jj++, p+=@(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 
         @iwhile j < @(ku)
            p[@(j)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT ii;
            for (ii=0; ii < @(ku); ii++)
               p[ii] = 0.0;
      @endiif
         }
@ROUT ATL_am2cm ATL_cm2am ammmtst
      }
      if (k != KK)
      {
@ROUT ATL_cm2am ammmtst
      /* zero padding the whole block first*/ 
      @SKIP @iif CU_NO ! 0
         ATL_UINT jj;
         TYPE *p = b; 
         for (jj=0; jj < @(nu); jj++, p+=@(ku))
         {
            ATL_UINT ii;
            for (ii=0; ii < @(ku); ii++)
            {
               p[ii] = 0.0;
            }
         }
      @SKIP @endiif
      @BEGINSKIP ****skipping unrolling the zero padding when not fully unrolled     
      @iif CU_NO = 0
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k 0 0 +
            @iwhile k < @(ku)
               @iexp ib @(j) @(ku) *
               @iexp ib @(ib) @(k) +
               b[@(ib)] = 
               @iexp k @(k) 1 +
            @endiwhile
            @iexp j @(j) 1 +
                    0.0;
         @endiwhile
      @endiif
      @ENDSKIP 
@ROUT ATL_am2cm ATL_cm2am ammmtst
         for (; i < K; i++, b++)
         {
            @callproc doKCuBlockRolled nr 
@ROUT ATL_cm2am ammmtst
            /* zero padding */
            for (; jj < @(nu); jj++, p+=@(ku))
               p[0] = 0.0;
@ROUT ATL_am2cm ATL_cm2am ammmtst
         }
         b += @(binc) - K + k;
      }
   }
@endiif
}
@ROUT ammmtst `#endif`
@endiif
@iif kmaj = 0
@SKIP ****** handles unrolled block copy
@BEGINPROC doBlockNu nu_
   @define j @dum@
   @define k @dum@
   @define jk @dum@
      @iexp j 0 0 +
      @iwhile j < @(nu_)
         @iexp jk @(dupB) @(j) *
         @iexp k @(dupB) -1 +
@ROUT ATL_cm2am ammmtst
         @iwhile k > 0
         b[@(jk)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         b[@(jk)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm
         A@(j)[i] = @(malp)b[@(jk)];
@ROUT ATL_am2cm ATL_cm2am ammmtst
      @iexp j @(j) 1 +
      @endiwhile
   @undef jk
   @undef k
   @undef j
@ENDPROC
@SKIP ***** handles rolled block copy 
@BEGINPROC doBlockRolled nu_
         ATL_UINT jj;
         @(cnst)TYPE *rA = A0;
         @(cnstb)TYPE *p = b;
      @iif dupB = 1
         for (jj=0; jj < @(nu_); jj++, rA += lda, p++)
         {
@ROUT ATL_cm2am ammmtst
            *p = @(malp)rA[i];
@ROUT ATL_am2cm
            rA[i] = @(malp)*p;
@ROUT ATL_am2cm ATL_cm2am ammmtst
         }
      @endiif
      @iif dupB > 1
         for (jj=0; jj < @(nu_); jj++, rA += lda, p+=@(dupB))
         {
@ROUT ATL_cm2am ammmtst
            ATL_UINT ii;
            TYPE a0 = rA[i];
            for (ii=0; ii < @(dupB); ii++)
               p[ii] = @(malp)a0;
@ROUT ATL_am2cm
            rA[i] = @(malp)p[0];
@ROUT ATL_am2cm ATL_cm2am ammmtst
         }
      @endiif
@ENDPROC
@ROUT ATL_am2cm
/*
 * Copies from (M-vectorized) access-major storage block b back to column-
 * major storage A, with possible scale.
 * For GEMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
@skip void Mjoin(PATL,am2cm_a@(nalp)_@(nu)@(dsuf)) /* col-access matx to access-major blk */
void ATL_USERCPMM       /* access-major blk 2 col-major array */
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* access-major block holding A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major format */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_cm2am ammmtst
/*
 * This routine copies the KxN submatrix A into the KxCEIL(N/@(nu)) block b.
 * b is stored in access-major storage, where the @(nu) unrolled accesses
 * are assumed to come from the columns of A.
 * More specifically, each Kx@(nu) column panel of A is copied into a
 * @(nu)xK region of b, and if the last such column panel is partial, it
 * is zero padded.
 * For GEMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
@skip void Mjoin(PATL,cm2am_a@(nalp)_@(nu)@(dsuf))
@ROUT ammmtst 
#ifdef NO_CM2AM
   void ATL_cm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);
#else
void ATL_cm2am
@ROUT ATL_cm2am 
void ATL_USERCPMM       /* col-access matx to access-major blk */
@ROUT ATL_cm2am ammmtst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding A */
)
@ROUT ATL_am2cm ATL_cm2am ammmtst
{
   ATL_CSZT n = (N/@(nu))*@(nu), incA = lda*@(nu);
   @iif ku > 1
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
@ROUT ATL_am2cm `   ATL_CSZT KZ = KK-K, ZSKIP=KZ*@(nu);`
      @define KB @KK@
   @endiif
   @iif ku < 2
      @define KB @K@
   @endiif
   ATL_SZT i, j;
   @iif CU_NUR = 0
   ATL_CSZT nr = N-n;
   @endiif
@iexp NA1 1
@iif @iexp 0 @(ML_NUR) ! 0 @(CU_NUR) ! |
   @iexp NA1 0
@endiif 
   @iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @endiif
   @iif NA1 ! 0
   @(cnst)TYPE *A0 = A;
   @endiif
   @SKIP @undef cnst

   for (j=0; j < n; j += @(nu))
   {
      for (i=0; i < K; i++, b += @(incdup))
      {
         @iif ML_NUR ! 0
            @callproc doBlockNu @(nu)
         @endiif
         @iif ML_NUR = 0
            @callproc doBlockRolled @(nu)
         @endiif
      }
   @iif NA1 = 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
      @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif NA1 ! 0
      A0 += incA;
   @endiif
   @iif ku > 1
@ROUT ATL_am2cm
      b += ZSKIP;
@ROUT ATL_cm2am ammmtst
      for (;i < KK; i++, b += @(incdup))
   @iif ML_NUR ! 0
      @iexp j 0
      @iwhile j < @(nu)
         b[@(j)] =
         @iexp j @(j) 1 +
      @endiwhile
                ATL_rzero;
   @endiif
   @iif ML_NUR = 0
      {
         ATL_UINT jj;
         for (jj=0; jj < @(nu); jj++)
            b[jj] = ATL_rzero;
      }
   @endiif
@ROUT ATL_am2cm ATL_cm2am ammmtst
   @endiif
   }
   @mif nu ! "1
      @iif CU_NUR ! 0
   switch(N-n)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
      @iexp j @(n) -1 + 
   case @(n):
      for (i=0; i < K; i++, b += @(incdup))
      {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp jk @(dupB) @(j) *
         @iexp k @(dupB) -1 +
@ROUT ATL_am2cm
         A@(j)[i] = @(malp)b[@(jk)];
@ROUT ATL_cm2am ammmtst
         @iwhile k > 0
         b[@(jk)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         b[@(jk)] = @(malp)A@(j)[i];
@ROUT ATL_am2cm ATL_cm2am ammmtst
      @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cm2am ammmtst
      @iwhile j < @(nu)
         @iexp jk @(dupB) @(j) *
         @iexp k @(dupB) -1 +
         @iwhile k > 0
         b[@(jk)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         b[@(jk)] = ATL_rzero;
      @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_am2cm ATL_cm2am ammmtst
      }
@ROUT ATL_cm2am ammmtst
   @iif ku > 1
      for (; i < KK; i++, b += @(incdup))
      @iexp j 0
      @iwhile j < @(nu)
         b[@(j)] =
         @iexp j @(j) 1 +
      @endiwhile
                ATL_rzero;
   @endiif
@ROUT ATL_am2cm ATL_cm2am ammmtst
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
      @endiif
      @SKIP **** rolled cleanup **** 
      @iif CU_NUR = 0
   if (nr)
   {
      for (i=0; i < K; i++, b += @(incdup))
      {
         @callproc doBlockRolled nr 
@ROUT ATL_cm2am ammmtst
         for (; jj < @(nu); jj++, p++)
            *p = ATL_rzero;
@ROUT ATL_am2cm ATL_cm2am ammmtst
      }
@ROUT ATL_cm2am ammmtst
   @iif ku > 1
      for (; i < KK; i++, b += @(incdup))
      {
         ATL_UINT ii;
         for (ii=0; ii < @(nu); ii++)
            b[ii] = ATL_rzero;
      }
   @endiif
@ROUT ATL_am2cm ATL_cm2am ammmtst
   }
      @endiif
   @endmif
}
@ROUT ammmtst `#endif`
@endiif
@ROUT ATL_ccm2am ATL_crm2am cammmtst
   @define cnst @const @
   @define cnstb @@
@ROUT ATL_cam2cm ATL_cam2rm
   @define cnst @@
   @define cnstb @const @
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
@iif kmaj = 1
   @iexp kmaj 0 0 +
@endiif
@iif kmaj ! 0
   @define ku @@(kmaj)@
@endiif
@ifdef ! ku
   @iif kmaj = 0
      @define ku @1@
   @endiif
@endifdef
@iif kmaj ! 0
   @iexp ku2 @(ku) @(ku) +
@SKIP *** handles element
@BEGINPROC doElement A_ j_ k2_ rA_ iA_ ib_
            @mif nalp ! "X
@ROUT ATL_cam2cm
                  @(A_)@(j_)[i+@(k2_)] = @(malp)@(rA_)[@(ib_)];
               #ifdef Conj_
                  @(A_)@(j_)[i+@(k2_)+1] = @(calp)@(iA_)[@(ib_)];
               #else
                  @(A_)@(j_)[i+@(k2_)+1] = @(malp)@(iA_)[@(ib_)];
               #endif
@ROUT ATL_ccm2am cammmtst
               @(rA_)[@(ib_)] = @(malp)@(A_)@(j_)[i+@(k2_)];
               #ifdef Conj_
                  @(iA_)[@(ib_)] = @(calp)@(A_)@(j_)[i+@(k2_)+1];
               #else
                  @(iA_)[@(ib_)] = @(malp)@(A_)@(j_)[i+@(k2_)+1];
               #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
            @mif nalp = "X
@ROUT ATL_cam2cm
               rv = @(rA_)[@(ib_)];
               #ifdef Conj_
                  iv = @(iA_)[@(ib_)];
               #else
                  iv = -@(iA_)[@(ib_)];
               #endif
               @(A_)@(j_)[i+@(k2_)] = rv*ra - iv*ia;
               @(A_)@(j_)[i+@(k2_)+1] = rv*ia + iv*ra;
@ROUT ATL_ccm2am cammmtst
               rv = @(A_)@(j_)[i+@(k2_)];
               #ifdef Conj_
                  iv = -@(A_)@(j_)[i+@(k2_)+1];
               #else
                  iv = @(A_)@(j_)[i+@(k2_)+1];
               #endif
               @(rA_)[@(ib_)] = rv*ra - iv*ia;
               @(iA_)[@(ib_)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
@ENDPROC
@SKIP *** this proc handles one full block
@BEGINPROC doBlockNuKu
   @define i @dum@
   @define j @dum@
   @define k @dum@
   @define ib @dum@
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp k2 @(k) @(k) +
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
               @callproc doElement A @(j) @(k2) rA iA @(ib) 
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef k
   @undef j
   @undef i
@ENDPROC
@SKIP *** this proc handles one full block with KU unrolled 
@BEGINPROC doBlockKu nu_
   @define k @dum@
   @define k2 @dum@
            ATL_UINT jj;
            @(cnst)TYPE *pA0 = A0;
            @(cnstb)TYPE *pr = rA, *pi = iA;
            for (jj=0; jj < @(nu_); jj++, pA0 += lda2, pr+=@(ku), pi+=@(ku))
            {
      @iexp k 0 
      @iwhile k < @(ku)
         @iexp k2 @(k) @(k) +
               @SKIP rA[i+@(k)] = @(malp)p[@(k)];
               @callproc doElement pA 0 @(k2) pr pi @(k) 
         @iexp k @(k) 1 +
      @endiwhile
            }
   @undef k2
   @undef k
@ENDPROC
@SKIP *** this proc handles one full block with NU unrolled 
@BEGINPROC doBlockNu ku_
   @define j @dum@
   @define ib @dum@
            ATL_UINT ii;
            for (ii=0; ii < @(ku_); ii++)
            {
      @iexp j 0 
      @iwhile j < @(nu)
            @iexp ib @(j) @(ku) *
               @SKIP ** real case : A@(j)[i+ii] = @(malp)b[@(ib)+ii];
               @SKIP @callproc doElement A @(j) ii*2 rA iA @(ib)+ii 
               @callproc doElement A @(j) (ii<<1) rA iA @(ib)+ii 
         @iexp j @(j) 1 +
      @endiwhile
            }
   @undef j
   @undef ib
@ENDPROC
@SKIP *** this proc handles one full block in both rolled 
@BEGINPROC doBlockRolled nu_ ku_
            ATL_UINT jj;
            @(cnst)TYPE *pA0 = A0;
            @(cnstb)TYPE *pr = rA, *pi = iA;
            for (jj=0; jj < @(nu_); jj++, pA0 += lda2, pr+=@(ku), pi+=@(ku))
            {
               ATL_UINT ii;
               for (ii=0; ii < @(ku_); ii++)
               {
                  @SKIP rA[i+ii] = @(malp)p[ii];
                  @SKIP @callproc doElement pA 0 (ii<<1) pr pi ii
                  @callproc doElement pA 0 ii*2 pr pi ii
               }
            }
@ENDPROC
@SKIP *** handles single element for cleanup
@SKIP *** NOTE: **** FIXME: call doElement with k2=0
@BEGINPROC doCuElement A_ j_ rA_ iA_ ib_ 
            @mif nalp ! "X
@ROUT ATL_ccm2am cammmtst
            @(rA_)[@(ib_)] = @(malp)@(A_)@(j_)[i];
            #ifdef Conj_
               @(iA_)[@(ib_)] = @(calp)@(A_)@(j_)[i+1];
            #else
               @(iA_)[@(ib_)] = @(malp)@(A_)@(j_)[i+1];
            #endif
@ROUT ATL_cam2cm
            @(A_)@(j_)[i] = @(malp)@(rA_)[@(ib_)];
            #ifdef Conj_
               @(A_)@(j_)[i+1] = @(calp)@(iA_)[@(ib_)];
            #else
               @(A_)@(j_)[i+1] = @(malp)@(iA_)[@(ib_)];
            #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
            @mif nalp = "X
@ROUT ATL_ccm2am cammmtst
            rv = @(A_)@(j_)[i];
            #ifdef Conj_
               iv = -@(A_)@(j_)[i+1];
            #else
               iv = @(A_)@(j_)[i+1];
            #endif
            @(rA_)[@(ib_)] = rv*ra - iv*ia;
            @(iA_)[@(ib_)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm
            rv = @(rA_)[@(ib_)];
            #ifdef Conj_
               iv = -@(iA_)[@(ib_)];
            #else
               iv = @(iA_)[@(ib_)];
            #endif
            @(A_)@(j_)[i] = rv*ra - iv*ia;
            @(A_)@(j_)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
@ENDPROC
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockNuKu
   @define j @dum@
   @define ib @dum@
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp ib @(j) @(ku) *
            @callproc doCuElement A @(j) rA iA @(ib) 
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef j
@ENDPROC
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockRolled nu_
   @define k @dum@
            ATL_UINT jj;
            @(cnst)TYPE *pA0 = A0;
            @(cnstb)TYPE *pr = rA, *pi = iA;
            for (jj=0; jj < @(nu_); jj++, pA0 += lda2, pr+=@(ku), pi+=@(ku))
            {
               @SKIP rA[i] = @(malp)p[0];
               @callproc doCuElement pA 0 pr pi 0 
            }
   @undef k
@ENDPROC 
@SKIP *** this proc handles K-cleanup block 
@BEGINPROC doKCuBlockNu nu_
   @define j @dum@
   @define ib @dum@
      @iexp j 0 
      @iwhile j < @(nu_)
         @iexp ib @(j) @(ku) *
            @SKIP A@(j)[i] = @(malp)b[@(ib)];
            @callproc doCuElement A @(j) rA iA @(ib)
         @iexp j @(j) 1 +
      @endiwhile
   @undef ib
   @undef j
@ENDPROC 
@ROUT ATL_cam2cm
void ATL_USERCPMM
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for rA,iA */
   const TYPE *rA,      /* access-ku-major block holding real(A) */
   const TYPE *iA,      /* access-ku-major block holding imag(A) */
   TYPE *A,             /* OUTPUT: submatrix to copy rA/iA to */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_ccm2am cammmtst
/*
 * This routine copies the KxN submatrix A into access-k-vlen-major storage.
 * In this storage, @(nu) vectors of @(ku) length are taken from the
 * @(nu) columns of A and stored in a @(ku)x@(nu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(N/nu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then the last block in the K-panel will be zero padded, and
 * the same is true for the NU portion of the last K-panel if nu does not
 * evenly divide N.
 */
@beginskip
#ifdef Conj_
void Mjoin(PATL,cm2am_a@(nalp)_@(ku)x@(nu)C)
#else
void Mjoin(PATL,cm2am_a@(nalp)_@(ku)x@(nu))
#endif
@endskip
@ROUT cammmtst
#ifdef NO_CM2AM
   void ATL_cm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*, ATL_CSZT, 
                  TYPE*,TYPE*);
#else
void ATL_cm2am
@ROUT ATL_ccm2am 
void ATL_USERCPMM
@ROUT ATL_ccm2am cammmtst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-ku-major block holding real(A) */
   TYPE *iA             /* OUTPUT: access-ku-major block holding imag(A) */
)
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
{
   ATL_CSZT n = (N/@(nu))*@(nu), k = (K/@(ku))*@(ku), nr=N-n;
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku);
   ATL_CSZT K2=K+K, lda2 = lda+lda, incA = lda2*@(nu), k2 = k+k, KK2=KK+KK;
   ATL_SZT i, j;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
@iexp NA1 1
@iif @iexp 0 @(ML_NUR) ! 0 @(CU_NUR) ! |
   @iexp NA1 0
@endiif 
@iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif NA1 ! 0
   @(cnst)TYPE *A0=A;
@endiif
   @iexp binc @(nu) @(ku) *

   for (j=0; j < n; j += @(nu))
   {
      for (i=0; i < k2; i += @(ku2), rA += @(binc), iA += @(binc))
      {
      @iif ML_NUKU ! 0
         @callproc doBlockNuKu 
      @endiif
      @iif ML_NUKU = 0
         @iif ML_KUR ! 0
            @callproc doBlockKu @(nu) 
         @endiif
         @iif ML_NUR ! 0
            @callproc doBlockNu @(ku) 
         @endiif
         @iif ML_NO ! 0
            @callproc doBlockRolled @(nu) @(ku) 
         @endiif
      @endiif
      }
      if (k != KK)
      {
@ROUT ATL_ccm2am cammmtst
   @iif CU_NUKU = 0
         ATL_UINT ii, jj;
         TYPE *pr = rA, *pi = iA;
         for (jj=0; jj < @(nu); jj++, pr+=@(ku), pi+=@(ku))
            for (ii=0; ii < @(ku); ii++)
               pr[ii] = pi[ii] = 0.0;
   @endiif
   @iif CU_NUKU ! 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            iA[@(ib)] = rA[@(ib)] = 
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
                    0.0;
      @endiwhile
   @endiif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         for (; i < K2; i += 2, rA++, iA++)
         {
            @iif CU_NUKU ! 0
               @callproc doKCuBlockNuKu 
            @endiif
            @iif CU_NUKU = 0
               @iif CU_NUR ! 0
                  @callproc doKCuBlockNu @(nu)
               @endiif
               @iif CU_NUR = 0
                  @callproc doKCuBlockRolled @(nu)
               @endiif
            @endiif
         }
         rA += @(binc) - K + k;
         iA += @(binc) - K + k;
      }
   @iif NA1 = 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
      @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif NA1 ! 0
      A0 += incA;
   @endiif
   }
@iif CU_NUKU ! 0 
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < k2; i += @(ku2), rA += @(binc), iA += @(binc))
      {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp k2 @(k) @(k) +
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            @mif nalp ! "X
@ROUT ATL_ccm2am cammmtst
            rA[@(ib)] = @(malp)A@(j)[i+@(k2)];
            #ifdef Conj_
               iA[@(ib)] = @(calp)A@(j)[i+@(k2)+1];
            #else
               iA[@(ib)] = @(malp)A@(j)[i+@(k2)+1];
            #endif
@ROUT ATL_cam2cm
            A@(j)[i+@(k2)] = @(malp)rA[@(ib)];
            #ifdef Conj_
               A@(j)[i+@(k2)+1] = @(calp)iA[@(ib)];
            #else
               A@(j)[i+@(k2)+1] = @(malp)iA[@(ib)];
            #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
            @mif nalp = "X
@ROUT ATL_ccm2am cammmtst
            rv = A@(j)[i+@(k2)];
            #ifdef Conj_
               iv = -A@(j)[i+@(k2)+1];
            #else
               iv = A@(j)[i+@(k2)+1];
            #endif
            rA[@(ib)] = rv*ra - iv*ia;
            iA[@(ib)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm
            rv = rA[@(ib)];
            #ifdef Conj_
               iv = -iA[@(ib)];
            #else
               iv = iA[@(ib)];
            #endif
            A@(j)[i+@(k2)] = rv*ra - iv*ia;
            A@(j)[i+@(k2)+1] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
            @endmif
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_ccm2am cammmtst
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            iA[@(ib)] = rA[@(ib)] = 0.0;
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
      }
      if (k != KK)
      {
@ROUT ATL_ccm2am cammmtst
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp k 0 0 +
         @iwhile k < @(ku)
            @iexp k2 @(k) @(k) +
            @iexp ib @(j) @(ku) *
            @iexp ib @(ib) @(k) +
            iA[@(ib)] = rA[@(ib)] = 
            @iexp k @(k) 1 +
         @endiwhile
         @iexp j @(j) 1 +
                    0.0;
      @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         for (; i < K2; i += 2, rA++, iA++)
         {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp ib @(j) @(ku) *
         @mif nalp ! "X
@ROUT ATL_ccm2am cammmtst
            rA[@(ib)] = @(malp)A@(j)[i];
            #ifdef Conj_
               iA[@(ib)] = @(calp)A@(j)[i+1];
            #else
               iA[@(ib)] = @(malp)A@(j)[i+1];
            #endif
@ROUT ATL_cam2cm
            A@(j)[i] = @(malp)rA[@(ib)];
            #ifdef Conj_
               A@(j)[i+1] = @(calp)iA[@(ib)];
            #else
               A@(j)[i+1] = @(malp)iA[@(ib)];
            #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
         @mif nalp = "X
@ROUT ATL_ccm2am cammmtst
            rv = A@(j)[i];
            #ifdef Conj_
               iv = -A@(j)[i+1];
            #else
               iv = A@(j)[i+1];
            #endif
            rA[@(ib)] = rv*ra - iv*ia;
            iA[@(ib)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm
            rv = rA[@(ib)];
            #ifdef Conj_
               iv = -iA[@(ib)];
            #else
               iv = iA[@(ib)];
            #endif
            A@(j)[i] = rv*ra - iv*ia;
            A@(j)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_ccm2am cammmtst
      @iwhile j < @(nu)
         @iexp ib @(j) @(ku) *
            iA[@(ib)] = rA[@(ib)] = 0.0;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         }
         rA += @(binc) - K + k;
         iA += @(binc) - K + k;
      }
      break;
      @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@iif CU_NUKU = 0
   if (nr) /* N-cleanup */
   {
      for (i=0; i < k2; i += @(ku2), rA += @(binc), iA += @(binc))
      {
      @iif CU_KUR ! 0
         @callproc doBlockKu nr
      @endiif
      @iif CU_KUR = 0
         @callproc doBlockRolled nr @(ku)
      @endiif
@ROUT ATL_ccm2am cammmtst
         /* zero padding */
         for (; jj < @(nu); jj++, pr+=@(ku), pi+=@(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 
         @iwhile j < @(ku)
            pr[@(j)] = pi[@(j)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT ii;
            for (ii=0; ii < @(ku); ii++)
               pr[ii] = pi[ii] = 0.0;
      @endiif
         }
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
      }
      if (k != KK)
      {
@ROUT ATL_ccm2am cammmtst
      /* zero padding the whole block first*/ 
      @SKIP @iif CU_NO ! 0
         ATL_UINT ii, jj;
         TYPE *pr = rA, *pi = iA; 
         for (jj=0; jj < @(nu); jj++, pr+=@(ku), pi+=@(ku))
            for (ii=0; ii < @(ku); ii++)
               pi[ii] = pr[ii] = 0.0;
      @SKIP @endiif
      @BEGINSKIP ***skipping unrolling the zero padding when not fully unrolled     
      @iif CU_NO = 0
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k 0 0 +
            @iwhile k < @(ku)
               @iexp ib @(j) @(ku) *
               @iexp ib @(ib) @(k) +
               iA[@(ib)] = rA[@(ib)] =
               @iexp k @(k) 1 +
            @endiwhile
            @iexp j @(j) 1 +
                    0.0;
         @endiwhile
      @endiif
      @ENDSKIP 
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         for (; i < K2; i+=2, rA++, iA++)
         {
            @callproc doKCuBlockRolled nr 
@ROUT ATL_ccm2am cammmtst
            /* zero padding */
            for (; jj < @(nu); jj++, pr+=@(ku), pi+=@(ku))
               pr[0] = pi[0] = 0.0;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         }
         rA += @(binc) - K + k;
         iA += @(binc) - K + k;
      }
   }
@endiif
}
@ROUT cammmtst `#endif`
@endiif
@iif kmaj = 0
@SKIP *** handles single cell
@BEGINPROC doElement A_ j_ rA_ iA_  
         @mif nalp = "X
@ROUT ATL_ccm2am cammmtst
            rv = @(A_)@(j_)[i];
            #ifdef Conj_
               iv = -@(A_)@(j_)[i+1];
            #else
               iv = @(A_)@(j_)[i+1];
            #endif
            @(rA_)[@(j_)] = rv*ra - iv*ia;
            @(iA_)[@(j_)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm
            rv = @(rA_)[@(j_)];
            #ifdef Conj_
               iv = -@(iA_)[@(j_)];
            #else
               iv = @(iA_)[@(j_)];
            #endif
            @(A_)@(j_)[i] = rv*ra - iv*ia;
            @(A_)@(j_)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
         @mif nalp ! "X
@ROUT ATL_ccm2am cammmtst
            @(rA_)[@(j_)] = @(malp)@(A_)@(j_)[i];
            #ifdef Conj_
               @(iA_)[@(j_)] = @(calp)@(A_)@(j_)[i+1];
            #else
               @(iA_)[@(j_)] = @(malp)@(A_)@(j_)[i+1];
            #endif
@ROUT ATL_cam2cm
            @(A_)@(j_)[i] = @(malp)@(rA_)[@(j_)];
            #ifdef Conj_
               @(A_)@(j_)[i+1] = @(calp)@(iA_)[@(j_)];
            #else
               @(A_)@(j_)[i+1] = @(malp)@(iA_)[@(j_)];
            #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
@ENDPROC
@SKIP *** handles block unrolled 
@BEGINPROC doBlockNu nu_
      @iexp j 0 0 +
      @iwhile j < @(nu_)
         @callproc doElement A @(j) rA iA  
      @iexp j @(j) 1 +
      @endiwhile
@ENDPROC
@SKIP *** handles one block rolled 
@BEGINPROC doBlockRolled nu_
         ATL_UINT jj;
         @(cnst)TYPE *pA0 = A0;
         @(cnstb)TYPE *pr = rA, *pi = iA;
         for (jj=0; jj < @(nu_); jj++, pA0 += lda2, pr++, pi++)
         {
            @callproc doElement pA 0 pr pi 
         }
@ENDPROC
@SKIP *** Handles cleanup rolled block only 
@BEGINPROC doCuBlockRolled 
         @callproc doBlockRolled nr
         for (; jj < @(nu); jj++, pr++, pi++)
            pr[0] = pi[0] = ATL_rzero;
@ENDPROC
@SKIP *** zero padding on K dimension
@BEGINPROC doKzeroPadRolled
      for (i=0; i < KR; i++, rA += @(nu), iA += @(nu))
      {
         ATL_UINT ii; 
         for (ii=0; ii < @(nu); ii++)
            rA[ii] = iA[ii] = ATL_rzero;
      }
@ENDPROC
@ROUT ATL_cam2cm
@beginskip
#ifdef Conj_
void Mjoin(PATL,am2cm_a@(nalp)_@(nu)C) /* access-major blk to col-major array */
#else
void Mjoin(PATL,am2cm_a@(nalp)_@(nu)) /* access-major blk to col-major array */
#endif
@endskip
void ATL_USERCPMM       /* col-major matx to access-major blk */
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *rA,      /* access-major block holding real(A) */
   const TYPE *iA,      /* access-major block holding imag(A) */
   TYPE *A,             /* OUTPUT: submatrix to cpy access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_ccm2am cammmtst
/*
 * This routine copies the KxN submatrix A into the KxCEIL(N/@(nu)) block b.
 * b is stored in access-major storage, where the @(nu) unrolled accesses
 * are assumed to come from the columns of A.
 * More specifically, each Kx@(nu) column panel of A is copied into a
 * @(nu)xK region of b, and if the last such column panel is partial, it
 * is zero padded.
 * For GEMM, this routine handles Notrans B matrices, and Trans A matrices.
 */
@beginskip
#ifdef Conj_
void Mjoin(PATL,cm2am_a@(nalp)_@(nu)C) /* col-access matx to access-major blk */
#else
void Mjoin(PATL,cm2am_a@(nalp)_@(nu)) /* col-access matx to access-major blk */
#endif
@endskip
@ROUT ATL_ccm2am 
void ATL_USERCPMM       /* col-major matx to access-major blk */
@ROUT cammmtst  
void ATL_cm2am
#ifdef NO_CM2AM
   void ATL_cm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*, ATL_CSZT, 
                  TYPE*,TYPE*);
#else
@ROUT ATL_ccm2am cammmtst
(
   ATL_CSZT K,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-major block holding real(A) */
   TYPE *iA             /* OUTPUT: access-major block holding imag(A) */
)
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
{
   ATL_CSZT K2=K+K, lda2=lda+lda, n = (N/@(nu))*@(nu), incA = lda2*@(nu);
   ATL_CSZT nr = N-n;
   @iif ku > 1
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku), KR=KK-K;
@ROUT ATL_cam2cm  `   ATL_CINT ZINC = KR*@(nu)`
   @endiif
   ATL_SZT i, j;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
   @iexp nu2 @(nu) @(nu) +
@iexp NA1 1
@iif @iexp 0 @(ML_NUR) ! 0 @(CU_NUR) ! |
   @iexp NA1 0
@endiif 
   @iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @endiif
   @iif NA1 ! 0
   @(cnst)TYPE *A0 = A;
   @endiif
   for (j=0; j < n; j += @(nu))
   {
      for (i=0; i < K2; i += 2, rA += @(nu), iA += @(nu))
      {
         @iif ML_NUR ! 0
            @callproc doBlockNu @(nu)
         @endiif
         @iif ML_NUR = 0
            @callproc doBlockRolled @(nu)
         @endiif
      }
   @iif ku > 1
@ROUT ATL_cam2cm
      rA += ZINC;
      iA += ZINC;
@ROUT ATL_ccm2am cammmtst
   @iif ML_NUR ! 0
      for (i=0; i < KR; i++, rA += @(nu), iA += @(nu))
      @iexp j 0
      @iwhile j < @(nu)
         rA[@(j)] = iA[@(j)] =
      @iexp j @(j) 1 +
      @endiwhile
                         ATL_rzero;
   @endiif
   @iif ML_NUR = 0
      @callproc doKzeroPadRolled
   @endiif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
   @endiif
   @iif NA1 = 0
      @iexp j 0 0 +
      @iwhile j < @(nu)
      A@(j) += incA;
      @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif NA1 ! 0
      A0 += incA;
   @endiif
   }
   @mif nu ! "1
@iif CU_NUR ! 0
   switch(N-n)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
      @iexp j @(n) -1 + 
   case @(n):
      for (i=0; i < K2; i += 2, rA += @(nu), iA += @(nu))
      {
      @iexp j 0 0 +
      @iwhile j < @(n)
         @mif nalp = "X
@ROUT ATL_ccm2am cammmtst
         rv = A@(j)[i];
         #ifdef Conj_
            iv = -A@(j)[i+1];
         #else
            iv = A@(j)[i+1];
         #endif
         rA[@(j)] = rv*ra - iv*ia;
         iA[@(j)] = rv*ia + iv*ra;
@ROUT ATL_cam2cm
         rv = rA[@(j)];
         #ifdef Conj_
            iv = -iA[@(j)];
         #else
            iv = iA[@(j)];
         #endif
         A@(j)[i] = rv*ra - iv*ia;
         A@(j)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
         @mif nalp ! "X
@ROUT ATL_ccm2am cammmtst
         rA[@(j)] = @(malp)A@(j)[i];
         #ifdef Conj_
            iA[@(j)] = @(calp)A@(j)[i+1];
         #else
            iA[@(j)] = @(malp)A@(j)[i+1];
         #endif
@ROUT ATL_cam2cm
         A@(j)[i] = @(malp)rA[@(j)];
         #ifdef Conj_
            A@(j)[i+1] = @(calp)iA[@(j)];
         #else
            A@(j)[i+1] = @(malp)iA[@(j)];
         #endif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
         @endmif
      @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_ccm2am cammmtst
      @iwhile j < @(nu)
         rA[@(j)] = iA[@(j)] = ATL_rzero;
      @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
      }
@ROUT ATL_ccm2am cammmtst
   @iif ku > 1
      for (i=0; i < KR; i++, rA += @(nu), iA += @(nu))
      @iexp j 0
      @iwhile j < @(nu)
         rA[@(j)] = iA[@(j)] =
      @iexp j @(j) 1 +
      @endiwhile
                         ATL_rzero;
    @endiif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
@endiif
@iif CU_NUR = 0
   if (nr)
   {
      for (i=0; i < K2; i += 2, rA += @(nu), iA += @(nu))
      {
         @callproc doCuBlockRolled 
      }
@ROUT ATL_ccm2am cammmtst
   @iif ku > 1
      @callproc doKzeroPadRolled 
   @endiif
@ROUT ATL_cam2cm ATL_ccm2am cammmtst
   }
@endiif
   @endmif
}
@ROUT cammmtst `#endif`
@endiif
@ROUT ATL_am2rm ATL_rm2am ammmtst
@iif kmaj ! 0
   @define ku @@(kmaj)@
@SKIP **** handles full block fully unrolled 
@BEGINPROC doBlockMuKu mu_ ku_
   @define i @dum@
   @define j @dum@
   @define ip @dum@
   @iexp i 0 0 +
   @iwhile i < @(mu_)
      @iexp j 0 0 +
      @iwhile j < @(ku_)
         @iexp ip @(i) @(ku_) *
         @iexp ip @(ip) @(j) +
@ROUT ATL_am2rm
         A@(j)[i+@(i)] = @(malp)pp[@(ip)];
@ROUT ATL_rm2am ammmtst
         pp[@(ip)] = @(malp)A@(j)[i+@(i)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i @(i) 1 +
   @endiwhile
   @undef ip
   @undef j
   @undef i
@ENDPROC
@SKIP **** handles full block unrolled MU  
@BEGINPROC doBlockMu ku_ 
   @define j @dum@
   @define ip @dum@
         ATL_UINT jj;
         @(cnst)TYPE *rA = A0;
         @(cnstb)TYPE *p = pp;
         for(jj=0; jj < @(ku_); jj++, rA +=lda, p++) 
         {
      @iexp j 0 
      @iwhile j < @(mu)
         @iexp ip @(j) @(ku) *
@ROUT ATL_am2rm
            rA[i+@(j)] = @(malp)p[@(ip)];
@ROUT ATL_rm2am ammmtst
            p[@(ip)] = @(malp)rA[i+@(j)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
         }
   @undef ip
   @undef j
@ENDPROC
@SKIP **** handles full block unrolled KU  
@BEGINPROC doBlockKu mu_ 
   @define j @dum@
         ATL_UINT ii;
         @(cnstb)TYPE *p = pp;
         for(ii=0; ii < @(mu_); ii++, p+=@(ku)) 
         {
      @iexp j 0 0 +
      @iwhile j < @(ku)
@ROUT ATL_am2rm
            A@(j)[i+ii] = @(malp)p[@(j)];
@ROUT ATL_rm2am ammmtst
            p[@(j)] = @(malp)A@(j)[i+ii];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
         }
   @undef j
@ENDPROC
@SKIP **** handles full block rolled 
@BEGINPROC doBlockRolled mu_ ku_ 
         ATL_UINT jj;
         @(cnst)TYPE *rA = A0;
         @(cnstb)TYPE *p = pp;
         for(jj=0; jj < @(ku_); jj++, rA +=lda, p++)
         {
            ATL_UINT ii;
            @(cnstb)TYPE *w = p;
            for(ii=0; ii < @(mu_); ii++, w+=@(ku_)) 
            {
@ROUT ATL_am2rm
               rA[i+ii] = @(malp)(*w);
@ROUT ATL_rm2am ammmtst
               *w = @(malp)rA[i+ii];
@ROUT ATL_am2rm ATL_rm2am ammmtst
            }
         }
@ENDPROC
@SKIP ****** handles K-cleanup in rolled, without zero padding 
@BEGINPROC doKCuBlockRolled mu_ ku_
         ATL_UINT jj;
         @(cnst)TYPE *rA = A0;
         @(cnstb)TYPE *p = pp;
         for(jj=0; jj < @(ku_); jj++, rA +=lda, p++)
         {
            ATL_UINT ii;
            @(cnstb)TYPE *w = p;
            for(ii=0; ii < @(mu_); ii++, w+=@(ku)) 
@ROUT ATL_am2rm
               rA[i+ii] = @(malp)(*w);
@ROUT ATL_rm2am ammmtst
               *w = @(malp)rA[i+ii];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         }
@ENDPROC
@ROUT ATL_am2rm
void ATL_USERCPMM       /* access-major blk to row-major matrix */
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* INPUT: access-major block to copy to A */
   TYPE *A,             /* OUTPUT: matrix copied from access-major block */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_rm2am ammmtst
/*
 * This routine copies the MxK submatrix A into access-k-vlen-major storage.
 * In this storage, @(mu) vectors of @(ku) length are taken from the
 * @(mu) rows of A and stored in a @(ku)x@(mu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(M/mu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then subblocks in some K-panels will be zero padded.
 * If mu does not evenly divide M, then some subblocks in the last
 * K-panel will be entirely 0.
 */
@skip void Mjoin(PATL,rm2am_a@(nalp)_@(ku)x@(mu)) /* row-access matrix to access-major      block */
@ROUT ammmtst
#ifdef NO_RM2AM
   void ATL_rm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);
#else
void ATL_rm2am
@ROUT ATL_rm2am
void ATL_USERCPMM       /* row-major matrix to access-major block */
@ROUT ATL_rm2am ammmtst
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding condensed A */
)
@ROUT ATL_am2rm ATL_rm2am ammmtst
{
   ATL_CSZT MM = ((M+@(mu)-1)/@(mu))*@(mu), KK = ((K+@(ku)-1)/@(ku))*@(ku);
   ATL_CSZT pansz = @(mu)*KK, m = M/@(mu)*@(mu), mr = M-m, incA = @(ku)*lda;
   ATL_CSZT k = (K/@(ku))*@(ku), kr = K-k;
   ATL_SZT i, j;
@iexp NA1 1
@iif @iexp 0 @(ML_KUR) ! 0 @(CU_KUR) ! |
   @iexp NA1 0
@endiif 
@iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @iexp j 0 1 +
      @iwhile j < @(ku)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif NA1 ! 0
   @(cnst)TYPE *A0=A;
@endiif
   @iexp incb @(ku) @(mu) *

   for (j=0; j < k; j += @(ku), b += @(incb))
   {
      @(cnstb)TYPE *pp = b;   /* panel ptr */

      for (i=0; i < m; i += @(mu), pp += pansz)
      {
         @iif ML_NUKU ! 0
            @callproc doBlockMuKu @(mu) @(ku)
         @endiif
         @iif ML_NUKU = 0
            @iif ML_NUR ! 0 
               @callproc doBlockMu @(ku)
            @endiif
            @iif ML_KUR ! 0 
               @callproc doBlockKu @(mu)
            @endiif
            @iif ML_NO ! 0
               @callproc doBlockRolled @(mu) @(ku)
            @endiif
         @endiif
      }
      if (m != M) /* M cleanup */
      {
         @(cnstb)TYPE *p;
/*
 *       Copy partial M remainder subblock
 */
         for (p=pp; i < M; i++, p += @(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(ku)
@ROUT ATL_rm2am ammmtst
            p[@(j)] = @(malp)A@(j)[i];
@ROUT ATL_am2rm
            A@(j)[i] = @(malp)p[@(j)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT jj;
            @(cnst)TYPE *rA = A0;
            for (jj=0; jj < @(ku); jj++, rA+=lda)
               p[jj] = rA[i];
      @endiif
         }
@ROUT ATL_rm2am ammmtst
/*
 *       Zero rest of M remainder subblock
 */
         for (; i < MM; i++, p += @(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(ku)
            p[@(j)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT jj;
            for (jj=0; jj < @(ku); jj++)
               p[jj] = 0.0;
      @endiif
         }
@ROUT ATL_am2rm ATL_rm2am ammmtst
      }
@iif NA1 = 0
/*
 * Update column-ptrs from A
 */
   @iexp j 0 0 +
   @iwhile j < @(ku)
      A@(j) += incA;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif NA1 ! 0
      A0 += incA;
@endiif
   }
/*
 * Check for final, partial K-panel that needs to be padded wt zeros
 */
@iif CU_NUKU ! 0
   switch(K-k)
   {
   @iexp r @(ku) -1 +
   @iwhile r > 0
   case @(r):
      {
         @(cnstb)TYPE *pp = b;   /* panel ptr */

         for (i=0; i < m; i += @(mu), pp += pansz)
         {
   @iexp i 0 0 +
   @iwhile i < @(mu)
      @iexp j 0 0 +
      @iwhile j < @(r)
         @iexp ip @(i) @(ku) *
         @iexp ip @(ip) @(j) +
@ROUT ATL_am2rm
            A@(j)[i+@(i)] = @(malp)pp[@(ip)];
@ROUT ATL_rm2am ammmtst
            pp[@(ip)] = @(malp)A@(j)[i+@(i)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_rm2am ammmtst
      @iwhile j < @(ku)
         @iexp ip @(i) @(ku) *
         @iexp ip @(ip) @(j) +
            pp[@(ip)] = 0.0;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_am2rm ATL_rm2am ammmtst
      @iexp i @(i) 1 +
   @endiwhile
         }
         if (m != M)
         {
            @(cnstb)TYPE *p;
/*
 *          Copy partial M remainder subblock
 */
            for (p=pp; i < M; i++, p += @(ku))
            {
   @iexp j 0 0 +
   @iwhile j < @(r)
@ROUT ATL_am2rm
               A@(j)[i] = @(malp)p[@(j)];
@ROUT ATL_rm2am ammmtst
               p[@(j)] = @(malp)A@(j)[i];
@ROUT ATL_am2rm ATL_rm2am ammmtst
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_rm2am ammmtst
   @iwhile j < @(ku)
               p[@(j)] = 0.0;
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_am2rm ATL_rm2am ammmtst
            }
@ROUT ATL_rm2am ammmtst
/*
 *          Zero rest of M remainder subblock
 */
            for (; i < MM; i++, p += @(ku))
            {
   @iexp j 0 0 +
   @iwhile j < @(ku)
               p[@(j)] = 0.0;
      @iexp j @(j) 1 +
   @endiwhile
            }
@ROUT ATL_am2rm ATL_rm2am ammmtst
         }
      }
      break;
      @iexp r @(r) -1 +
   @endiwhile
   default:;
   }
@endiif
@iif CU_NUKU = 0
   if (kr)
   {
      @(cnstb)TYPE *pp = b;   /* panel ptr */
      for (i=0; i < m; i += @(mu), pp += pansz)
      {
         @iif CU_NUR ! 0
            @callproc doBlockMu kr
         @endiif
         @iif CU_NUR = 0
            @callproc doKCuBlockRolled @(mu) kr
         @endiif
@ROUT ATL_rm2am ammmtst
         /* zero padding */
         for (; jj < @(ku); jj++, p++)
         {
      @iif CU_NUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(mu)
            @iexp ip @(j) @(ku) *
            p[@(ip)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_NUR = 0
            ATL_UINT ii;
            TYPE *w = p;
            for (ii=0; ii < @(mu); ii++, w+=@(ku))
               *w = 0.0;
      @endiif
         }
@ROUT ATL_am2rm ATL_rm2am ammmtst
      }
      if (m != M)
      {
         @(cnstb)TYPE *p = pp; 
         for ( ; i < M; i++, p+=@(ku))
         {
            ATL_UINT jj;
            @(cnst)TYPE *rA = A0;
            for (jj=0; jj < kr; jj++, rA+=lda)
@ROUT ATL_rm2am ammmtst
               p[jj] = @(malp)rA[i];
            for ( ; jj < @(ku); jj++)
               p[jj] = 0.0;
         }
/*
 *       Zero rest of M remainder subblock
 */
         for (; i < MM; i++, p += @(ku))
         {
            ATL_UINT jj;
            for (jj=0; jj < @(ku); jj++)
               p[jj] = 0.0;
@ROUT ATL_am2rm
               rA[i] = @(malp)p[jj];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         }
      }
   }
@endiif
}
@ROUT ammmtst `#endif`
@endiif
@ROUT ammmtst
   @define dupB @1@
@ROUT ATL_am2rm ATL_rm2am ammmtst
@iif kmaj = 0
@SKIP *** handles block unrolled 
@BEGINPROC doBlockMU mu_
   @define i @dum@
   @define k @dum@
   @define ik @dum@
      @iexp i 0 0 +
      @iwhile i < @(mu_)
         @iexp ik @(dupB) @(i) *
@ROUT ATL_rm2am ammmtst
         @iexp k @(dupB) -1 +
         @iwhile k > 0
         pp[@(ik)+@(k)] =
            @iexp k @(k) -1 +
         @endiwhile
         pp[@(ik)] = @(malp)A[@(i)];
@ROUT ATL_am2rm
         A[@(i)] = @(malp)pp[@(ik)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
      @iexp i @(i) 1 +
      @endiwhile
   @undef ik 
   @undef k 
   @undef i 
@ENDPROC
@SKIP *** handles block rolled
@BEGINPROC doBlockRolled mu_
         ATL_UINT ii;
      @iif dupB = 1
         for (ii=0; ii < @(mu_); ii++)
         {
@ROUT ATL_rm2am ammmtst
            pp[ii] = @(malp)A[ii];
@ROUT ATL_am2rm
            A[ii] = @(malp)*pp[ii];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         }
      @endiif
      @iif dupB > 1
         @(cnstb)TYPE *p = pp;
         for (ii=0; ii < @(mu_); ii++, p+=@(dupB))
         {
@ROUT ATL_rm2am ammmtst
            ATL_UINT jj;
            TYPE a0 = A[ii];
            for (jj=0; jj < @(dupB); jj++)
               p[jj] = @(malp)a0;
@ROUT ATL_am2rm
            A[ii] = @(malp)p[0];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         }
      @endiif
@ENDPROC
@ROUT ATL_am2rm
@beginskip
@iif dupB > 1
void Mjoin(PATL,am2rm_a@(nalp)_@(mu)d@(dupB)) /* access-major blk to row-maj submatrix */
@endiif
@iif dupB < 2
void Mjoin(PATL,am2rm_a@(nalp)_@(mu)) /* access-major blk to row-major submatrix */
@endiif
@endskip
void ATL_USERCPMM       /* access-major blk to row-major submatrix */
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* INPUT: access-major block holding condensed A */
   TYPE *A,             /* OUTPUT: submatrix copied frm access-major b */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_rm2am ammmtst
/*
 * This routine copies the MxK submatrix A into the KxCEIL(M/@(mu)) block b.
 * b is stored in access-major storage, where the @(mu) unrolled accesses
 * are assumed to come from the rows of A.
 * It is for M-vectorized kernels.
 * More specifically, the @(mu)xK row panel of A becomes a @(mu)xK region
 * in b, and if the last such row panel is partial, it is zero padded.
 * For GEMM, this routine handles Notrans A matrices, and Trans B matrices.
 */
@ROUT ammmtst
#ifdef NO_RM2AM
   void ATL_rm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*,ATL_CSZT,TYPE*);
#else
void ATL_rm2am          /* row-access matrix to access-major block */
@ROUT ATL_rm2am
void ATL_USERCPMM       /* row-access matrix to access-major block */
@ROUT ATL_rm2am ammmtst
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *b              /* OUTPUT: access-major block holding condensed A */
)
@ROUT ATL_am2rm ATL_rm2am ammmtst
{
   ATL_CSZT m = M/@(mu)*@(mu), mr = M-m, incA = lda - m;
   @iif ku > 1
   ATL_CSZT KK = ((K+@(ku)-1)/@(ku))*@(ku), pansz=@(mu)*KK;
@ROUT ATL_rm2am ammmtst `   ATL_CUINT KR=KK-K;`
   @endiif
   @iif ku < 2
   ATL_CSZT pansz = @(mu)*K;
   @endiif
   ATL_SZT i, j;
   @iexp incV @(mu) @(dupB) *

   for (j=0; j < K; j++, b += @(incV), A += incA)
   {
      @(cnstb)TYPE *pp = b;  /* panel ptr */
      for (i=0; i < m; i += @(mu), pp += pansz, A += @(mu))
      {
      @iif ML_NUR ! 0
         @callproc doBlockMU @(mu)
      @endiif 
      @iif ML_NUR = 0
         @callproc doBlockRolled @(mu) 
      @endiif
      }
      @mif mu ! "1
         @iif CU_NUR ! 0
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @iexp i 0 0 +
         @iwhile i < @(n)
            @iexp ik @(dupB) @(i) *
@ROUT ATL_am2rm
         A[@(i)] = @(malp)pp[@(ik)];
@ROUT ATL_rm2am ammmtst
            @iexp k @(dupB) -1 +
            @iwhile k > 0
         pp[@(ik)+@(k)] =
               @iexp k @(k) -1 +
            @endiwhile
         pp[@(ik)] = @(malp)A[@(i)];
@ROUT ATL_am2rm ATL_rm2am ammmtst
         @iexp i @(i) 1 +
         @endiwhile
@ROUT ATL_rm2am ammmtst
         @iwhile i < @(mu)
            @iexp ik @(dupB) @(i) *
            @iexp k @(dupB) -1 +
            @iwhile k > 0
         pp[@(ik)+@(k)] =
               @iexp k @(k) -1 +
            @endiwhile
         pp[@(ik)] = ATL_rzero;
         @iexp i @(i) 1 +
         @endiwhile
@ROUT ATL_am2rm ATL_rm2am ammmtst
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
         @endiif
         @iif CU_NUR = 0
      if (mr)
      {
            @callproc doBlockRolled mr 
@ROUT ATL_rm2am ammmtst
      @iif dupB = 1
         for (; ii < @(mu); ii++)
            pp[ii] = ATL_rzero;
      @endiif
      @iif dupB > 1
         @(cnstb)TYPE *p = pp;
         for (; ii < @(mu); ii++, p+=@(dupB))
         {
            ATL_UINT jj;
            for (jj=0; jj < @(dupB); jj++)
               p[jj] = ATL_rzero;
         }
      @endiif
@ROUT ATL_am2rm ATL_rm2am ammmtst
      }
         @endiif
      @endmif
   }
@ROUT ATL_rm2am ammmtst
   @iif ku > 1
   if (KR)  /* need zero padding if @(ku) (K unroll) doesn't divide K */
   {
      for (i=0; i < M; i += @(mu), b += pansz)  /* loop over all panels */
      {
      @iif ku > 2
         TYPE *pp = b;
         for (j=0; j < KR; j++, pp += @(mu)) /* zero KR*mu block */
      @iif CU_KUR ! 0
         @iexp i 0
         @iwhile i < @(mu)
            pp[@(i)] =
         @iexp i @(i) 1 +
         @endiwhile
                    ATL_rzero;
      @endiif
      @iif CU_KUR = 0
         {
            ATL_UINT ii;
            for (ii=0; ii < @(mu); ii++)
               pp[ii] = ATL_rzero;
         }
      @endiif
      @endiif
      @iif ku == 2
      @iif CU_NUR ! 0
         @iexp i 0
         @iwhile i < @(mu)
         b[@(i)] =
         @iexp i @(i) 1 +
         @endiwhile
                 ATL_rzero;
      @endiif
      @iif CU_NUR = 0
         ATL_UINT ii;
         for (ii=0; ii < @(mu); ii++)
            b[ii] = ATL_rzero;
      @endiif
      @endiif
      }
   }
   @endiif
@ROUT ATL_am2rm ATL_rm2am ammmtst
}
@ROUT ammmtst `#endif`
@endiif
@ROUT ammmtst
   @undef dupB
@ROUT ATL_cam2rm ATL_crm2am cammmtst
@iif kmaj ! 0
   @define ku @@(kmaj)@
@SKIP ***** handles single element 
@BEGINPROC doElement A_ j_ i2_ pr_ pi_ ib_
         @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
               @(pr_)[@(ib_)] = @(malp)@(A_)@(j_)[i+@(i2_)];
               #ifdef Conj_
                  @(pi_)[@(ib_)] = @(calp)@(A_)@(j_)[i+@(i2_)+1];
               #else
                  @(pi_)[@(ib_)] = @(malp)@(A_)@(j_)[i+@(i2_)+1];
               #endif
@ROUT ATL_cam2rm
               @(A_)@(j_)[i+@(i2_)] = @(malp)@(pr_)[@(ib_)];
               #ifdef Conj_
                  @(A_)@(j_)[i+@(i2_)+1] = @(calp)@(pi_)[@(ib_)];
               #else
                  @(A_)@(j_)[i+@(i2_)+1] = @(malp)@(pi_)[@(ib_)];
               #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @mif nalp = "X
@ROUT ATL_crm2am cammmtst
               rv = @(A_)@(j_)[i+@(i2_)];
               #ifdef Conj_
                  iv = -@(A_)@(j_)[i+@(i2_)+1];
               #else
                  iv = @(A_)@(j_)[i+@(i2_)+1];
               #endif
               @(pr_)[@(ib_)] = rv*ra - iv*ia;
               @(pi_)[@(ib_)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
               rv = @(pr_)[@(ib_)];
               #ifdef Conj_
                  iv = -@(pi_)[@(ib_)];
               #else
                  iv = @(pi_)[@(ib_)];
               #endif
               @(A_)@(j_)[i+@(i2_)] = rv*ra - iv*ia;
               @(A_)@(j_)[i+@(i2_)+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
@ENDPROC
@SKIP handles block 
@BEGINPROC doBlockMuKu mu_ ku_ 
   @define i @dum@
   @define i2 @dum@
   @define j @dum@
   @define ip @dum@
   @iexp i 0 0 +
   @iwhile i < @(mu_)
      @iexp i2 @(i) @(i) +
      @iexp j 0 0 +
      @iwhile j < @(ku_)
         @iexp ip @(i) @(ku_) *
         @iexp ip @(ip) @(j) +
            @callproc doElement A @(j) @(i2) pr pi @(ip) 
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i @(i) 1 +
   @endiwhile
   @undef ip
   @undef j
   @undef i2
   @undef i
@ENDPROC
@SKIP **** handles full block unrolled MU  
@BEGINPROC doBlockMu ku_ 
   @define j @dum@
   @define i2 @dum@
   @define ip @dum@
         ATL_UINT jj;
         @(cnst)TYPE *pA0 = A0;
         @(cnstb)TYPE *pr0 = pr, *pi0 = pi;
         for(jj=0; jj < @(ku_); jj++, pA0 +=lda2, pr0++, pi0++) 
         {
      @iexp j 0 
      @iwhile j < @(mu)
         @iexp i2 @(j) @(j) +
         @iexp ip @(j) @(ku) *
            @callproc doElement pA 0 @(i2) pr0 pi0 @(ip) 
         @iexp j @(j) 1 +
      @endiwhile
         }
   @undef ip
   @undef i2
   @undef j
@ENDPROC
@SKIP **** handles full block unrolled KU  
@BEGINPROC doBlockKu mu_ 
   @define j @dum@
   @define kk @dum@
         ATL_UINT ii;
         @(cnstb)TYPE *pr0 = pr, *pi0 = pi;
         @iexp kk @(mu_) @(mu_) +
         for(ii=0; ii < @(kk); ii+=2, pr0+=@(ku), pi0+=@(ku)) 
         {
      @iexp j 0 0 +
      @iwhile j < @(ku)
            @SKIP A@(j)[i+ii] = @(malp)p[@(j)];
         @callproc doElement A @(j) ii pr0 pi0 @(j) 
         @iexp j @(j) 1 +
      @endiwhile
         }
   @undef kk
   @undef j
@ENDPROC
@SKIP **** handles full block rolled 
@BEGINPROC doBlockRolled mu_ ku_ 
   @define kk @dum@
         ATL_UINT jj;
         @(cnst)TYPE *pA0 = A0;
         @(cnstb)TYPE *pr0 = pr, *pi0 = pi;
         for(jj=0; jj < @(ku_); jj++, pA0 +=lda2, pr0++, pi0++)
         {
            ATL_UINT ii;
            @(cnstb)TYPE *rw = pr0, *iw = pi0;
            @iexp kk @(mu_) @(mu_) +
            for(ii=0; ii < @(kk); ii+=2, rw+=@(ku), iw+=@(ku)) 
            {
               @callproc doElement pA 0 ii rw iw 0 
            }
         }
   @undef kk
@ENDPROC
@SKIP *** FIXME: modify doElement with work with 
@BEGINPROC doCuElement A_ j_ rr_ ii_ ip_ 
      @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
               @(rr_)[@(ip_)] = @(malp)@(A_)@(j_)[i];
               #ifdef Conj_
                  @(ii_)[@(ip_)] = @(calp)@(A_)@(j_)[i+1];
               #else
                  @(ii_)[@(ip_)] = @(malp)@(A_)@(j_)[i+1];
               #endif
@ROUT ATL_cam2rm
               @(A_)@(j_)[i] = @(malp)@(rr_)[@(ip_)];
               #ifdef Conj_
                  @(A_)@(j_)[i+1] = @(calp)@(ii_)[@(ip_)];
               #else
                  @(A_)@(j_)[i+1] = @(malp)@(ii_)[@(ip_)];
               #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      @endmif
      @mif nalp = "X
@ROUT ATL_crm2am cammmtst
               rv = @(A_)@(j_)[i];
               #ifdef Conj_
                  iv = -@(A_)@(j_)[i+1];
               #else
                  iv = @(A_)@(j_)[i+1];
               #endif
               @(rr_)[@(ip_)] = rv*ra - iv*ia;
               @(ii_)[@(ip_)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
               rv = @(rr_)[@(ip_)];
               #ifdef Conj_
                  iv = -@(ii_)[@(ip_)];
               #else
                  iv = @(ii_)[@(ip_)];
               #endif
               @(A_)@(j_)[i] = rv*ra - iv*ia;
               @(A_)@(j_)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      @endmif
@ENDPROC 
@SKIP **** handles full block unrolled MU  
@BEGINPROC doCuBlockMu ku_ 
   @define j @dum@
   @define i2 @dum@
   @define ip @dum@
         ATL_UINT jj;
         @(cnst)TYPE *pA0 = A0;
         @(cnstb)TYPE *pr0 = pr, *pi0 = pi;
         for(jj=0; jj < @(ku_); jj++, pA0 +=lda2, pr0++, pi0++) 
         {
      @iexp j 0 
      @iwhile j < @(mu)
         @iexp i2 @(j) @(j) +
         @iexp ip @(j) @(ku) *
            @callproc doElement pA 0 @(i2) pr0 pi0 @(ip) 
         @iexp j @(j) 1 +
      @endiwhile
         }
   @undef ip
   @undef i2
   @undef j
@ENDPROC
@SKIP **** handles K-cleanup block rolled FIXME: no diff with doBlockRolled!!! 
@BEGINPROC doKCuBlockRolled mu_ ku_ 
   @define kk @dum@
         ATL_UINT jj;
         @(cnst)TYPE *pA0 = A0;
         @(cnstb)TYPE *pr0 = pr, *pi0 = pi;
         for(jj=0; jj < @(ku_); jj++, pA0 +=lda2, pr0++, pi0++)
         {
            ATL_UINT ii;
            @(cnstb)TYPE *rw = pr0, *iw = pi0;
            @iexp kk @(mu_) @(mu_) +
            for(ii=0; ii < @(kk); ii+=2, rw+=@(ku), iw+=@(ku)) 
            {
               @callproc doElement pA 0 ii rw iw 0 
            }
         }
   @undef kk 
@ENDPROC
@ROUT ATL_cam2rm
void ATL_USERCPMM       /* access- to row-major */
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *rA,      /* access-maj blk holding condensed real(A) */
   const TYPE *iA,      /* access-maj blk holding condensed imag(A) */
   TYPE *A,             /* OUTPUT: matrix copied from access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_crm2am cammmtst
/*
 * This routine copies the MxK submatrix A into access-k-vlen-major storage.
 * In this storage, @(mu) vectors of @(ku) length are taken from the
 * @(mu) rows of A and stored in a @(ku)x@(mu) subblock.
 * CEIL(K/ku) of these subblocks are stored together to make a K-panel.
 * The CEIL(M/mu) K-panels are stored contiguously.  If ku does not evenly
 * divide K then subblocks in some K-panels will be zero padded.
 * If mu does not evenly divide M, then some subblocks in the last
 * K-panel will be entirely 0.
 */
@beginskip
#ifdef Conj_
void Mjoin(PATL,rm2am_a@(nalp)_@(ku)x@(mu)C) /* row- to access-major */
#else
void Mjoin(PATL,rm2am_a@(nalp)_@(ku)x@(mu))  /* row- to access-major */
#endif
@endskip
@ROUT cammmtst
#ifdef NO_RM2AM
   void ATL_rm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*, ATL_CSZT, 
                  TYPE*,TYPE*);
#else
void ATL_rm2am          /* row- to access-major */
@ROUT ATL_crm2am
void ATL_USERCPMM       /* row- to access-major */
@ROUT ATL_crm2am cammmtst
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-maj blk holding condensed real(A) */
   TYPE *iA             /* OUTPUT: access-maj blk holding condensed imag(A) */
)
@ROUT ATL_cam2rm ATL_crm2am cammmtst
{
   @iexp mu2 @(mu) @(mu) +
   ATL_CSZT MM = ((M+@(mu)-1)/@(mu))*@(mu), KK = ((K+@(ku)-1)/@(ku))*@(ku);
   ATL_CSZT pansz = @(mu)*KK, m = M/@(mu)*@(mu), mr = M-m, k = (K/@(ku))*@(ku);
   ATL_CSZT K2=K+K, m2 = m+m, lda2=lda+lda, M2 = M+M, incA = @(ku)*lda2;
   ATL_CSZT kr = K-k;
   ATL_SZT i, j;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif
@iexp NA1 1
@iif @iexp 0 @(ML_KUR) ! 0 @(CU_KUR) ! |
   @iexp NA1 0
@endiif 
@iif NA1 = 0
   @declare "   @(cnst)TYPE " n n ";"
      *A0=A
      @iexp j 0 1 +
      @iwhile j < @(ku)
         @iexp i @(j) -1 +
         *A@(j)=A@(i)+lda2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
@endiif
@iif NA1 ! 0
   @(cnst)TYPE *A0=A;
@endiif
   @iexp incb @(ku) @(mu) *

   for (j=0; j < k; j += @(ku), rA += @(incb), iA += @(incb))
   {
      @(cnstb)TYPE *pr = rA, *pi = iA;   /* panel ptrs */

      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
         @iif ML_NUKU ! 0
            @callproc doBlockMuKu @(mu) @(ku) 
         @endiif 
         @iif ML_NUKU = 0
            @iif ML_NUR ! 0 
               @callproc doBlockMu @(ku)
            @endiif
            @iif ML_KUR ! 0 
               @callproc doBlockKu @(mu)
            @endiif
            @iif ML_NO ! 0
               @callproc doBlockRolled @(mu) @(ku)
            @endiif
         @endiif
      }
      if (m != M)
      {
         @(cnstb)TYPE *rr, *ii;
/*
 *       Copy partial M remainder subblock
 */
         for (rr=pr, ii=pi; i < M2; i += 2, rr += @(ku), ii += @(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(ku)
            @callproc doCuElement A @(j) rr ii @(j) 
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT jj;
            @(cnst)TYPE *pA0 = A0;
            for (jj=0; jj < @(ku); jj++, pA0+=lda2)
            {
               @callproc doCuElement pA 0 rr ii jj 
            }
      @endiif
         }
@ROUT ATL_crm2am cammmtst
/*
 *       Zero rest of M remainder subblock
 */
         for (i=M; i < MM; i++, rr += @(ku), ii += @(ku))
         {
      @iif CU_KUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(ku)
            ii[@(j)] = rr[@(j)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_KUR = 0
            ATL_UINT jj;
            for (jj=0; jj < @(ku); jj++)
               ii[jj] = rr[jj] = 0.0;
      @endiif
         }
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      }
@iif NA1 = 0
/*
 * Update column-ptrs from A
 */
   @iexp j 0 0 +
   @iwhile j < @(ku)
      A@(j) += incA;
      @iexp j @(j) 1 +
   @endiwhile
@endiif
@iif NA1 ! 0
      A0 += incA;
@endiif
   }
/*
 * Check for final, partial K-panel that needs to be padded wt zeros
 */
@iif CU_NUKU ! 0
   switch(K-k)
   {
   @iexp r @(ku) -1 +
   @iwhile r > 0
   case @(r):
      {
         @(cnstb)TYPE *pr = rA, *pi = iA;   /* panel ptrs */

         for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
         {
   @iexp i 0 0 +
   @iwhile i < @(mu)
      @iexp i2 @(i) @(i) +
      @iexp j 0 0 +
      @iwhile j < @(r)
         @iexp ip @(i) @(ku) *
         @iexp ip @(ip) @(j) +
         @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
            pr[@(ip)] = @(malp)A@(j)[i+@(i2)];
            #ifdef Conj_
               pi[@(ip)] = @(calp)A@(j)[i+@(i2)+1];
            #else
               pi[@(ip)] = @(malp)A@(j)[i+@(i2)+1];
            #endif
@ROUT ATL_cam2rm
            A@(j)[i+@(i2)] = @(malp)pr[@(ip)];
            #ifdef Conj_
               A@(j)[i+@(i2)+1] = @(calp)pi[@(ip)];
            #else
               A@(j)[i+@(i2)+1] = @(malp)pi[@(ip)];
            #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @mif nalp = "X
@ROUT ATL_crm2am cammmtst
            rv = A@(j)[i+@(i2)];
            #ifdef Conj_
               iv = -A@(j)[i+@(i2)+1];
            #else
               iv = A@(j)[i+@(i2)+1];
            #endif
            pr[@(ip)] = rv*ra - iv*ia;
            pi[@(ip)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
            rv =  pr[@(ip)];
            #ifdef Conj_
               iv = -pi[@(ip)];
            #else
               iv = pi[@(ip)];
            #endif
            A@(j)[i+@(i2)] = rv*ra - iv*ia;
            A@(j)[i+@(i2)+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_crm2am cammmtst
      @iwhile j < @(ku)
         @iexp ip @(i) @(ku) *
         @iexp ip @(ip) @(j) +
            pi[@(ip)] = pr[@(ip)] = 0.0;
         @iexp j @(j) 1 +
      @endiwhile
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      @iexp i @(i) 1 +
   @endiwhile
         }
         if (m != M)
         {
            @(cnstb)TYPE *rr, *ii;
/*
 *          Copy partial M remainder subblock
 */
            for (rr=pr, ii=pi; i < M2; i += 2, rr += @(ku), ii += @(ku))
            {
   @iexp j 0 0 +
   @iwhile j < @(r)
      @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
               rr[@(j)] = @(malp)A@(j)[i];
               #ifdef Conj_
                  ii[@(j)] = @(calp)A@(j)[i+1];
               #else
                  ii[@(j)] = @(malp)A@(j)[i+1];
               #endif
@ROUT ATL_cam2rm
               A@(j)[i] = @(malp)rr[@(j)];
               #ifdef Conj_
                  A@(j)[i+1] = @(calp)ii[@(j)];
               #else
                  A@(j)[i+1] = @(malp)ii[@(j)];
               #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      @endmif
      @mif nalp = "X
@ROUT ATL_crm2am cammmtst
               rv = A@(j)[i];
               #ifdef Conj_
                  iv = -A@(j)[i+1];
               #else
                  iv = A@(j)[i+1];
               #endif
               rr[@(j)] = rv*ra - iv*ia;
               ii[@(j)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
               rv = rr[@(j)];
               #ifdef Conj_
                  iv = -ii[@(j)];
               #else
                  iv = ii[@(j)];
               #endif
               A@(j)[i] = rv*ra - iv*ia;
               A@(j)[i+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      @endmif
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_crm2am cammmtst
   @iwhile j < @(ku)
               ii[@(j)] = rr[@(j)] = 0.0;
      @iexp j @(j) 1 +
   @endiwhile
@ROUT ATL_cam2rm ATL_crm2am cammmtst
            }
@ROUT ATL_crm2am cammmtst
/*
 *          Zero rest of M remainder subblock
 */
            for (i=M; i < MM; i++, rr += @(ku), ii += @(ku))
            {
   @iexp j 0 0 +
   @iwhile j < @(ku)
               ii[@(j)] = rr[@(j)] = 0.0;
      @iexp j @(j) 1 +
   @endiwhile
            }
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         }
      }
      break;
      @iexp r @(r) -1 +
   @endiwhile
   default:;
   }
@endiif
@iif CU_NUKU = 0
   if (kr)
   {
      @(cnstb)TYPE *pr = rA, *pi = iA;   /* panel ptrs */
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
         @iif CU_NUR ! 0
            @callproc doCuBlockMu kr
         @endiif
         @iif CU_NUR = 0
         @callproc doKCuBlockRolled @(mu) kr
         @endiif
@ROUT ATL_crm2am cammmtst
         /* zero padding */
         for(; jj < @(ku); jj++, pr0++, pi0++) 
         {
      @iif CU_NUR ! 0
         @iexp j 0 0 +
         @iwhile j < @(mu)
            @iexp ip @(j) @(ku) *
            pi0[@(ip)] = pr0[@(ip)] = 0.0;
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif CU_NUR = 0
            ATL_UINT kk;
            TYPE *rw = pr0, *iw = pi0;
            for (kk=0; kk < @(mu); kk++, rw+=@(ku), iw+=@(ku))
               *rw = *iw = 0.0;
      @endiif 
         }
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      }
      if (m != M)
      {
         @(cnstb)TYPE *rr, *ii;
/*
 *       Copy partial M remainder subblock
 */
         for (rr=pr, ii=pi; i < M2; i += 2, rr += @(ku), ii += @(ku))
         {
            ATL_UINT jj; 
            @(cnst)TYPE *pA0 = A0;
            for (jj=0; jj < kr; jj++, pA0+=lda2)
            {
@ROUT ATL_crm2am cammmtst
               @callproc doCuElement pA 0 rr ii jj 
            }
            for (; jj < @(ku); jj++)
               rr[jj] = ii[jj] = 0.0;
         }
/*
 *       zero rest of M remainder subblock 
 */
         for (i=M; i < MM; i++, rr+=@(ku), ii+=@(ku))
         {
            ATL_UINT jj;
            for (jj=0; jj < @(ku); jj++)
               rr[jj] = ii[jj] = 0.0;
         }
@ROUT ATL_cam2rm 
               @callproc doCuElement pA 0 rr ii jj 
            }
         }
@ROUT ATL_cam2rm ATL_crm2am cammmtst
      }
   }
@endiif
}
@ROUT cammmtst `#endif`
@endiif
@iif kmaj = 0
@SKIP *** handles single cell 
@BEGINPROC doElement A_ i2_ pr_ pi_ i_
         @mif nalp = "X
@ROUT ATL_crm2am cammmtst
            rv = @(A_)[@(i2_)];
            #ifdef Conj_
               iv = -@(A_)[@(i2_)+1];
            #else
               iv = @(A_)[@(i2_)+1];
            #endif
            @(pr_)[@(i_)] = rv*ra - iv*ia;
            @(pi_)[@(i_)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
            rv = @(pr_)[@(i_)];
            #ifdef Conj_
               iv = -@(pi_)[@(i_)];
            #else
               iv = @(pi_)[@(i_)];
            #endif
            @(A_)[@(i2_)] = rv*ra - iv*ia;
            @(A_)[@(i2_)+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
            @(pr_)[@(i_)] = @(malp)@(A_)[@(i2_)];
            #ifdef Conj_
               @(pi_)[@(i_)] = @(calp)@(A_)[@(i2_)+1];
            #else
               @(pi_)[@(i_)] = @(malp)@(A_)[@(i2_)+1];
            #endif
@ROUT ATL_cam2rm
            @(A_)[@(i2_)] = @(malp)@(pr_)[@(i_)];
            #ifdef Conj_
               @(A_)[@(i2_)+1] = @(calp)@(pi_)[@(i_)];
            #else
               @(A_)[@(i2_)+1] = @(malp)@(pi_)[@(i_)];
            #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
@ENDPROC
@SKIP *** handles single block unrolled 
@BEGINPROC doBlockMu
   @define i @dum@
   @define i2 @dum@
      @iexp i 0 0 +
      @iwhile i < @(mu)
         @iexp i2 @(i) @(i) +
         @callproc doElement A @(i2) pr pi @(i)
      @iexp i @(i) 1 +
      @endiwhile
   @undef i2
   @undef i
@ENDPROC
@SKIP *** handles single block unrolled 
@BEGINPROC doBlockRolled mu_
         ATL_UINT ii;
         for (ii=0; ii < @(mu_); ii++)
         {
            @callproc doElement A (ii<<1) pr pi ii
         }
@ENDPROC
@SKIP *** handles single cleanup block unrolled 
@BEGINPROC doCuBlockRolled mu_
         @callproc doBlockRolled @(mu_)
         for (; ii < @(mu); ii++)
            pr[ii] = pi[ii] = ATL_rzero;
@ENDPROC
@ROUT ATL_cam2rm
@beginskip
#ifdef Conj_
void Mjoin(PATL,am2rm_a@(nalp)_@(mu)C)
#else
void Mjoin(PATL,am2rm_a@(nalp)_@(mu))
#endif
@endskip
void ATL_USERCPMM       /* access- to row-major */
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *rA,      /* access-maj blk holding condensed real(A) */
   const TYPE *iA,      /* access-maj blk holding condensed imag(A) */
   TYPE *A,             /* OUTPUT: submatrix dest for access-major blk */
   ATL_CSZT lda         /* stride between row elements */
)
@ROUT ATL_crm2am cammmtst
/*
 * This routine copies the MxK submatrix A into the KxCEIL(M/@(mu)) blks rA,iA.
 * ?A are stored in access-major storage, where the @(mu) unrolled accesses
 * are assumed to come from the rows of A.
 * It is for M-vectorized storage.
 * More specifically, the @(mu)xK row panel of A becomes a @(mu)xK region
 * in b, and if the last such row panel is partial, it is zero padded.
 * For GEMM, this routine handles Notrans A matrices, and Trans B matrices.
 */
@ROUT cammmtst
#ifdef NO_RM2AM
   void ATL_rm2am(ATL_CSZT,ATL_CSZT,const SCALAR,const TYPE*, ATL_CSZT, 
                  TYPE*,TYPE*);
#else
void ATL_rm2am          /* row- to access-major */
@ROUT ATL_crm2am
void ATL_USERCPMM       /* row- to access-major */
@ROUT ATL_crm2am cammmtst
(
   ATL_CSZT K,          /* number of columns in A */
   ATL_CSZT M,          /* number of rows in A */
   const SCALAR alpha,  /* scalar for A */
   const TYPE *A,       /* matrix to be copied to access-major format */
   ATL_CSZT lda,        /* stride between row elements */
   TYPE *rA,            /* OUTPUT: access-maj blk holding condensed real(A) */
   TYPE *iA             /* OUTPUT: access-maj blk holding condensed imag(A) */
)
@ROUT ATL_cam2rm ATL_crm2am cammmtst
{
   @iexp mu2 @(mu) @(mu) +
   ATL_CSZT m = M/@(mu)*@(mu), mr = M-m, incA = (lda - m)<<1;
   @iif ku > 1
   ATL_CSZT KK=((K+@(ku)-1)/@(ku))*@(ku), pansz = @(mu)*KK;
@ROUT ATL_crm2am cammmtst `   ATL_UINT KR = KK-K;`
   @endiif
   @iif ku < 2
   ATL_CSZT pansz = @(mu)*K;
   @endiif
   ATL_CSZT m2 = m+m;
   ATL_SZT i, j;
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rv, iv;
   @endmif

   for (j=0; j < K; j++, rA += @(mu), iA += @(mu), A += incA)
   {
      @(cnstb)TYPE *pr = rA, *pi = iA;  /* panel ptrs */
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz, A += @(mu2))
      {
      @iif ML_NUR ! 0
         @callproc doBlockMu
      @endiif
      @iif ML_NUR = 0
         @callproc doBlockRolled @(mu)
      @endiif
      }
      @mif mu ! "1
   @iif CU_NUR ! 0
      switch(mr)
      {
      @iexp n 1 0 +
      @iwhile n < @(mu)
      case @(n):
         @iexp i 0 0 +
         @iwhile i < @(n)
         @iexp i2 @(i) @(i) +
         @mif nalp = "X
@ROUT ATL_crm2am cammmtst
         rv = A[@(i2)];
         #ifdef Conj_
            iv = -A[@(i2)+1];
         #else
            iv = A[@(i2)+1];
         #endif
         pr[@(i)] = rv*ra - iv*ia;
         pi[@(i)] = rv*ia + iv*ra;
@ROUT ATL_cam2rm
         rv = pr[@(i)];
         #ifdef Conj_
            iv = -pi[@(i)];
         #else
            iv = pi[@(i)];
         #endif
         A[@(i2)] = rv*ra - iv*ia;
         A[@(i2)+1] = rv*ia + iv*ra;
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @mif nalp ! "X
@ROUT ATL_crm2am cammmtst
         pr[@(i)] = @(malp)A[@(i2)];
         #ifdef Conj_
            pi[@(i)] = @(calp)A[@(i2)+1];
         #else
            pi[@(i)] = @(malp)A[@(i2)+1];
         #endif
@ROUT ATL_cam2rm
         A[@(i2)] = @(malp)pr[@(i)];
         #ifdef Conj_
            A[@(i2)+1] = @(calp)pi[@(i)];
         #else
            A[@(i2)+1] = @(malp)pi[@(i)];
         #endif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         @endmif
         @iexp i @(i) 1 +
         @endiwhile
@ROUT ATL_crm2am cammmtst
         @iwhile i < @(mu)
         pr[@(i)] = pi[@(i)] = ATL_rzero;
         @iexp i @(i) 1 +
         @endiwhile
@ROUT ATL_cam2rm ATL_crm2am cammmtst
         break;
      @iexp n @(n) 1 +
      @endiwhile
      default:;
      }
   @endiif
   @iif CU_NUR = 0
      if (mr)
      {
         @callproc doCuBlockRolled mr
      }
   @endiif
      @endmif
   }
@ROUT ATL_crm2am cammmtst
   @iif ku > 1
   if (KR)  /* need zero padding if @(ku) (K unroll) doesn't divide K */
   {
      for (i=0; i < M; i += @(mu), iA += pansz, rA += pansz) 
      {                                 /* loop over all panels */
      @iif ku > 2
         TYPE *pr = rA, *pi = iA;
         for (j=0; j < KR; j++, pr += @(mu), pi += @(mu)) /* zero KR*mu block */
         @iif CU_KUR ! 0
         @iexp i 0
         @iwhile i < @(mu)
            pr[@(i)] = pi[@(i)] =
         @iexp i @(i) 1 +
         @endiwhile
                            ATL_rzero;
         @endiif
         @iif CU_KUR = 0
         {
            ATL_UINT ii;
            for (ii=0; ii < @(mu); ii++)
               pr[ii] = pi[ii] = ATL_rzero;
         }
         @endiif
      @endiif
      @iif ku == 2
         @iif CU_KUR ! 0
         @iexp i 0
         @iwhile i < @(mu)
         rA[@(i)] = iA[@(i)] =
         @iexp i @(i) 1 +
         @endiwhile
                         ATL_rzero;
         @endiif
         @iif CU_KUR = 0
            ATL_UINT ii;
            for (ii=0; ii < @(mu); ii++)
               rA[ii] = iA[ii] = ATL_rzero;
         @endiif
      @endiif
      }
   }
   @endiif
@ROUT ATL_cam2rm ATL_crm2am cammmtst
}
@ROUT cammmtst `#endif`
@endiif
@ROUT ammmtst
  @define beta @0@
  @define nbet @0@
@ROUT ATL_ablk2cmat blk2C_avx blk2C_sse
@beginproc cploops aligned vtyp ralp rbet
   @mif vtyp = "__m256
      @define velts @8@
      @define vadd @_mm256_add_ps@
      @define vsub @_mm256_sub_ps@
      @define vmul @_mm256_mul_ps@
      @define vld @_mm256_load_ps@
      @iif aligned = 0
         @define vldu @_mm256_loadu_ps@
         @define vstu @_mm256_storeu_ps@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm256_load_ps@
         @define vstu @_mm256_store_ps@
      @endiif
   @endmif
   @mif vtyp = "__m256d
      @define velts @4@
      @define vadd @_mm256_add_pd@
      @define vsub @_mm256_sub_pd@
      @define vmul @_mm256_mul_pd@
      @define vld @_mm256_load_pd@
      @iif aligned = 0
         @define vldu @_mm256_loadu_pd@
         @define vstu @_mm256_storeu_pd@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm256_load_pd@
         @define vstu @_mm256_store_pd@
      @endiif
   @endmif
   @mif vtyp = "__m128d
      @define velts @2@
      @define vadd @_mm_add_pd@
      @define vsub @_mm_sub_pd@
      @define vmul @_mm_mul_pd@
      @define vld @_mm_load_pd@
      @iif aligned = 0
         @define vldu @_mm_loadu_pd@
         @define vstu @_mm_storeu_pd@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm_load_pd@
         @define vstu @_mm_store_pd@
      @endiif
   @endmif
   @mif vtyp = "__m128
      @define velts @4@
      @define vadd @_mm_add_ps@
      @define vsub @_mm_sub_ps@
      @define vmul @_mm_mul_ps@
      @define vld @_mm_load_ps@
      @iif aligned = 0
         @define vldu @_mm_loadu_ps@
         @define vstu @_mm_storeu_ps@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm_load_ps@
         @define vstu @_mm_store_ps@
      @endiif
   @endmif
      for (j=0; j < n; j += @(nu), b += incb)
      {
         const TYPE *p = b;
         for (i=0; i < m; i += @(mu), p += pansz)
         {
            register @(vtyp) rC0, rc0;
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu)
         @iexp h 0 0 +
            rc0 = @(vld)(p+@(k));
         @mif nalp = "X
            rc0 = @(vmul)(rc0, @(ralp));
         @endmif
         @mif nbet = "0
            @mif nalp = "n
            rc0 = @(vmul)(rc0, @(ralp));
            @endmif
            @(vstu)(C@(j)+i+@(i), rc0);
            @iexp h 1 0 +
         @endmif
         @iif h = 0
            rC0 = @(vldu)(C@(j)+i+@(i));
            @mif nbet = "X
            rC0 = @(vmul)(rC0, @(rbet));
            @endmif
            @mif nalp = "n
               @mif nbet = "0
            rc0 = @(vmul)(rc0, @(ralp));
            @(vstu)(C@(j)+i+@(i), rc0);
                  @iexp h 1 0 +
               @endmif
               @mif nbet = "n
            rC0 = @(vadd)(rC0, rc0);
            rC0 = @(vmul)(rC0, @(ralp));
            @(vstu)(C@(j)+i+@(i), rC0);
                  @iexp h 1 0 +
               @endmif
               @iif h = 0
            rC0 = @(vsub)(rC0, rc0);
            @(vstu)(C@(j)+i+@(i), rC0);
                  @iexp h 1 0 +
               @endiif
            @endmif
            @iif h = 0
               @mif nbet = "n
            rc0 = @(vsub)(rc0, rC0);
            @(vstu)(C@(j)+i+@(i), rc0);
               @endmif
               @mif nbet ! "n
            rC0 = @(vadd)(rC0, rc0);
           @(vstu)(C@(j)+i+@(i), rC0);
               @endmif
            @endiif
         @endiif
         @iexp k @(k) @(velts) +
      @iexp i @(i) @(velts) +
      @endiwhile
   @iexp j @(j) 1 +
   @endiwhile
         }
      @mif mu ! "1
         switch(mr)
         {
      @iexp m 1 0 +
      @iwhile m < @(mu)
         case @(m):
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
         @mif nalp = "n
            @mif nbet = "X
            C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @mif nbet = "1
            C@(j)[i+@(i)] -= p[@(k)];
            @endmif
            @mif nbet = "0
            C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
            C@(j)[i+@(i)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
            C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)p[@(k)];
            @endmif
         @mif nbet = "1
            C@(j)[i+@(i)] += @(malp)p[@(k)];
            @endmif
            @mif nbet = "0
            C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
            C@(j)[i+@(i)] = @(malp)p[@(k)] - C@(j)[i+@(i)];
            @endmif
         @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
            break;
      @iexp m @(m) 1 +
      @endiwhile
         default:;
         }
      @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
         C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      }
   @undef velts
   @undef vadd
   @undef vsub 
   @undef vmul 
   @undef vld 
   @undef vldu 
   @undef vstu 
@endproc
/*
 *  C <- beta*C + alpha*b,
 *  C is an MxN matrix in column-major storage
 *  b is a CEIL(M/@(mu))*@(mu) x CEIL(N/@(nu))*@(nu) matrix stored in
 *    @(mu)x@(nu)-major storage
 */
@beginproc cpfunc vtyp
#include <immintrin.h>
   @mif vtyp = "__m256
      @define andC @0x1F@
      @define andL @7@
      @define vtyp2 @__m128@
      @define andC2 @0xF@
      @define andL2 @3@
      @define ibe @{beta,beta,beta,beta,beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha,alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
      @define ib2 @{beta,beta,beta,beta}@
      @define ia2 @{alpha,alpha,alpha,alpha}@
      @define in2 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m256d
      @define andC @0x1F@
      @define andL @3@
      @define vtyp2 @__m128d@
      @define andC2 @0xF@
      @define andL2 @1@
      @define ibe @{beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
      @define ib2 @{beta,beta,}@
      @define ia2 @{alpha,alpha}@
      @define in2 @{ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m128
      @define andC @0xF@
      @define andL @3@
      @define ibe @{beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m128d
      @define andC @0xF@
      @define andL @1@
      @define ibe @{beta,beta}@
      @define ial @{alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone}@
   @endmif

@skip void Mjoin(PATL,ablk2cmat_@(mu)x@(nu)_a@(nalp)_b@(nbet))
void ATL_USERCPMM       /* access-major C to col-major C */
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* matrix stored in @(mu)x@(nu)-major order */
   const SCALAR beta,   /* scalar for C */
   TYPE *C,             /* matrix to be copied to access-major format */
   ATL_CSZT ldc         /* stride between row elements */
)
{
   ATL_CINT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CINT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CINT incC = ldc*@(nu), incb = @(mu)*@(nu);
   ATL_INT i, j;
   @iexp URALP 0
   @mif nbet = "X
   const register @(vtyp) rBETA=@(ibe);
   @endmif
   @mif nbet = "n
   const register @(vtyp) rBETA=@(in1);
   @endmif
   @mif nalp = "X
   const register @(vtyp) rALP=@(ial);
      @iexp URALP 1
   @endmif
   @mif nalp = "n
   const register @(vtyp) rALP=@(in1);
      @iexp URALP 1
   @endmif
   @declare "   TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare

@ROUT ATL_ablk2cmat
/*
 * If C is aligned, use aligned load/stores to C
 */
   if (((((size_t)C) & @(andC))|(ldc&@(andL))) == 0)
   {
      @callproc cploops 1 @(vtyp) rALP rBETA
   }
   @mif andC = "0x1F
   else if (((((size_t)C) & @(andC2))|(ldc&@(andL2))) == 0)
   {
      @(vtyp2) ralp=@(ia2), rbet=@(ib2);
      @callproc cploops 1 @(vtyp2) ralp rbet
   }
   @endmif
   else
@ROUT ATL_ablk2cmat blk2C_avx blk2C_sse
   {
      @callproc cploops 0 @(vtyp) rALP rBETA
   }
   @mif nu ! "1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < m; i += @(mu), b += pansz)
      {
      @iexp k 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)b[@(k)];
            @endmif
            @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)b[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)b[@(k)] - C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)b[@(k)];
            @endmif
            @iexp k @(k) 1 +
         @iexp i @(i) 1 +
         @endiwhile
      @iexp j @(j) 1 +
      @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
               @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)b[@(k)] - C@(j)[i+@(i)];
               @endmif
               @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)b[@(k)];
               @endmif
               @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)b[@(k)];
               @endmif
               @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)b[@(k)];
               @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         b += incb;
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endmif
}
   @undef ial
   @undef ibe
   @undef in1
   @undef andC
   @undef andL
@endproc
@ROUT blk2C_avx 
#if defined(ATL_AVX) && defined(DREAL)
   @iif @iexp 0 4 @(mu) % !
   #error "MU must be a multiple of 4!"
   @endiif
   @callproc cpfunc __m256d
#endif
#if defined(ATL_AVX) && defined(SREAL)
   @iif @iexp 0 8 @(mu) % !
   #error "MU must be a multiple of 8!"
   @endiif
   @callproc cpfunc __m256
#endif
@ROUT blk2C_sse
#if defined(ATL_SSE2) && defined(DREAL)
   @iif @iexp 0 2 @(mu) % !
   #error "MU must be a multiple of 2!"
   @endiif
   @callproc cpfunc __m128d
#endif
#if defined(ATL_SSE1) && defined(SREAL)
   @iif @iexp 0 4 @(mu) % !
   #error "MU must be a multiple of 4!"
   @endiif
   @callproc cpfunc __m128
#endif
@ROUT ATL_ablk2cmat
@iexp vtst 4 @(mu) %
@iif vtst = 0
#if 0 && defined(ATL_AVX) && defined(DREAL)  /* AVX loses perf for unaligned */
   @callproc cpfunc __m256d
@endiif
@iif vtst ! 0
#if 0
@endiif
@iexp vtst 8 @(mu) %
@iif vtst = 0
#elif 0 && defined(ATL_AVX) && defined(SREAL) /* AVX loses perf for unaligned */
   @callproc cpfunc __m256
@endiif
@iif vtst ! 0
#elif 0
@endiif
@iexp vtst 2 @(mu) %
@iif vtst = 0
#elif defined(ATL_SSE2) && defined(DREAL) && defined(__GNUC__)
   @callproc cpfunc __m128d
@endiif
@iif vtst ! 0
#elif 0
@endiif
@iexp vtst 4 @(mu) %
@iif vtst = 0
#elif defined(SREAL) && defined(ATL_SSE1) && defined(__GNUC__)
   @callproc cpfunc __m128
@endiif
@iif vtst ! 0
#elif 0
@endiif
#else
@skip void Mjoin(PATL,ablk2cmat_@(mu)x@(nu)_a@(nalp)_b@(nbet))
void ATL_USERCPMM       /* access-major C to col-major C */
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *b,       /* matrix stored in @(mu)x@(nu)-major order */
   const SCALAR beta,   /* scalar for C */
   TYPE *C,             /* matrix to be copied to access-major format */
   ATL_CSZT ldc         /* stride between row elements */
)
{
   ATL_CINT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CINT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CINT incC = ldc*@(nu), incb = @(mu)*@(nu);
   ATL_INT i, j;
   @declare "   TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare

   for (j=0; j < n; j += @(nu), b += incb)
   {
      const TYPE *p = b;
      for (i=0; i < m; i += @(mu), p += pansz)
      {
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu)
         @mif nalp = "n
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @mif nbet = "1
         C@(j)[i+@(i)] -= p[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)p[@(k)];
            @endmif
         @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)p[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)p[@(k)] - C@(j)[i+@(i)];
            @endmif
         @endmif
         @iexp k @(k) 1 +
      @iexp i @(i) 1 +
      @endiwhile
   @iexp j @(j) 1 +
   @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
         @mif nalp = "n
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @mif nbet = "1
         C@(j)[i+@(i)] -= p[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)p[@(k)];
            @endmif
         @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)p[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)p[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)p[@(k)] - C@(j)[i+@(i)];
            @endmif
         @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
   @mif nu ! "1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < m; i += @(mu), b += pansz)
      {
      @iexp k 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)b[@(k)];
            @endmif
            @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)b[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)b[@(k)] - C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)b[@(k)];
            @endmif
            @iexp k @(k) 1 +
         @iexp i @(i) 1 +
         @endiwhile
      @iexp j @(j) 1 +
      @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
               @mif nbet = "n
         C@(j)[i+@(i)] = @(malp)b[@(k)] - C@(j)[i+@(i)];
               @endmif
               @mif nbet = "X
         C@(j)[i+@(i)] = beta*C@(j)[i+@(i)] + @(malp)b[@(k)];
               @endmif
               @mif nbet = "1
         C@(j)[i+@(i)] += @(malp)b[@(k)];
               @endmif
               @mif nbet = "0
         C@(j)[i+@(i)] = @(malp)b[@(k)];
               @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         b += incb;
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endmif
}
#endif
@ROUT ATL_cablk2cmat
/*
 *  C <- beta*C + alpha*b,
 *  C is an MxN matrix in column-major storage
 *  b is a CEIL(M/@(mu))*@(mu) x CEIL(N/@(nu))*@(nu) matrix stored in
 *    @(mu)x@(nu)-major storage
 */
@skip void Mjoin(PATL,ablk2cmat_@(mu)x@(nu)_a@(nalp)_b@(nbet))
void ATL_USERCPMM       /* access-major C to col-major C */
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for b */
   const TYPE *rC,      /* matrix stored in @(mu)x@(nu)-major order */
   const TYPE *iC,      /* matrix stored in @(mu)x@(nu)-major order */
   const SCALAR beta,   /* scalar for C */
   TYPE *C,             /* col-major array to write to */
   ATL_CSZT ldc         /* stride between row elements */
)
{
   ATL_CSZT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CSZT m2 = m+m;
   ATL_CSZT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CSZT ldc2 = ldc+ldc, incC = ldc2*@(nu), incb = @(mu)*@(nu);
   ATL_SZT i, j;
   @mif nbet = "X
   const register TYPE rb=(*beta), ib=beta[1];
   register TYPE rc, ic;
   @endmif
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rp, ip, rtmp;
   @endmif
   @declare "   TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @iexp mu2 @(mu) @(mu) +

   for (j=0; j < n; j += @(nu), rC += incb, iC += incb)
   {
      const TYPE *pr = rC, *pi = iC;
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu2)
         @mif nalp = "n
            @mif nbet = "X
            rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib - pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb - pi[@(k)];
            @endmif
            @mif nbet = "1
         C@(j)[i+@(i)] -= pr[@(k)];
         C@(j)[i+@(i)+1] -= pi[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = -pr[@(k)];
         C@(j)[i+@(i)+1] = -pi[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         C@(j)[i+@(i)+1] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
            @endmif
         @endmif
         @mif nalp = "1
            @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + pi[@(k)];
            @endmif
            @mif nbet = "1
         C@(j)[i+@(i)] += pr[@(k)];
         C@(j)[i+@(i)+1] += pi[@(k)];
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = pr[@(k)];
         C@(j)[i+@(i)+1] = pi[@(k)];
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = pr[@(k)] - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = pi[@(k)] - C@(j)[i+@(i)+1];
            @endmif
         @endmif
         @mif nalp = "X
         rtmp = rp = pr[@(k)];
         ip = pi[@(k)];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
            @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + rp;
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + ip;
            @endmif
            @mif nbet = "1
         C@(j)[i+@(i)] += rp;
         C@(j)[i+@(i)+1] += ip;
            @endmif
            @mif nbet = "0
         C@(j)[i+@(i)] = rp;
         C@(j)[i+@(i)+1] = ip;
            @endmif
            @mif nbet = "n
         C@(j)[i+@(i)] = rp - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = ip - C@(j)[i+@(i)+1];
            @endmif
         @endmif
         @iexp k @(k) 1 +
         @iexp i @(i) 2 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
      }
   @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iexp m2 @(m) @(m) +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m2)
               @mif nalp = "n
                  @mif nbet = "X
            rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib - pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb - pi[@(k)];
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] -= pr[@(k)];
         C@(j)[i+@(i)+1] -= pi[@(k)];
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = -pr[@(k)];
         C@(j)[i+@(i)+1] = -pi[@(k)];
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         C@(j)[i+@(i)+1] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                  @endmif
               @endmif
               @mif nalp = "1
                  @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + pi[@(k)];
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] += pr[@(k)];
         C@(j)[i+@(i)+1] += pi[@(k)];
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = pr[@(k)];
         C@(j)[i+@(i)+1] = pi[@(k)];
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = pr[@(k)] - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = pi[@(k)] - C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @mif nalp = "X
         rtmp = rp = pr[@(k)];
         ip = pi[@(k)];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                  @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + rp;
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + ip;
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] += rp;
         C@(j)[i+@(i)+1] += ip;
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = rp;
         C@(j)[i+@(i)+1] = ip;
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = rp - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = ip - C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @iexp k @(k) 1 + 
               @iexp i @(i) 2 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
   @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
   @mif nu ! "1
   switch(nr)
   {
      const TYPE *pr, *pi;
      @iexp n 1 0 +
      @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp i 0 0 +
            @iwhile i < @(mu2)
               @mif nalp = "n
                  @mif nbet = "X
            rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib - pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb - pi[@(k)];
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] -= pr[@(k)];
         C@(j)[i+@(i)+1] -= pi[@(k)];
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = -pr[@(k)];
         C@(j)[i+@(i)+1] = -pi[@(k)];
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         C@(j)[i+@(i)+1] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                  @endmif
               @endmif
               @mif nalp = "1
                  @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + pi[@(k)];
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] += pr[@(k)];
         C@(j)[i+@(i)+1] += pi[@(k)];
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = pr[@(k)];
         C@(j)[i+@(i)+1] = pi[@(k)];
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = pr[@(k)] - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = pi[@(k)] - C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @mif nalp = "X
         rtmp = rp = pr[@(k)];
         ip = pi[@(k)];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                  @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + rp;
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + ip;
                  @endmif
                  @mif nbet = "1
         C@(j)[i+@(i)] += rp;
         C@(j)[i+@(i)+1] += ip;
                  @endmif
                  @mif nbet = "0
         C@(j)[i+@(i)] = rp;
         C@(j)[i+@(i)+1] = ip;
                  @endmif
                  @mif nbet = "n
         C@(j)[i+@(i)] = rp - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = ip - C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @iexp i @(i) 2 +
               @iexp k @(k) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
      }
         @mif mu ! "1
      switch(mr)
      {
            @iexp m 1 0 +
            @iwhile m < @(mu)
      case @(m):
               @iexp j 0 0 +
               @iwhile j < @(n)
                  @iexp k @(mu) @(j) *
                  @iexp i 0 0 +
                  @iexp m2 @(m) @(m) +
                  @iwhile i < @(m2)
                     @mif nalp = "n
                        @mif nbet = "X
            rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib - pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb - pi[@(k)];
                        @endmif
                        @mif nbet = "1
         C@(j)[i+@(i)] -= pr[@(k)];
         C@(j)[i+@(i)+1] -= pi[@(k)];
                        @endmif
                        @mif nbet = "0
         C@(j)[i+@(i)] = -pr[@(k)];
         C@(j)[i+@(i)+1] = -pi[@(k)];
                        @endmif
                        @mif nbet = "n
         C@(j)[i+@(i)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         C@(j)[i+@(i)+1] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                        @endmif
                     @endmif
                     @mif nalp = "1
                        @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + pr[@(k)];
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + pi[@(k)];
                        @endmif
                        @mif nbet = "1
         C@(j)[i+@(i)] += pr[@(k)];
         C@(j)[i+@(i)+1] += pi[@(k)];
                        @endmif
                        @mif nbet = "0
         C@(j)[i+@(i)] = pr[@(k)];
         C@(j)[i+@(i)+1] = pi[@(k)];
                        @endmif
                        @mif nbet = "n
         C@(j)[i+@(i)] = pr[@(k)] - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = pi[@(k)] - C@(j)[i+@(i)+1];
                        @endmif
                     @endmif
                     @mif nalp = "X
         rtmp = rp = pr[@(k)];
         ip = pi[@(k)];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                        @mif nbet = "X
         rc = C@(j)[i+@(i)]; ic = C@(j)[i+@(i)+1];
         C@(j)[i+@(i)] = rc*rb - ic*ib + rp;
         C@(j)[i+@(i)+1] = rc*ib + ic*rb + ip;
                        @endmif
                        @mif nbet = "1
         C@(j)[i+@(i)] += rp;
         C@(j)[i+@(i)+1] += ip;
                        @endmif
                        @mif nbet = "0
         C@(j)[i+@(i)] = rp;
         C@(j)[i+@(i)+1] = ip;
                        @endmif
                        @mif nbet = "n
         C@(j)[i+@(i)] = rp - C@(j)[i+@(i)];
         C@(j)[i+@(i)+1] = ip - C@(j)[i+@(i)+1];
                        @endmif
                     @endmif
                     @iexp k @(k) 1 +
                     @iexp i @(i) 2 +
                  @endiwhile
                  @iexp j @(j) 1 +
               @endiwhile
         pr += pansz;
         pi += pansz;
         break;
               @iexp m @(m) 1 +
            @endiwhile
      default:;
      }
         @endmif
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endmif
}
@ROUT ATL_ccmat2ablk
/*
 *  b <- alpha*C + beta*b,
 *  C is an MxN matrix in column-major storage
 *  b is a CEIL(M/@(mu))*@(mu) x CEIL(N/@(nu))*@(nu) matrix stored in
 *    @(mu)x@(nu)-major storage
 */
@skip void Mjoin(PATL,cmat2ablk_@(mu)x@(nu)_a@(nalp)_b@(nbet))
void ATL_USERCPMM       /* col-major C to access-major C */
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for C */
   const TYPE *C,       /* col-major array to write from */
   ATL_CSZT ldc,        /* stride between row elements */
   const SCALAR beta,   /* scalar for b */
   TYPE *rC,            /* matrix to store in @(mu)x@(nu)-major order */
   TYPE *iC             /* matrix to store in @(mu)x@(nu)-major order */
)
{
   ATL_CSZT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CSZT m2 = m+m;
   ATL_CSZT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CSZT ldc2 = ldc+ldc, incC = ldc2*@(nu), incb = @(mu)*@(nu);
   ATL_SZT i, j;
   @mif nbet = "X
   const register TYPE rb=(*beta), ib=beta[1];
   register TYPE rc, ic;
   @endmif
   @mif nalp = "X
   const register TYPE ra=(*alpha), ia=alpha[1];
   register TYPE rp, ip, rtmp;
   @endmif
   @declare "  const TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc2
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare
   @iexp mu2 @(mu) @(mu) +

   for (j=0; j < n; j += @(nu), rC += incb, iC += incb)
   {
      TYPE *pr = rC, *pi = iC;
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu2)
         @mif nalp = "n
            @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib - C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb - C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "1
         pr[@(k)] -= C@(j)[i+@(i)];
         pi[@(k)] -= C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "0
         pr[@(k)] = -C@(j)[i+@(i)];
         pi[@(k)] = -C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "n
         pr[@(k)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         pi[@(k)] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
            @endmif
         @endmif
         @mif nalp = "1
            @mif nbet = "X
            rc = pr[@(k)]; ic = pr[@(k)];
         pr[@(k)] = rc*rb - ic*ib + C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb + C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "1
         pr[@(k)] += C@(j)[i+@(i)];
         pi[@(k)] += C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "0
         pr[@(k)] = C@(j)[i+@(i)];
         pi[@(k)] = C@(j)[i+@(i)+1];
            @endmif
            @mif nbet = "n
         pr[@(k)] = -pr[@(k)] + C@(j)[i+@(i)];
         pi[@(k)] = -pi[@(k)] + C@(j)[i+@(i)+1];
            @endmif
         @endmif
         @mif nalp = "X
         rtmp = rp = C@(j)[i+@(i)];
         ip = C@(j)[i+@(i)+1];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
            @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib + rp;
         pi[@(k)] = rc*ib + ic*rb + ip;
            @endmif
            @mif nbet = "1
         pr[@(k)] += rp;
         pi[@(k)] += ip;
            @endmif
            @mif nbet = "0
         pr[@(k)] = rp;
         pi[@(k)] = ip;
            @endmif
            @mif nbet = "n
         pr[@(k)] = rp - pr[@(k)];
         pi[@(k)] = ip - pi[@(k)];
            @endmif
         @endmif
         @iexp k @(k) 1 +
         @iexp i @(i) 2 +
      @endiwhile
      @iexp j @(j) 1 +
   @endiwhile
      }
   @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iexp m2 @(m) @(m) +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m2)
               @mif nalp = "n
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib - C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb - C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "1
         pr[@(k)] -= C@(j)[i+@(i)];
         pi[@(k)] -= C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = -C@(j)[i+@(i)];
         pi[@(k)] = -C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         pi[@(k)] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                  @endmif
               @endmif
               @mif nalp = "1
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pr[@(k)];
         pr[@(k)] = rc*rb - ic*ib + C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb + C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "1
         pr[@(k)] += C@(j)[i+@(i)];
         pi[@(k)] += C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = C@(j)[i+@(i)];
         pi[@(k)] = C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = -pr[@(k)] + C@(j)[i+@(i)];
         pi[@(k)] = -pi[@(k)] + C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @mif nalp = "X
         rtmp = rp = C@(j)[i+@(i)];
         ip = C@(j)[i+@(i)+1];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib + rp;
         pi[@(k)] = rc*ib + ic*rb + ip;
                  @endmif
                  @mif nbet = "1
         pr[@(k)] += rp;
         pi[@(k)] += ip;
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = rp;
         pi[@(k)] = ip;
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = rp - pr[@(k)];
         pi[@(k)] = ip - pi[@(k)];
                  @endmif
               @endmif
               @iexp k @(k) 1 + 
               @iexp i @(i) 2 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         break;
         @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
   @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
   @mif nu ! "1
   switch(nr)
   {
      TYPE *pr, *pi;
      @iexp n 1 0 +
      @iwhile n < @(nu)
   case @(n):
      pr = rC; pi = iC;
      for (i=0; i < m2; i += @(mu2), pr += pansz, pi += pansz)
      {
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp i 0 0 +
            @iwhile i < @(mu2)
               @mif nalp = "n
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib - C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb - C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "1
         pr[@(k)] -= C@(j)[i+@(i)];
         pi[@(k)] -= C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = -C@(j)[i+@(i)];
         pi[@(k)] = -C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         pi[@(k)] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                  @endmif
               @endmif
               @mif nalp = "1
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pr[@(k)];
         pr[@(k)] = rc*rb - ic*ib + C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb + C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "1
         pr[@(k)] += C@(j)[i+@(i)];
         pi[@(k)] += C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = C@(j)[i+@(i)];
         pi[@(k)] = C@(j)[i+@(i)+1];
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = -pr[@(k)] + C@(j)[i+@(i)];
         pi[@(k)] = -pi[@(k)] + C@(j)[i+@(i)+1];
                  @endmif
               @endmif
               @mif nalp = "X
         rtmp = rp = C@(j)[i+@(i)];
         ip = C@(j)[i+@(i)+1];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                  @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib + rp;
         pi[@(k)] = rc*ib + ic*rb + ip;
                  @endmif
                  @mif nbet = "1
         pr[@(k)] += rp;
         pi[@(k)] += ip;
                  @endmif
                  @mif nbet = "0
         pr[@(k)] = rp;
         pi[@(k)] = ip;
                  @endmif
                  @mif nbet = "n
         pr[@(k)] = rp - pr[@(k)];
         pi[@(k)] = ip - pi[@(k)];
                  @endmif
               @endmif
               @iexp i @(i) 2 +
               @iexp k @(k) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
      }
         @mif mu ! "1
      switch(mr)
      {
            @iexp m 1 0 +
            @iwhile m < @(mu)
      case @(m):
               @iexp j 0 0 +
               @iwhile j < @(n)
                  @iexp k @(mu) @(j) *
                  @iexp i 0 0 +
                  @iexp m2 @(m) @(m) +
                  @iwhile i < @(m2)
                     @mif nalp = "n
                        @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib - C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb - C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "1
         pr[@(k)] -= C@(j)[i+@(i)];
         pi[@(k)] -= C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "0
         pr[@(k)] = -C@(j)[i+@(i)];
         pi[@(k)] = -C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "n
         pr[@(k)] = -(pr[@(k)] + C@(j)[i+@(i)]);
         pi[@(k)] = -(pi[@(k)] + C@(j)[i+@(i)+1]);
                        @endmif
                     @endmif
                     @mif nalp = "1
                        @mif nbet = "X
            rc = pr[@(k)]; ic = pr[@(k)];
         pr[@(k)] = rc*rb - ic*ib + C@(j)[i+@(i)];
         pi[@(k)] = rc*ib + ic*rb + C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "1
         pr[@(k)] += C@(j)[i+@(i)];
         pi[@(k)] += C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "0
         pr[@(k)] = C@(j)[i+@(i)];
         pi[@(k)] = C@(j)[i+@(i)+1];
                        @endmif
                        @mif nbet = "n
         pr[@(k)] = -pr[@(k)] + C@(j)[i+@(i)];
         pi[@(k)] = -pi[@(k)] + C@(j)[i+@(i)+1];
                        @endmif
                     @endmif
                     @mif nalp = "X
         rtmp = rp = C@(j)[i+@(i)];
         ip = C@(j)[i+@(i)+1];
         rp = rp*ra - ip*ia;
         ip = rtmp*ia + ip*ra;
                        @mif nbet = "X
            rc = pr[@(k)]; ic = pi[@(k)];
         pr[@(k)] = rc*rb - ic*ib + rp;
         pi[@(k)] = rc*ib + ic*rb + ip;
                        @endmif
                        @mif nbet = "1
         pr[@(k)] += rp;
         pi[@(k)] += ip;
                        @endmif
                        @mif nbet = "0
         pr[@(k)] = rp;
         pi[@(k)] = ip;
                        @endmif
                        @mif nbet = "n
         pr[@(k)] = rp - pr[@(k)];
         pi[@(k)] = ip - pi[@(k)];
                        @endmif
                     @endmif
                     @iexp k @(k) 1 +
                     @iexp i @(i) 2 +
                  @endiwhile
                  @iexp j @(j) 1 +
               @endiwhile
         pr += pansz;
         pi += pansz;
         break;
               @iexp m @(m) 1 +
            @endiwhile
      default:;
      }
         @endmif
      break;
         @iexp n @(n) 1 +
      @endiwhile
   default:;
   }
   @endmif
}
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avx ATL_mm@(kmaj)_@(mu)x@(nu)_1_sse ATL_mm@(kmaj)_@(mu)x@(nu)_1_avxz
#include <immintrin.h>
#include "atlas_misc.h"
#include "atlas_prefetch.h"
#ifndef ATL_CSZT
   #define ATL_CSZT const size_t
#endif
#ifndef ATL_MM_KB 
   #ifdef KB
      #if KB == 0
         #define ATL_MM_KB K
         #define ATL_KBCONST 0
      #else
         #define ATL_MM_KB KB
         #define ATL_KBCONST 1
      #endif
   #else
      #define ATL_MM_KB K
      #define ATL_KBCONST 0
   #endif
#else
   #define ATL_KBCONST 1
#endif
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_sse
@ifdef ! dupB
   @define dupB @1@
@endifdef
@iif dupB = 0
   @undef dupB
   @define dupB @1@
@endiif
@ifdef ! vlen
   @define vlen @2@
@endifdef
@iif vlen = 2
   @define vtyp @__m128d@
   @define mul @_mm_mul_pd@
   @define add @_mm_add_pd@
   @define sub @_mm_sub_pd@
   @define ld  @_mm_load_pd@
   @define store @_mm_store_pd@
   @define CL @8@
#ifdef ATL_SSE3
   #define ATL_bcast(p_, r_) \
      r_ =  _mm_loaddup_pd(p_)
#else
   #define ATL_bcast(p_, r_) \
      r_ = _mm_load1_pd(p_)
#endif
@endiif
@iif vlen = 4
   @define vtyp @__m128@
   @define mul @_mm_mul_ps@
   @define add @_mm_add_ps@
   @define sub @_mm_sub_ps@
   @define ld  @_mm_load_ps@
   @define store @_mm_store_ps@
   @define CL @16@
   @iif dupB = 1
#define ATL_bcast(p_, r_) \
   r_ = _mm_load1_ps(p_)
   @endiif
   @iif dupB = 2
#ifdef ATL_SSE3
   #define ATL_bcast(p_, r_) \
      r_ = (__m128) _mm_loaddup_pd((double*)(p_))
#else
   #define ATL_bcast(p_, r_) \
      r_ = _mm_load1_ps(p_)
#endif
   @endiif
   @iif dupB = 4
   #define ATL_bcast(p_, r_) \
      r_ = _mm_load_ps(p_)
   @endiif
@endiif
@iexp vmu @(vlen) @(mu) /
@iexp i @(vmu) @(vlen) *
@iif i ! @(mu)
   @abort "@(mu) must be a multiple of @(vlen)!"
@endiif
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avxz
@ifdef ! vlen
   @define vlen @8@
@endifdef
@iif vlen = 8
   @define vtyp @__m512d@
   @define bcast @my_mm512_broadcast_sd@
   @define fma @_mm512_fmadd_pd@
   @define mul @_mm512_mul_pd@
   @define add @_mm512_add_pd@
   @define sub @_mm512_sub_pd@
   @define ld  @_mm512_load_pd@
   @define store @_mm512_store_pd@
   @define CL @8@
   #define ATL_bcast(p_, r_) \
      r_ = _mm512_extload_pd(pB, _MM_UPCONV_PD_NONE, _MM_BROADCAST_1X8, 0)
@endiif
@iif vlen = 16
   @define vtyp @__m512@
   @define bcast @my__mm512_broadcast_ss@
   @define fma @_mm512_fmadd_ps@
   @define mul @_mm512_mul_ps@
   @define add @_mm512_add_ps@
   @define sub @_mm512_sub_ps@
   @define ld  @_mm512_load_ps@
   @define store @_mm512_store_ps@
   @define CL @16@
   #define ATL_bcast(p_, r_) \
      r_ = _mm512_extload_ps(pB, _MM_UPCONV_PS_NONE, _MM_BROADCAST_1X16, 0)
@endiif
@iexp vmu @(vlen) @(mu) /
@iexp i @(vmu) @(vlen) *
@iif i ! @(mu)
   @abort "@(mu) must be a multiple of @(vlen)!"
@endiif
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avx
@ifdef ! vlen
   @define vlen @4@
@endifdef
@iif vlen = 4
   @define vtyp @__m256d@
   @define bcast @_mm256_broadcast_sd@
   @define mul @_mm256_mul_pd@
   @define add @_mm256_add_pd@
   @define sub @_mm256_sub_pd@
   @define ld  @_mm256_load_pd@
   @define store @_mm256_store_pd@
   @define CL @8@
@endiif
@iif vlen = 8
   @define vtyp @__m256@
   @define bcast @_mm256_broadcast_ss@
   @define mul @_mm256_mul_ps@
   @define add @_mm256_add_ps@
   @define sub @_mm256_sub_ps@
   @define ld  @_mm256_load_ps@
   @define store @_mm256_store_ps@
   @define CL @16@
@endiif
@iexp vmu @(vlen) @(mu) /
@iexp i @(vmu) @(vlen) *
@iif i ! @(mu)
   @abort "@(mu) must be a multiple of @(vlen)!"
@endiif
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avx ATL_mm@(kmaj)_@(mu)x@(nu)_1_sse ATL_mm@(kmaj)_@(mu)x@(nu)_1_avxz
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const TYPE *pA,    /* @(mu)*KB*nmus-length access-major array of A */
   const TYPE *pB,    /* @(nu)*KB*nnus-length access-major array of B */
   TYPE *pC,          /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const TYPE *pAn,   /* next block of A */
   const TYPE *pBn,   /* next block of B */
   const TYPE *pCn    /* next block of C */
)
/*
 * Performs a GEMM operation on a @(mu)x@(nu) jammed GEMM with a compile-time
 * constant K-length of ATL_MM_KB.
 */
{
   @declare "   register @(vtyp) " y y ";"
      m0
      @iexp j 0 0 +
      @iwhile j < @(nu)
         rB@(j)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rC@(i)@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i 0 0 +
      @iwhile i < @(vmu)
         rA@(i)
         @iexp i @(i) 1 +
      @endiwhile
   @enddeclare
   const TYPE *pB0 = pB;
   const TYPE *pfA, *pfB;
   size_t incPF;
   size_t i, j, k;
   #if ATL_KBCONST == 0
      size_t incAm = @(mu)*ATL_MM_KB;
   #else
      #define incAm @(mu)*ATL_MM_KB
   #endif

   if (pAn != pA)
   {
      pfA = pAn;
      incPF = (nmus*@(mu)*K) / (nmus * nnus);
      pfB = pBn;
      
   }
   else if (pBn != pB)
   {
      pfA = pBn;
      pfB = pA + nmus*@(mu)*2;
      incPF = (K*nnus*@(nu)*sizeof(TYPE)) / ((nmus * nnus)<<1);
   }
   else
   {
      pfA = pA + nmus*@(mu)*(K>>1);
      incPF = (nmus*@(mu)*K) / (nmus * nnus);
   }
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avxz
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel K=1 iteration to avoid zero of rCxx and extra add 
 */
         rA0 = @(ld)(pA);
         ATL_bcast(pB, rB0);
         @iexp k 0 @(vlen) +
         @iexp i 0 1 +
         @iwhile i < @(vmu)
         rA@(i) = @(ld)(pA+@(k));
            @iexp k @(k) @(vlen) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
         ATL_bcast(pB+@(j), rB@(j));
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
         rC@(i)@(j) = @(mul)(rA@(i), rB@(j));
            @iif k = 0
               ATL_pfl1W(pC);
            @endiif
            @iif k = 1
               ATL_pfl1W(pC+@(CL));
            @endiif
            @iif k = 2
               ATL_pfl1R(pfA);
            @endiif
            @iif k = 3
               ATL_pfl1R(pfA+@(CL));
            @endiif
            @iif k = 4
               pfA += incPF;
            @endiif
            @iif k = 5
               pA += @(mu);
            @endiif
            @iif k = 6
               pB += @(nu);
            @endiif
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iif k < 2
               ATL_pfl1W(pC+@(CL));
         @endiif
         @iif k < 3
               ATL_pfl1R(pfA);
         @endiif
         @iif k < 4
               ATL_pfl1R(pfA+@(CL));
         @endiif
         @iif k < 5
               pfA += incPF;
         @endiif
         @iif k < 6
               pA += @(mu);
         @endiif
         @iif k < 7
               pB += @(nu);
         @endiif
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = @(ld)(pA);
            ATL_bcast(pB, rB0);
            @iexp k 0 @(vlen) +
            @iexp i 0 1 +
            @iwhile i < @(vmu)
            rA@(i) = @(ld)(pA+@(k));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j 0 1 +
            @iwhile j < @(nu)
            ATL_bcast(pB+@(j),rB@(j));
               @iexp j @(j) 1 +
            @endiwhile
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp i 0 0 +
               @iwhile i < @(vmu)
            rC@(i)@(j) = @(fma)(rA@(i), rB@(j), rC@(i)@(j));
                  @iexp i @(i) 1 +
               @endiwhile
               @iexp j @(j) 1 +
            @endiwhile
            pA += @(mu);
            pB += @(nu);
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(sub)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(add)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_avx
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel K=1 iteration to avoid zero of rCxx and extra add 
 */
         rA0 = @(ld)(pA);
         rB0 = @(bcast)(pB);
         @iexp k 0 @(vlen) +
         @iexp i 0 1 +
         @iwhile i < @(vmu)
         rA@(i) = @(ld)(pA+@(k));
            @iexp k @(k) @(vlen) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
         rB@(j) = @(bcast)(pB+@(j));
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
         rC@(i)@(j) = @(mul)(rA@(i), rB@(j));
            @iif k = 0
               ATL_pfl1W(pC);
            @endiif
            @iif k = 1
               ATL_pfl1W(pC+@(CL));
            @endiif
            @iif k = 2
               ATL_pfl1R(pfA);
            @endiif
            @iif k = 3
               ATL_pfl1R(pfA+@(CL));
            @endiif
            @iif k = 4
               pfA += incPF;
            @endiif
            @iif k = 5
               pA += @(mu);
            @endiif
            @iif k = 6
               pB += @(nu);
            @endiif
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iif k < 2
               ATL_pfl1W(pC+@(CL));
         @endiif
         @iif k < 3
               ATL_pfl1R(pfA);
         @endiif
         @iif k < 4
               ATL_pfl1R(pfA+@(CL));
         @endiif
         @iif k < 5
               pfA += incPF;
         @endiif
         @iif k < 6
               pA += @(mu);
         @endiif
         @iif k < 7
               pB += @(nu);
         @endiif
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = @(ld)(pA);
            rB0 = @(bcast)(pB);
            @iexp k 0 @(vlen) +
            @iexp i 0 1 +
            @iwhile i < @(vmu)
            rA@(i) = @(ld)(pA+@(k));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j 0 1 +
            @iwhile j < @(nu)
            rB@(j) = @(bcast)(pB+@(j));
               @iexp j @(j) 1 +
            @endiwhile
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp i 0 0 +
               @iwhile i < @(vmu)
            m0 = @(mul)(rA@(i), rB@(j));
            rC@(i)@(j) = @(add)(m0, rC@(i)@(j));
                  @iexp i @(i) 1 +
               @endiwhile
               @iexp j @(j) 1 +
            @endiwhile
            pA += @(mu);
            pB += @(nu);
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(sub)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(add)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_sse
   @iexp nud @(nu) @(dupB) *
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel K=1 iteration to avoid zero of rCxx and extra add 
 */
         rA0 = @(ld)(pA);
         ATL_bcast(pB, rB0);
         @iexp k 0 @(vlen) +
         @iexp i 0 1 +
         @iwhile i < @(vmu)
         rA@(i) = @(ld)(pA+@(k));
            @iexp k @(k) @(vlen) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
            @iexp jd @(j) @(dupB) *
         ATL_bcast(pB+@(jd), rB@(j));
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
         rC@(i)@(j) = @(mul)(rA@(i), rB@(j));
            @iif k = 0
               ATL_pfl1W(pC);
            @endiif
            @iif k = 1
               ATL_pfl1W(pC+@(CL));
            @endiif
            @iif k = 2
               ATL_pfl1R(pfA);
            @endiif
            @iif k = 3
               ATL_pfl1R(pfA+@(CL));
            @endiif
            @iif k = 4
               pfA += incPF;
            @endiif
            @iif k = 5
               pA += @(mu);
            @endiif
            @iif k = 6
               pB += @(nud);
            @endiif
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iif k < 2
            ATL_pfl1W(pC+@(CL));
         @endiif
         @iif k < 3
            ATL_pfl1R(pfA);
         @endiif
         @iif k < 4
            ATL_pfl1R(pfA+@(CL));
         @endiif
         @iif k < 5
            pfA += incPF;
         @endiif
         @iif k < 6
            pA += @(mu);
         @endiif
         @iif k < 7
            pB += @(nud);
         @endiif
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = @(ld)(pA);
            ATL_bcast(pB, rB0);
            @iexp k 0 @(vlen) +
            @iexp i 0 1 +
            @iwhile i < @(vmu)
            rA@(i) = @(ld)(pA+@(k));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j 0 1 +
            @iwhile j < @(nu)
               @iexp jd @(j) @(dupB) *
            ATL_bcast(pB+@(jd), rB@(j));
               @iexp j @(j) 1 +
            @endiwhile
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp i 0 0 +
               @iwhile i < @(vmu)
            m0 = @(mul)(rA@(i), rB@(j));
            rC@(i)@(j) = @(add)(m0, rC@(i)@(j));
                  @iexp i @(i) 1 +
               @endiwhile
               @iexp j @(j) 1 +
            @endiwhile
            pA += @(mu);
            pB += @(nud);
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(sub)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(vmu)
            m0 = @(ld)(pC+@(k));
            rC@(i)@(j) = @(add)(rC@(i)@(j), m0);
            @(store)(pC+@(k), rC@(i)@(j));
               @iexp k @(k) @(vlen) +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1_sse ATL_mm@(kmaj)_@(mu)x@(nu)_1_avx @\
      ATL_mm@(kmaj)_@(mu)x@(nu)_1_avxz
#if ATL_KBCONST != 0
   #undef incAm
#endif
#undef ATL_KBCONST
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_gvec
#include "atlas_misc.h"
#include "atlas_prefetch.h"
#define ATL_VLEN @(vlen)
#if defined(SREAL) || defined(SCPLX)
   @iexp vlb @(vlen) 4 *
   #define ATL_VLENb @(vlb)
#else
   @iexp vlb @(vlen) 8 *
   #define ATL_VLENb @(vlb)
#endif
#include "atlas_gnuvec.h"
#ifndef ATL_CSZT
   #define ATL_CSZT const size_t
#endif
#ifndef ATL_MM_KB 
   #ifdef KB
      #if KB == 0
         #define ATL_KBCONST 0
         #define ATL_MM_KB K
      #else
         #define ATL_KBCONST 1
         #define ATL_MM_KB KB
      #endif
   #else
      #define ATL_KBCONST 0
      #define ATL_MM_KB K
   #endif
#endif
@skip typedef TYPE ATL_vec_t __attribute__ ((vector_size (@(vlen))));
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const TYPE *pAv,   /* @(mu)*KB*nmus-length access-major array of A */
   const TYPE *pB,    /* @(nu)*KB*nnus-length access-major array of B */
   TYPE *pCv,         /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const TYPE *pAn,   /* next block of A */
   const TYPE *pBn,   /* next block of B */
   const TYPE *pCn    /* next block of C */
)
/*
 * Performs a GEMM operation on a @(mu)x@(nu) jammed GEMM with a compile-time
 * constant K-length of ATL_MM_KB.
 */
{
   const ATL_vec_t *pA = (const ATL_vec_t*)pAv;
   ATL_vec_t *pC = (ATL_vec_t*)pCv;
   @declare "   register ATL_vec_t " y n ";"
      @iexp j 0 0 +
      @iwhile j < @(nu)
         rB@(j)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            rC@(i)@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i 0 0 +
      @iwhile i < @(mu)
         rA@(i)
         @iexp i @(i) 1 +
      @endiwhile
   @enddeclare
   const TYPE *pB0 = pB;
   const TYPE *pfA;
   size_t incPF;
   size_t i, j, k;
   #if ATL_KBCONST == 0
      size_t incAm = @(mu)*K;
   #else
      #define incAm (@(mu)*ATL_MM_KB)
   #endif

   if (pAn != pAv)
   {
      pfA = pAn;
      incPF = (nmus*@(mu)*K*sizeof(TYPE)) / (nmus * nnus);
   }
   else if (pCn != pCv)
   {
      pfA = pCn;
      incPF = (nmus*@(mu)*nnus*@(nu)*sizeof(TYPE)) / (nmus * nnus);
   }
   else if (pBn != pB)
   {
      pfA = pBn;
      incPF = (K*nnus*@(nu)*sizeof(TYPE)) / (nmus * nnus);
   }
   else
   {
      pfA = pAv + nmus*@(mu)*(K>>1);
      incPF = (nmus*@(mu)*K*sizeof(TYPE)) / (nmus * nnus);
   }
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel K=1 iteration to avoid zero of rCxx and extra add 
 */
         rA0 = *pA;
         ATL_gvbcast(pB, rB0);
         @iexp i 0 1 +
         @iwhile i < @(mu)
         rA@(i) = pA[@(i)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
         ATL_gvbcast(pB+@(j), rB@(j));
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
         rC@(i)@(j) = rA@(i) * rB@(j);
            @iif k = 0
               ATL_pfl1W(pC);
            @endiif
            @iif k = 1
               ATL_pfl1R(pfA);
            @endiif
            @iif k = 2
               pfA += incPF;
            @endiif
            @iif k = 3
               pA += @(mu);
            @endiif
            @iif k = 4
               pB += @(nu);
            @endiif
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iif k < 2
               ATL_pfl1R(pfA);
         @endiif
         @iif k < 3
               pfA += incPF;
         @endiif
         @iif k < 4
               pA += @(mu);
         @endiif
         @iif k < 5
               pB += @(nu);
         @endiif
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = *pA;
            ATL_gvbcast(pB, rB0);
            @iexp i 0 1 +
            @iwhile i < @(mu)
            rA@(i) = pA[@(i)];
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j 0 1 +
            @iwhile j < @(nu)
            ATL_gvbcast(pB+@(j), rB@(j));
               @iexp j @(j) 1 +
            @endiwhile
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp i 0 0 +
               @iwhile i < @(mu)
            rC@(i)@(j) += rA@(i) * rB@(j);
                  @iexp i @(i) 1 +
               @endiwhile
               @iexp j @(j) 1 +
            @endiwhile
            pA += @(mu);
            pB += @(nu);
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j) - pC[@(k)];
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] += rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
#if ATL_KBCONST != 0
   #undef incAm
#endif
#undef ATL_KBCONST
@ROUT ATL_mm@(kmaj)_@(mu)x@(nu)_1
@iif kmaj = 0
#include "atlas_misc.h"
#include "atlas_prefetch.h"
#ifndef ATL_CSZT
   #define ATL_CSZT const size_t
#endif
#ifndef ATL_MM_KB 
   #ifdef KB
      #if KB == 0
         #define ATL_KBCONST 0
         #define ATL_MM_KB K
      #else
         #define ATL_KBCONST 1
         #define ATL_MM_KB KB
      #endif
   #else
      #define ATL_KBCONST 0
      #define ATL_MM_KB K
   #endif
#endif
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const TYPE *pA,    /* @(mu)*KB*nmus-length access-major array of A */
   const TYPE *pB,    /* @(nu)*KB*nnus-length access-major array of B */
   TYPE *pC,          /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const TYPE *pAn,   /* next block of A */
   const TYPE *pBn,   /* next block of B */
   const TYPE *pCn    /* next block of C */
)
/*
 * Performs a GEMM operation on a @(mu)x@(nu) jammed GEMM with a compile-time
 * constant K-length of ATL_MM_KB.
 */
{
   @declare "   register TYPE " y n ";"
      @iexp j 0 0 +
      @iwhile j < @(nu)
         rB@(j)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            rC@(i)@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i 0 0 +
      @iwhile i < @(mu)
         rA@(i)
         @iexp i @(i) 1 +
      @endiwhile
   @enddeclare
   const TYPE *pB0 = pB;
   const TYPE *pfA;
   size_t incPF;
   size_t i, j, k;
   #if ATL_KBCONST == 0
      size_t incAm = @(mu)*K;
   #else
      #define incAm (@(mu)*ATL_MM_KB)
   #endif

   if (pAn != pA)
   {
      pfA = pAn;
      incPF = (nmus*@(mu)*K*sizeof(TYPE)) / (nmus * nnus);
   }
   else if (pCn != pA)
   {
      pfA = pCn;
      incPF = (nmus*@(mu)*nnus*@(nu)*sizeof(TYPE)) / (nmus * nnus);
   }
   else if (pBn != pB)
   {
      pfA = pBn;
      incPF = (K*nnus*@(nu)*sizeof(TYPE)) / (nmus * nnus);
   }
   else
   {
      pfA = pA + nmus*@(mu)*(K>>1);
      incPF = (nmus*@(mu)*K*sizeof(TYPE)) / (nmus * nnus);
   }
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel K=1 iteration to avoid zero of rCxx and extra add 
 */
         rA0 = *pA;
         rB0 = *pB;
         @iexp i 0 1 +
         @iwhile i < @(mu)
         rA@(i) = pA[@(i)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
         rB@(j) = pB[@(j)];
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
         rC@(i)@(j) = rA@(i) * rB@(j);
            @iif k = 0
               ATL_pfl1W(pC);
            @endiif
            @iif k = 1
               ATL_pfl1R(pfA);
            @endiif
            @iif k = 2
               pfA += incPF;
            @endiif
            @iif k = 3
               pA += @(mu);
            @endiif
            @iif k = 4
               pB += @(nu);
            @endiif
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iif k < 2
               ATL_pfl1R(pfA);
         @endiif
         @iif k < 3
               pfA += incPF;
         @endiif
         @iif k < 4
               pA += @(mu);
         @endiif
         @iif k < 5
               pB += @(nu);
         @endiif
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = *pA;
            rB0 = *pB;
            @iexp i 0 1 +
            @iwhile i < @(mu)
            rA@(i) = pA[@(i)];
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j 0 1 +
            @iwhile j < @(nu)
            rB@(j) = pB[@(j)];
               @iexp j @(j) 1 +
            @endiwhile
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp i 0 0 +
               @iwhile i < @(mu)
            rC@(i)@(j) += rA@(i) * rB@(j);
                  @iexp i @(i) 1 +
               @endiwhile
               @iexp j @(j) 1 +
            @endiwhile
            pA += @(mu);
            pB += @(nu);
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j) - pC[@(k)];
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] += rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
#if ATL_KBCONST != 0
   #undef incAm
#endif
#undef ATL_KBCONST
   @endextract
@endiif
#include "atlas_misc.h"
#include "atlas_prefetch.h"
#ifndef ATL_CSZT
   #define ATL_CSZT const size_t
#endif
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const TYPE *pA,    /* @(kmaj)*mu*nkus*nmus access-major array of A */
   const TYPE *pB,    /* @(kmaj)*nu*nkus*nkus access-major array of A */
   TYPE *pC,          /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const TYPE *pAn,   /* next block of A */
   const TYPE *pBn,   /* next block of B */
   const TYPE *pCn    /* next block of C */
)
/*
 * Performs a GEMM operation on a @(mu)x@(nu) jammed GEMM in simplist way
 * possible in order to get k-major access-major framework working.
 * Replace with real code generator once things work.
 */
{
   @declare "   register TYPE " y n ";"
      @iexp j 0 0 +
      @iwhile j < @(nu)
         rB@(j)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            rC@(i)@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iexp i 0 0 +
      @iwhile i < @(mu)
         rA@(i)
         @iexp i @(i) 1 +
      @endiwhile
   @enddeclare
   const TYPE *pB0 = pB;
   const TYPE *pfA;
   size_t incPF;
   size_t i, j, k;
   size_t incAm = @(mu)*K;

   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
/*
 *       Peel first iteration to avoid zero of rCxx & extra add
 */
         rA0 = *pA;
         rB0 = *pB;
         @iexp i 0 1 +
         @iwhile i < @(mu)
            @iexp h @(i) @(kmaj) *
         rA@(i) = pA[@(h)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
            @iexp h @(j) @(kmaj) *
         rB@(j) = pB[@(h)];
            @iexp j @(j) 1 +
         @endiwhile
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
         rC@(i)@(j) = rA@(i) * rB@(j);
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
/*
 *       Peal remaining @(kmaj)-1 iters to start loop properly
 */
      @iexp k 0 1 +
      @iwhile k < @(kmaj)
         rA0 = pA[@(k)];
         rB0 = pB[@(k)];
         @iexp i 0 1 +
         @iwhile i < @(mu)
            @iexp h @(i) @(kmaj) *
            @iexp h @(h) @(k) +
         rA@(i) = pA[@(h)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
            @iexp h @(j) @(kmaj) *
            @iexp h @(h) @(k) +
         rB@(j) = pB[@(h)];
            @iexp j @(j) 1 +
         @endiwhile
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
         rC@(i)@(j) += rA@(i) * rB@(j);
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k @(k) 1 +
      @endiwhile
/*
 *       Increment A/B ptrs past used k-blks
 */
         @iexp incA @(mu) @(kmaj) *
         @iexp incB @(nu) @(kmaj) *
         pA += @(incA);
         pB += @(incB);
/*
 *       Handle remaining K its with rolled loop (compiler can unroll easily)
 */
         for (k=@(kmaj); k < K; k += @(kmaj), pA += @(incA), pB += @(incB))
         {
      @iexp k 0 0 +
      @iwhile k < @(kmaj)
         rA0 = pA[@(k)];
         rB0 = pB[@(k)];
         @iexp i 0 1 +
         @iwhile i < @(mu)
            @iexp h @(i) @(kmaj) *
            @iexp h @(h) @(k) +
         rA@(i) = pA[@(h)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
            @iexp h @(j) @(kmaj) *
            @iexp h @(h) @(k) +
         rB@(j) = pB[@(h)];
            @iexp j @(j) 1 +
         @endiwhile
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
         rC@(i)@(j) += rA@(i) * rB@(j);
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iexp k @(k) 1 +
      @endiwhile
         }
         pA -= incAm;
         #ifdef BETA0
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #elif defined(BETAN1)
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] = rC@(i)@(j) - pC[@(k)];
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #else  /* BETA = 1 */
         @iexp k 0 0 +
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp i 0 0 +
            @iwhile i < @(mu)
            pC[@(k)] += rC@(i)@(j);
               @iexp k @(k) 1 +
               @iexp i @(i) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         #endif
         pC += @(mu)*@(nu);
      }
      pA += incAm;
      pB = pB0;
   }
}
@ROUT ATL_mm4x2
void ATL_UGEMM
(
   size_t nmus,
   size_t nnus,
   TYPE *pA,    /* mu*KB*nmus-length access-major array of A */
   TYPE *pB,    /* nu*KB*nnus-length access-major array of B */
   TYPE *pC,    /* mu*nu*nnus*nmus-length acces-major array of C */
   TYPE *pf     /* will prefetch next KB*KB elts from this area into L2cache */
)
/*
 * Performs a GEMM operation on a 4x2 jammed GEMM with a compile-time
 * constant K-length of ATL_MM_KB.
 */
{
   register TYPE rA0, rA1, rA2, rA3, rB0, rB1;
   register TYPE rC00, rC10, rC20, rC30,
                 rC01, rC11, rC21, rC31,
                 rC02, rC12, rC22, rC32,
                 rC03, rC13, rC23, rC33;
   TYPE pB0 = pB;
   ATL_CINT incPF = ((size_t)KB*KB)/(nmus*nnus);
   for (i=0; i < nmus; i++)
   {
      for (j=0; j < nnus; j++)
      {
         rA0 = *pA;
         rA1 = pA[1];
         rA2 = pA[2];
         rA3 = pA[3];
         rB0 = *pB;
         rB1 = pB[1];
         rC00 = rA0 * rB0;
         ATL_pfl1W(pC);
         rC10 = rA1 * rB0;
         pA += 4;
         rC20 = rA2 * rB0;
         pB += 2;
         rC30 = rA3 * rB0;
         rC01 = rA0 * rB1;
         rC11 = rA1 * rB1;
         ATL_pfl1R(pf);
         rC21 = rA2 * rB1;
         pf += incPF;
         rC31 = rA3 * rB1;
         for (k=1; k < ATL_MM_KB; k++)
         {
            rA0 = *pA; rA1 = pA[1]; rA2 = pA[2]; rA3 = pA[3];
            rB0 = *pB; rB1 = pB[1];
            rC00 += rA0 * rB0;
            rC10 += rA1 * rB0;
            rC20 += rA2 * rB0;
            rC30 += rA3 * rB0;
            rC01 += rA0 * rB1;
            rC11 += rA1 * rB1;
            rC21 += rA2 * rB1;
            rC31 += rA3 * rB1;
            pA += 4;
            pB += 2;
         }
         pA -= 4*ATL_MM_KB;
         #ifdef BETA0
            pC[0] = rC00;
            pC[1] = rC10;
            pC[2] = rC20;
            pC[3] = rC30;
            pC[4] = rC01;
            pC[5] = rC11;
            pC[6] = rC21;
            pC[7] = rC31;
         #elif defined(BETAN1)
            pC[0] = rC00 - pC[0];
            pC[1] = rC10 - pC[1];
            pC[2] = rC20 - pC[2];
            pC[3] = rC30 - pC[3];
            pC[4] = rC01 - pC[4];
            pC[5] = rC11 - pC[5];
            pC[6] = rC21 - pC[6];
            pC[7] = rC31 - pC[7];
         #else /* BETA=1 */
            pC[0] += rC00;
            pC[1] += rC10;
            pC[2] += rC20;
            pC[3] += rC30;
            pC[4] += rC01;
            pC[5] += rC11;
            pC[6] += rC21;
            pC[7] += rC31;
         #endif
         pC += 8;
      }
      pA += 4*ATL_MM_KB;
      pB = pB0;
   }
}
@ROUT cammmtst

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )

#define NoTransA 1
#define NoTransB 1

void cmm_b0(const size_t nmu, const size_t nnu, const size_t K, 
            const TYPE *A, const TYPE *B, TYPE *C, 
            const TYPE *pAn, const TYPE *pBn, const TYPE *pCn);
void cmm_b1(const size_t nmu, const size_t nnu, const size_t K, 
            const TYPE *A, const TYPE *B, TYPE *C, 
            const TYPE *pAn, const TYPE *pBn, const TYPE *pCn);
void cmm_bn(const size_t nmu, const size_t nnu, const size_t K, 
            const TYPE *A, const TYPE *B, TYPE *C, 
            const TYPE *pAn, const TYPE *pBn, const TYPE *pCn);
#ifndef ATL_CWRK3
   #define ATL_CWRK3 0
#endif
static void cusermm(const int M, const int N, const int K, const TYPE *A,
                    const TYPE *B, TYPE *C)
{
   ATL_CINT nmu = (M+@(mu)-1)/@(mu), nnu = (N+@(nu)-1)/@(nu);
   ATL_CINT MMU=nmu*@(mu), NNU=nnu*@(nu);
   ATL_CINT incA = MMU*K, incB=K*NNU; 
   @iif kmaj = 0
   ATL_CINT incC=MMU*NNU;
   @endiif
   @iif kmaj ! 0
      @iexp bsz @(kmaj) @(mu) @(nu) * @(kmaj) + -1 + / @(kmaj) *
   ATL_CINT incC=nmu*nnu*@(bsz);
   @endiif
   const TYPE *iA=A, *rA = A+incA, *iB=B, *rB = B+incB;
   #if ATL_CWRK3
      TYPE *iC=C, rC = C+incC, rC1 = C+incC+incC;
      ATL_INT i;

   @iif beta = 0
      cmm_b0(nmu, nnu, K, iA, iB, rC1, rA, iB, iC);
      cmm_b0(nmu, nnu, K, rA, iB, iC, rA, rB, rC);
      cmm_b0(nmu, nnu, K, rA, rB, rC, iA, rB, iC);
   @endiif
   @iif beta ! 0
      for (i=0; i < incC; i++)
         rC1[i] = ATL_rzero;
      cmm_b1(nmu, nnu, K, iA, iB, rC1, rA, iB, iC);
      cmm_b1(nmu, nnu, K, rA, iB, iC, rA, rB, rC);
      cmm_b1(nmu, nnu, K, rA, rB, rC, iA, rB, iC);
   @endiif
      cmm_b1(nmu, nnu, K, iA, rB, iC, rA+incA, rB+incB, rC+incC);
      for (i=0; i < incC; i++)
         rC[i] -= rC1[i];
   #else
      TYPE *iC=C, *rC = C+incC;
   @iif beta = 0
      cmm_b0(nmu, nnu, K, iA, iB, rC, rA, iB, iC);
      cmm_b0(nmu, nnu, K, rA, iB, iC, rA, rB, rC);
   @endiif
   @iif beta ! 0
      cmm_bn(nmu, nnu, K, iA, iB, rC, rA, iB, iC);
      cmm_b1(nmu, nnu, K, rA, iB, iC, rA, rB, rC);
   @endiif
      cmm_bn(nmu, nnu, K, rA, rB, rC, iA, rB, iC);
      cmm_b1(nmu, nnu, K, iA, rB, iC, rA+incA, rB+incB, rC+incC);
   #endif
}

void tst_mm(const int M, const int N, const int K, const SCALAR alpha,
            const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
            const SCALAR beta, TYPE *C, const int ldc0)
{
   int i, j, k;
   int lda = lda0 SHIFT, ldb = ldb0 SHIFT, ldc = ldc0 SHIFT;
   register TYPE c0;
   register TYPE cr, ci, ar, ai, br, bi;

   for (j=0; j < N; j++)
   {
      for (i=0; i < M; i++)
      {
         cr = ci = 0.0;
         for (k=0; k < K; k++)
         {
            #if defined(NoTransA) && defined(NoTransB)
               ar = A[2*i+k*lda];
               ai = A[2*i+k*lda+1];
               br = B[j*ldb+2*k];
               bi = B[j*ldb+2*k+1];
            #elif defined(NoTransA) && !defined(NoTransB)
               ar = A[2*i+k*lda] ;
               ai = A[2*i+k*lda+1];
               br = B[2*j+k*ldb];
               bi = B[2*j+k*ldb+1];
            #elif !defined(NoTransA) && defined(NoTransB)
               ar = A[i*lda+k*2];
               ai = A[i*lda+k*2+1];
               br = B[j*ldb+k*2];
               bi = B[j*ldb+k*2+1];
            #elif !defined(NoTransA) && !defined(NoTransB)
               ar = A[i*lda+k*2];
               ai = A[i*lda+k*2+1];
               br = B[2*j+k*ldb];
               bi = B[2*j+k*ldb+1];
            #endif
            #ifdef ConjTransA
               ai = -ai;
            #endif
            #ifdef ConjTransB
               bi = -bi;
            #endif
            cr += ar * br - ai * bi;
            ci += ar * bi + ai * br;
         }
/*
 *       Scale by alpha
 */
         ar = *alpha;
         ai = alpha[1];
         br = cr;
         bi = ci;
         cr =  br * ar;
         ci =  bi * ar;
         cr -= bi * ai;
         ci += br * ai;
/*
 *       Scale C by beta
 */
         br = *beta;
         bi = beta[1];
         ar = C[2*i+j*ldc];
         ai = C[2*i+j*ldc+1];
         C[2*i+j*ldc]   = ar*br - ai * bi;
         C[2*i+j*ldc+1] = ai*br + ar * bi;
/*
 *       Store answer back to C
 */
         C[2*i+j*ldc]   += cr;
         C[2*i+j*ldc+1] += ci;

      }
   }
}
@ifdef ! M
   @define M @40@
@endifdef
@ifdef ! N
   @define N @60@
@endifdef
@ifdef ! K
   @define K @80@
@endifdef

@beginskip
/*
 * This routine copies the column-major array A into muxnu storage, split 
 * real/imag storage.  
 * It is used to copy C for the tester GEMM into the C for the tested kernel.
 */
static void ATL_CM2BK
(
   ATL_CINT M,   /* # of rows in A */
   ATL_CINT N,   /* # of cols in A */
   ATL_CINT mu,  /* M unrolling */
   ATL_CINT nu,  /* N unrolling */
   TYPE *A,      /* column-major ldaxN matrix A */
   ATL_CINT lda, /* stride between row elements of A */
   TYPE *I       /* OUTPUT: muxnu blk storage of A */
)
{
   ATL_CINT MMU = ((M+mu-1)/mu)*mu, NNU = ((N+nu-1)/nu)*nu;
   ATL_INT i, j;
   TYPE *R = I + MMU*NNU;

   for (i=0; i != MMU; i += mu)
   {
      for (j=0; j != NNU; j += nu)
      {
         ATL_INT iu, ju;
         for (ju=0; ju < nu; ju++)
         {
            for (iu=0; iu < mu; iu++)
            {
               if (i+iu < M && j+ju < N)
               {
                  ATL_CINT k = ((j+ju)*lda+i+iu)<<1;
                  *R++ = A[k];
                  *I++ = A[k+1];
               }
               else
                  *R++ = *I++ = 0.0;
            }
         }
      }
   }
}
@endskip

int mmtst(void)
{
   int inca, incb, incc;
   const TYPE one=1.0, none=(-1.0);
   TYPE alpha[2] = {1.0, 0.0};
   TYPE beta[2] = {@(be).0, 0.0};
   TYPE zero[2] = {0.0, 0.0};
   const TYPE rone=1.0, rnone=(-1.0);
   void *va=NULL, *vb=NULL, *vc=NULL;
   TYPE *C, *D, *A, *B, *a, *b, *c;
   TYPE diff, tmp;
@iif TRI = 1
   const TYPE mynan=0.0/0.0;
@endiif
   int i, j, k, n, nerr;
   ATL_CINT M=@(M), N=@(N), K=@(K), lda=M, ldb=K, ldc=M+3;
   ATL_CINT NMU = ((@(M)+@(mu)-1)/@(mu));
   ATL_CINT NNU = ((@(N)+@(nu)-1)/@(nu));
   ATL_CINT MM=NMU*@(mu), NN=NNU*@(nu);
   @iif kmaj = 0
   ATL_CINT KK = K, incC = MM*NN;
   @endiif
   @iif kmaj ! 0
   ATL_CINT KK = ((K+@(ku)-1)/@(ku))*@(ku), incC=NMU*NNU*@(bsz);
   @endiif
   ATL_CINT incA = MM*KK, incB = KK*NN*@(dupB);
   TYPE ErrBound;

   tmp = Mabs(*beta) + Mabs(beta[1]);
   ErrBound =  2.0 * (8.0*K*EPS + tmp*EPS) + EPS;
/*
 * Allocate normal & access-major storage arrays; access-major arrays are
 * always aligned to ATL_Cachelen
 */
   
   A = malloc(2*sizeof(TYPE)*lda*K);
   B = malloc(2*sizeof(TYPE)*ldb*N);
   C = malloc(2*sizeof(TYPE)*ldc*N);
   D = malloc(2*sizeof(TYPE)*ldc*N);
   va = malloc(4*sizeof(TYPE)*incA + ATL_Cachelen);
   vb = malloc(4*sizeof(TYPE)*incB + ATL_Cachelen);
   vc = malloc(4*sizeof(TYPE)*incC + ATL_Cachelen);
   a = ATL_AlignPtr(va);
   b = ATL_AlignPtr(vb);
   c = ATL_AlignPtr(vc);
/*
 * Fill in column-major arrays and translate to access-major
 */
   assert(A && B && C && a && b && c);
   for (n=lda*K SHIFT, i=0; i < n; i++) A[i] = dumb_rand();
@iif TRI = 1
   for (j=0; j < N; j++)   /* make B = trans(A), so we can test SYRK */
   {
      for (i=0; i < K; i++)
      {
          size_t ib = (i+j*ldb)SHIFT, ia = (j+i*lda)SHIFT;
          B[ib] = A[ia];
          B[ib+1] = A[ia+1];
      }
   }
@endiif
@iif TRI = 0
   for (n=ldb*N SHIFT, i=0; i < n; i++) B[i] = dumb_rand();
@endiif
   for (n=ldc*N SHIFT, i=0; i < n; i++) C[i] = dumb_rand();
   ATL_rm2am(K, M, alpha, A, lda, a+incA, a);
@iif TRI = 0
   ATL_cm2am(K, N, alpha, B, ldb, b+incB, b);
@endiif
@skip   ATL_CM2BK(M, N, @(mu), @(nu), C, ldc, c);
@skip   Mjoin(PATL,gezero)(M, N, D, ldc);
/*
 * Call test routine, move output to col-major D for comparison with correct C
 */
@iif TRI = 1
   cusermm(M, N, KK, a, a, c);
@endiif
@iif TRI = 0
   cusermm(M, N, KK, a, b, c);
@endiif
   tst_mm(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
/*
   printf("c=%e,%e,%e,%e; %e,%e,%e,%e\n", c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
   printf("C=%e,%e,%e,%e; %e,%e,%e,%e\n", C[0], C[1], C[2], C[3], C[ldc], C[ldc+1], C[ldc+2], C[ldc+3]);
*/
   ATL_blk2C(M, N, alpha, c+incC, c, beta, D, ldc);

   nerr = 0;
   for (j=0; j < N; j++)
   {
@iif TRI = 1
   @beginskip
      for (i=0; i < j SHIFT; i++)
      {
         diff = D[i + j*(ldc SHIFT)];
         if (diff == diff)
         {
            fprintf(stderr, "C(%d,%d) : expected=NaN, got=%e!\n", i, j, D[k]);
            nerr++;
         }
      }
   @endskip
      for (i=j+j; i < M SHIFT; i++)
@endiif
@iif TRI = 0
      for (i=0; i < M SHIFT; i++)
@endiif
      {
         k = i + j*(ldc SHIFT);
         diff = C[k] - D[k];
         if (diff < 0.0) diff = -diff;
         if (diff > ErrBound)
         {
            fprintf(stderr, "C(%d,%d) : expected=%e, got=%e, diff=%e\n",
                    i, j, C[k], D[k], diff);
            nerr++;
         }
         else if (D[k] != D[k])   /* test for NaNs in test answer */
         {
            fprintf(stderr, "C(%d,%d) : expected=%e, got=%e\n",
                    i, j, C[k], D[k]);
            nerr++;
         }
      }
   }
   free(A);
   free(B);
   free(C);
   free(va);
   free(vb);
   free(vc);
   free(D);
   return(nerr);
}

int main(void)
{
   int ierr;
   ierr = mmtst();
   if (!ierr) fprintf(stdout, "PASSED TEST\n");
   exit(ierr);
}
@ROUT ammmtst
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "atlas_misc.h"

#define dumb_seed(iseed_) srand(iseed_)
#ifndef RAND_MAX  /* rather dangerous non-ansi workaround */
   #define RAND_MAX ((unsigned long)(1<<30))
#endif
#define dumb_rand() ( 0.5 - ((double)rand())/((double)RAND_MAX) )

#define NoTransA 1
#define NoTransB 1

@iif TRMM == 1
   #ifdef UPLO_U_
      #define UP 1
   #else /* lo */
      #define UP 0
   #endif
   #ifdef SIDE_R_
      #define SD_Right 1
   #else
      #define SD_Right 0
   #endif
   #ifdef TCPLX
      #if SD_Right == 1
         void B2BLK(const size_t, const SCALAR,
                    const TYPE*, const size_t, TYPE*, TYPE*);
      #else
         void A2BLK(const size_t, const SCALAR,
                    const TYPE*, const size_t, TYPE*, TYPE*);
      #endif
   #else
      #if SD_Right == 1
         void B2BLK(const size_t, const SCALAR,
                    const TYPE*, const size_t, TYPE*);
      #else
         void A2BLK(const size_t, const SCALAR,
                    const TYPE*, const size_t, TYPE*);
      #endif
   #endif
@endiif

void ATL_USERMM(const size_t nmu, const size_t nnu, const size_t K, 
                const TYPE *A, const TYPE *B, TYPE *C, 
                const TYPE *pAn, const TYPE *pBn, const TYPE *pCn);

void tst_mm(const int M, const int N, const int K, const SCALAR alpha,
            const TYPE *A, const int lda0, const TYPE *B, const int ldb0,
            const SCALAR beta, TYPE *C, const int ldc0)
{
   int i, j, k;
   int lda = lda0 SHIFT, ldb = ldb0 SHIFT, ldc = ldc0 SHIFT;
   register TYPE c0;
   #ifdef TREAL
      for (j=0; j < N; j++)
      {
         for (i=0; i < M; i++)
         {
            c0 = 0.0;
            for (k=0; k < K; k++)
            {
               #if defined(NoTransA) && defined(NoTransB)
                  c0 += A[i+k*lda] * B[j*ldb+k];
               #elif defined(NoTransA) && defined(TransB)
                  c0 += A[i+k*lda] * B[j+k*ldb];
               #elif defined(TransA) && defined(NoTransB)
                  c0 += A[i*lda+k] * B[j*ldb+k];
               #elif defined(TransA) && defined(TransB)
                  c0 += A[i*lda+k] * B[j+k*ldb];
               #endif
            }
            C[i+j*ldc] = beta*C[i+j*ldc] + alpha*c0;
         }
      }
   #else
      register TYPE cr, ci, ar, ai, br, bi;

      for (j=0; j < N; j++)
      {
         for (i=0; i < M; i++)
         {
            cr = ci = 0.0;
            for (k=0; k < K; k++)
            {
               #if defined(NoTransA) && defined(NoTransB)
                  ar = A[2*i+k*lda];
                  ai = A[2*i+k*lda+1];
                  br = B[j*ldb+2*k];
                  bi = B[j*ldb+2*k+1];
               #elif defined(NoTransA) && !defined(NoTransB)
                  ar = A[2*i+k*lda] ;
                  ai = A[2*i+k*lda+1];
                  br = B[2*j+k*ldb];
                  bi = B[2*j+k*ldb+1];
               #elif !defined(NoTransA) && defined(NoTransB)
                  ar = A[i*lda+k*2];
                  ai = A[i*lda+k*2+1];
                  br = B[j*ldb+k*2];
                  bi = B[j*ldb+k*2+1];
               #elif !defined(NoTransA) && !defined(NoTransB)
                  ar = A[i*lda+k*2];
                  ai = A[i*lda+k*2+1];
                  br = B[2*j+k*ldb];
                  bi = B[2*j+k*ldb+1];
               #endif
               #ifdef ConjTransA
                  ai = -ai;
               #endif
               #ifdef ConjTransB
                  bi = -bi;
               #endif
               cr += ar * br - ai * bi;
               ci += ar * bi + ai * br;
            }
/*
 *          Scale by alpha
 */
            ar = *alpha;
            ai = alpha[1];
            br = cr;
            bi = ci;
            cr =  br * ar;
            ci =  bi * ar;
            cr -= bi * ai;
            ci += br * ai;
/*
 *          Scale C by beta
 */
            br = *beta;
            bi = beta[1];
            ar = C[2*i+j*ldc];
            ai = C[2*i+j*ldc+1];
            C[2*i+j*ldc]   = ar*br - ai * bi;
            C[2*i+j*ldc+1] = ai*br + ar * bi;
/*
 *          Store answer back to C
 */
            C[2*i+j*ldc]   += cr;
            C[2*i+j*ldc+1] += ci;

         }
      }
      #if csA == 1 && csB == 1
         free(aa);
         free(bb);
      #endif
   #endif
}
@ifdef ! M
   @define M @40@
@endifdef
@ifdef ! N
   @define N @60@
@endifdef
@ifdef ! K
   @define K @80@
@endifdef

static void ATL_CM2BK
(
   ATL_CINT M,   /* # of rows in A */
   ATL_CINT N,   /* # of cols in A */
   ATL_CINT mu,  /* M unrolling */
   ATL_CINT nu,  /* N unrolling */
   TYPE *A,      /* column-major ldaxN matrix A */
   ATL_CINT lda, /* stride between row elements of A */
   TYPE *b       /* OUTPUT: muxnu blk storage of A */
)
{
   ATL_CINT nmuC = (M+mu-1)/mu, nnuC = (N+nu-1)/nu;
   ATL_CINT MMU = nmuC*mu, NNU = nnuC*nu;
   @iif kmaj > 1
   ATL_CINT gap = ((mu*nu+@(kmaj)-1)/@(kmaj))*@(kmaj) - mu*nu;
   @endiif
   @iif kmaj < 2
   ATL_CINT gap = 0;
   @endiif
   ATL_INT i, j;

   for (i=0; i != MMU; i += mu)
   {
      for (j=0; j != NNU; j += nu)
      {
         ATL_INT iu, ju;
         for (ju=0; ju < nu; ju++)
         {
            for (iu=0; iu < mu; iu++)
            {
               if (i+iu < M && j+ju < N)
                  *b++ = A[(j+ju)*lda+i+iu];
               else
                  *b++ = 0.0;
            }
         }
         b += gap;
      }
   }
}

int mmtst(void)
{
   #ifdef TCPLX
      int inca, incb, incc;
      const TYPE one=1.0, none=(-1.0);
      TYPE alpha[2] = {1.0, 0.0};
      TYPE beta[2] = {@(be).0, 0.0};
   #else
      TYPE alpha=1.0;
      TYPE beta=@(be).0;
   #endif
   const TYPE rone=1.0, rnone=(-1.0);
   void *va=NULL, *vb=NULL, *vc=NULL;
   TYPE *C, *D, *A, *B, *a, *b, *c;
@iif TRMM = 1
   ATL_INT MM, ldt; 
   TYPE *tA, *tB, *pT, *pR;
   const TYPE mynan = 0.0/0.0;
@endiif 
   TYPE diff, tmp;
@iif TRI = 1
   const TYPE mynan = 0.0/0.0;
@endiif
   int i, j, k, n, nerr;
@iif TRMM = 0
   ATL_CINT M=@(M), N=@(N), K=@(K), lda=M, ldb=K, ldc=M+3;
@endiif
@iif TRMM = 1
   #if SD_Right == 1
      ATL_CINT M=@(M), N=@(N), K=@(N), lda=M, ldc=M, ldb=N;
   #else
      ATL_CINT M=@(M), N=@(N), K=@(M), lda=M, ldb=M, ldc=M;
   #endif
@endiif
   ATL_CINT nmuC = (@(M)+@(mu)-1)/@(mu), nnuC = (@(N)+@(nu)-1)/@(nu);
   ATL_CINT MMU = nmuC*@(mu);
   ATL_CINT NNU = nnuC*@(nu);
   @iif kmaj > 1
   ATL_CINT KKU = (K+@(kmaj)-1)/@(kmaj)*@(kmaj);
      @iexp bsz @(kmaj) @(mu) @(nu) * @(kmaj) + -1 + / @(kmaj) *
   ATL_CINT szC = nmuC*nnuC*@(bsz);
   @endiif
   @iif kmaj < 2
   ATL_CINT KKU = K;
   ATL_CINT szC = MMU*NNU;
   @endiif
   TYPE ErrBound;

   #ifdef TREAL
      ErrBound = 2.0 * (2.0*K*EPS + Mabs(beta) * EPS) + EPS;
   #else
      tmp = Mabs(*beta) + Mabs(beta[1]);
      ErrBound =  2.0 * (8.0*K*EPS + tmp*EPS) + EPS;
   #endif
/*
 * Allocate normal & access-major storage arrays; access-major arrays are
 * always aligned to ATL_Cachelen
 */
   
   A = malloc(sizeof(TYPE)*lda*K);
   B = malloc(sizeof(TYPE)*ldb*N);
   C = malloc(sizeof(TYPE)*ldc*N);
   D = malloc(sizeof(TYPE)*ldc*N);
@iif TRMM = 1
/* 
 * TRMM:
 * allocate seperate space for TRMM's triangular matrix. We will assign NAN in 
 * one half of the matrix to make sure TRMM's copy-routine never accesses it
 */
#if SD_Right == 1
   tA = A;  
   tB = malloc(sizeof(TYPE)*ldb*N);  
#else
   tA = malloc(sizeof(TYPE)*lda*M);  
   tB = B;
#endif
   assert(tA && tB);
@endiif
   va = malloc(2*sizeof(TYPE)*MMU*KKU + ATL_Cachelen);
   vb = malloc(2*sizeof(TYPE)*NNU*KKU*@(dupB) + ATL_Cachelen);
   vc = malloc(2*sizeof(TYPE)*szC + ATL_Cachelen);
   a = ATL_AlignPtr(va);
   b = ATL_AlignPtr(vb);
   c = ATL_AlignPtr(vc);
/*
 * Fill in column-major arrays and translate to access-major
 */
   assert(A && B && C && a && b && c);
@iif TRMM = 0
   for (n=lda*K SHIFT, i=0; i < n; i++) A[i] = dumb_rand();
@iif TRI = 1
    for (j=0; j < N; j++)
       for (i=0; i < K; i++)
           B[i+j*ldb] = A[j+i*lda];
@endiif
@iif TRI = 0
   for (n=ldb*N SHIFT, i=0; i < n; i++) B[i] = dumb_rand();
@endiif
   for (n=ldc*N SHIFT, i=0; i < n; i++) C[i] = dumb_rand();
@endiif
@iif TRMM = 1
/*
 * Special initialization requirement for TRMM
 *    Left Side  : A = triangular, C = B
 *    Right Side : B = triangular, C = A 
 */
   #if SD_Right == 1
      pT = tB; pR = B; 
      ldt = ldb;
      MM = N;
   #else
      pT = tA; pR = A; 
      ldt = lda;
      MM = M;
   #endif
      for (j=0; j < MM; j++)
      {
         TYPE *Tc = pR + j*ldt, *tTc = pT + j*ldt;
   #if UP == 1 
         for (i=0; i <= (j SHIFT); i++)
            tTc[i] = Tc[i];
         for ( ; i < (MM SHIFT); i++)
         {
            Tc[i] = 0.0;     /* gemm's lower half filled with zero */
            tTc[i] = mynan;  /* trmm should never access lower half */
         }
   #else
         for (i=0; i < (j SHIFT); i++)
         {
            Tc[i] = 0.0;     /* gemm's upper half filled with zero */
            tTc[i] = mynan;  /* trmm should never access upper half */
         }
         for ( ; i < (MM SHIFT); i++)
            tTc[i] = Tc[i];
   #endif
      }
@endiif
/*
 * To ease debugging, make matrices easily mappable:
 *    A counts from 1.0-M*K, col-maj
 *    B counts from .1-K*N, col maj
 *    C counts from 1.0 - M*N, col maj
 */
   #if 0
   {
      int i, j;
      for (j=0; j < K; j++)
      {
         for (i=0; i < M; i++)
            A[i+j*lda] = 1.0+(i+j*M);
         for (; i < lda; i++)
            A[i+j*lda] = 1000000.0;
      }
      for (j=0; j < N; j++)
      {
         for (i=0; i < K; i++)
            B[i+j*ldb] = 0.1 + (i+j*M)*0.1;
         for (; i < ldb; i++)
            B[i+j*ldb] = 2000000.0;
      }
      for (j=0; j < N; j++)
      {
         for (i=0; i < M; i++)
            C[i+j*ldc] = 0; /* 1.0+(i+j*M); */
         for (; i < ldc; i++)
            C[i+j*ldc] = 3000000.0;
      }
   }
   #endif
@iif TRMM == 0
/*
 * A and B copy for access major
 */
   ATL_rm2am(K, M, 1.0, A, lda, a);
   @iif TRI = 0
      ATL_cm2am(K, N, 1.0, B, ldb, b);
   @endiif
   @iif @iexp @(TRI) @(mu) @(nu) ! &
      ATL_cm2am(K, N, 1.0, B, ldb, b);
   @endiif
@endiif
@iif TRMM == 1
/*
 * A and B copies for TRMM 
 */
#if SD_Right == 1
   ATL_rm2am(N, M, 1.0, tA, lda, a);
   B2BLK(N, 1.0, tB, ldb, b);    /* special triangular copy */ 
#else
   A2BLK(M, 1.0, tA, ldb, a);    /* special triangular copy */ 
   ATL_cm2am(M, N, 1.0, tB, ldb, b);
#endif
@endiif
/*
 * C copy 
 */
@iif TRI = 0
   #if 0
      ATL_CM2BK(M, N, @(mu), @(nu), C, ldc, c);
   #else
      ATL_C2blk(M, N, rone, C, ldc, 0.0, c);
   #endif
@endiif
@iif TRI = 1
/* 
 * Put NaN's above diag of C, so we are sure these vals not used in computation
 */
   for (j=0; j < N; j++)
   {
      TYPE *Cc=C+j*ldc, *Dc=D+j*ldc;
      for (i=0; i < (j SHIFT); i++)
         Dc[i] = mynan;
      for (; i < (M SHIFT); i++)
         Dc[i] = Cc[i];
   }
   @iexp vlp 0
   @iexp jj 1
   @iwhile jj < vlen
      @iexp vlp @(vlp) 1 +
      @iexp jj @(jj) 2 *
   @endiwhile

@skip   ATL_C2blk(M, N, rone, D, ldc, 0.0, c);
   Mjoin(PATL,skL2amLNB_a1b0)(N, @(mu), @(nu), @(vlp), rone, D, ldc, 0.0, c);
@endiif
/*
 * Call test routine, move output to col-major D for comparison with correct C
 */
@iif TRI = 1
   @iif mu ! nu
   ATL_USERMM(MMU/@(mu), NNU/@(nu), KKU, a, b, c, NULL, NULL, NULL);
   @endiif
   @iif mu = nu
   ATL_USERMM(MMU/@(mu), NNU/@(nu), KKU, a, a, c, NULL, NULL, NULL);
   @endiif
@endiif
@iif TRI = 0
   ATL_USERMM(MMU/@(mu), NNU/@(nu), KKU, a, b, c, NULL, NULL, NULL);
@endiif
   tst_mm(M, N, K, alpha, A, lda, B, ldb, beta, C, ldc);
/*
   printf("c=%e,%e,%e,%e; %e,%e,%e,%e\n", c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7]);
   printf("C=%e,%e,%e,%e; %e,%e,%e,%e\n", C[0], C[1], C[2], C[3], C[ldc], C[ldc+1], C[ldc+2], C[ldc+3]);
 */
@iif TRI = 0
   ATL_blk2C(M, N, 1.0, c, 0.0, D, ldc);
@endiif
@iif TRI = 1
   Mjoin(PATL,amL2skLNB_a1b0)(N, @(mu), @(nu), @(vlp), rone, c, 0.0, D, ldc);
@endiif

   nerr = 0;
   for (j=0; j < N; j++)
   {
@iif TRI = 0
      for (i=0; i < M SHIFT; i++)
@endiif
@iif TRI = 1
      for(i=0; i < j SHIFT; i++)
      {
         diff = D[i + j*(ldc SHIFT)];
         if (diff == diff)
         {
            fprintf(stderr, "C(%d,%d) : expected=NaN, got=%e!\n", i, j, D[k]);
            nerr++;
         }
      }
      for (; i < M SHIFT; i++)
@endiif
      {
         k = i + j*(ldc SHIFT);
         diff = C[k] - D[k];
         if (diff < 0.0) diff = -diff;
         if (diff > ErrBound)
         {
            fprintf(stderr, "C(%d,%d) : expected=%e, got=%e, diff=%e\n",
                    i, j, C[k], D[k], diff);
            nerr++;
         }
         else if (D[k] != D[k])   /* test for NaNs in test answer */
         {
            fprintf(stderr, "C(%d,%d) : expected=%e, got=%e\n",
                    i, j, C[k], D[k]);
            nerr++;
         }
      }
   }
   free(A);
   free(B);
@iif TRMM = 1
#if SD_Right == 1
   free(tB);
#else
   free(tA);
#endif
@endiif 
   free(C);
   free(va);
   free(vb);
   free(vc);
   free(D);
   return(nerr);
}

int main(void)
{
   int ierr;
   ierr = mmtst();
   if (!ierr) fprintf(stdout, "PASSED TEST\n");
   exit(ierr);
}
@ROUT ATL_ChooseNB
/*
 * This include file defines teh following:
 *   ATL_MM_MU : CPP macro of selected M unrolling factor
 *   ATL_MM_NU : CPP macro of selected N unrolling factor
 *   ATL_NKBS  : CPP macro of number of generated KBs
 *   ATL_KBS   : ATL_NKBS-length static array of all supported KBs;
 *               array is sorted from largest to smallest
 *   ATL_KItTimByKb : ATL_NKBS-length static double array time to perform one
 *                    k iteration of muxnu jammed loop
 *   ATL_mm_b0_Ks : ATL_NKBS-length function pointer array beta=0
 *   ATL_mm_b1_Ks : ATL_NKBS-length function pointer array beta=1
 *   ATL_mm_bn_Ks : ATL_NKBS-length function pointer array beta=-1
 *   ATL_DivByMU : CPP macro func that cheaply divides arg by MU 
 *   ATL_DivByNU : CPP macro func that cheaply divides arg by MU 
 *   ATL_MulByMU : CPP macro func that cheaply multiplies arg by MU 
 *   ATL_MulByNU : CPP macro func that cheaply multiplies arg by MU 
 */
#include Mstr(Mjoin(Mjoin(atlas_,PRE),mm.h))
int ATL_FindClosestKB(ATL_CINT K)
/*
 * Of the given KBs, find first one >= supplied K using recursive refinement
 * search
 */
{
   int i, imax, imin;
   if (K >= ATL_KBS[ATL_NKBS-1])
      return(ATL_NKBS-1);
   else if (K <= ATL_KBS[0])
      return(0);
   imax = ATL_NKBS-1;
   imin = 0;
   while (imax-imin > 1)
   {
      int k;
      i = (imin + imax) >> 1;
      k = ATL_KBS[i];
      if (k > K)
         imax = i;
      else if (k < K)
         imin = i;
      else if (k == K)
         return(i);
   }
   return((k < K) ? imax : i);
}

int ATL_ChooseNB(ATL_CINT M, ATL_CINT N, ATL_CINT K)
/* 
 * RETURNS: index into ATL_KBS of NB to use to min time for MxNxK gemm
 */
{
   size_t nnus, nmus, nkbs;
   int kb, kr, imin;
   double nmblks, minTime, t0;

   nmus = M + ATL_MM_MU - 1;
   nnus = N + ATL_MM_NU - 1;
   nmus = ATL_DivByMU(nmus);
   nnus = ATL_DivByNU(nnus);
   nmblks = nmus;
   nmblks *= nnus;
   kb = ATL_KBS[0];
   nkbs = K / kb;
   kr = K - nkbs*kb;
   minTime = nmblks * nkbs*ATL_KItTimByKb[0] + 
             ATL_KItTimByKb[ATL_FindClosestKB(kr)];
   imin = 0;
   for (i=1; i < ATL_NKBS; i++)
   {
      double t0;
      kb = ATL_KBS[i];
      nkbs = K / kb;
      kr = K - nkbs*kb;
      t0 = nmblks * nkbs*ATL_KItTimByKb[0] + 
           ATL_KItTimByKb[ATL_FindClosestKB(kr)];
      if (t0 < minTime)
      {
         minTime = t0;
         imin = i;
      }
   }
   return(imin);
}
@ROUT ATL_ngemm

@whiledef al 1 X
#define ATL_A2blk_a@(al) Mjoin(Mjoin(PATL,rm2am_a@(al)_),ATL_MM_MU)
#define ATL_AT2blk_a@(al) Mjoin(Mjoin(PATL,cm2am_a@(al)_),ATL_MM_MU)
#define ATL_B2blk_a@(al) Mjoin(Mjoin(PATL,cm2am_a@(al)_),ATL_MM_NU)
#define ATL_BT2blk_a@(al) Mjoin(Mjoin(PATL,rm2am_a@(al)_),ATL_MM_NU)
@endwhile
@ROUT ATL_cmat2ablk C2blk_sse C2blk_avx
@beginproc pcloops aligned vtyp ralp rbet
   @mif vtyp = "__m256
      @define velts @8@
      @define vadd @_mm256_add_ps@
      @define vsub @_mm256_sub_ps@
      @define vmul @_mm256_mul_ps@
      @define vld @_mm256_load_ps@
      @define vst @_mm256_store_ps@
      @iif aligned = 0
         @define vldu @_mm256_loadu_ps@
         @define vstu @_mm256_storeu_ps@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm256_load_ps@
         @define vstu @_mm256_store_ps@
      @endiif
   @endmif
   @mif vtyp = "__m256d
      @define velts @4@
      @define vadd @_mm256_add_pd@
      @define vsub @_mm256_sub_pd@
      @define vmul @_mm256_mul_pd@
      @define vld @_mm256_load_pd@
      @define vst @_mm256_store_pd@
      @iif aligned = 0
         @define vldu @_mm256_loadu_pd@
         @define vstu @_mm256_storeu_pd@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm256_load_pd@
         @define vstu @_mm256_store_pd@
      @endiif
   @endmif
   @mif vtyp = "__m128d
      @define velts @2@
      @define vadd @_mm_add_pd@
      @define vsub @_mm_sub_pd@
      @define vmul @_mm_mul_pd@
      @define vld @_mm_load_pd@
      @define vst @_mm_store_pd@
      @iif aligned = 0
         @define vldu @_mm_loadu_pd@
         @define vstu @_mm_storeu_pd@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm_load_pd@
         @define vstu @_mm_store_pd@
      @endiif
   @endmif
   @mif vtyp = "__m128
      @define velts @4@
      @define vadd @_mm_add_ps@
      @define vsub @_mm_sub_ps@
      @define vmul @_mm_mul_ps@
      @define vld @_mm_load_ps@
      @define vst @_mm_store_ps@
      @iif aligned = 0
         @define vldu @_mm_loadu_ps@
         @define vstu @_mm_storeu_ps@
      @endiif
      @iif aligned ! 0
         @define vldu @_mm_load_ps@
         @define vstu @_mm_store_ps@
      @endiif
   @endmif
      for (j=0; j < n; j += @(nu), b += incb)
      {
         TYPE *p = b;
         for (i=0; i < m; i += @(mu), p += pansz)
         {
            register @(vtyp) rP0, rp0;
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu)
         @iexp h 0 0 +
            rp0 = @(vldu)(C@(j)+i+@(i));
         @mif nalp = "X
            rp0 = @(vmul)(rp0, @(ralp));
         @endmif
         @mif nbet = "0
            @mif nalp = "n
            rp0 = @(vmul)(rp0, @(ralp));
            @endmif
            @(vst)(p+@(k), rp0);
            @iexp h 1 0 +
         @endmif
         @iif h = 0
            rP0 = @(vld)(p+@(k));
            @mif nbet = "X
            rP0 = @(vmul)(rP0, @(rbet));
            @endmif
            @mif nalp = "n
               @mif nbet = "0
            rp0 = @(vmul)(rp0, @(ralp));
            @(vst)(p+@(k), rp0);
                  @iexp h 1 0 +
               @endmif
               @mif nbet = "n
            rP0 = @(vadd)(rP0, rp0);
            rP0 = @(vmul)(rP0, @(ralp));
            @(vst)(p+@(k), rP0);
                  @iexp h 1 0 +
               @endmif
               @iif h = 0
            rP0 = @(vsub)(rP0, rp0);
            @(vst)(p+@(k), rP0);
                  @iexp h 1 0 +
               @endiif
            @endmif
            @iif h = 0
               @mif nbet = "n
            rp0 = @(vsub)(rp0, rP0);
            @(vst)(p+@(k), rp0);
               @endmif
               @mif nbet ! "n
            rP0 = @(vadd)(rP0, rp0);
           @(vst)(p+@(k), rP0);
               @endmif
            @endiif
         @endiif
         @iexp k @(k) @(velts) +
      @iexp i @(i) @(velts) +
      @endiwhile
   @iexp j @(j) 1 +
   @endiwhile
         }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
         @mif nalp = "n
            @mif nbet = "X
         p[@(k)] = beta*p[@(k)] - C@(j)[i+@(i)];
            @endmif
            @mif nbet = "1
         p[@(k)] -= C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
         p[@(k)] = @(malp)C@(j)[i+@(i)] + beta*p[@(k)];
            @endmif
            @mif nbet = "1
         p[@(k)] += @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = @(malp)C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
         C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
      }
   @undef velts
   @undef vadd
   @undef vsub 
   @undef vmul 
   @undef vld 
   @undef vldu 
   @undef vstu 
@endproc
/*
 *  b <- alpha*C + beta*b,
 *  C is an MxN matrix in column-major storage
 *  b is a CEIL(M/@(mu))*@(mu) x CEIL(N/@(nu))*@(nu) matrix stored in
 *    @(mu)x@(nu)-major storage
 */
@beginproc pcfunc vtyp
#include <immintrin.h>
   @mif vtyp = "__m256
      @define andC @0x1F@
      @define andL @7@
      @define vtyp2 @__m128@
      @define andC2 @0xF@
      @define andL2 @3@
      @define ibe @{beta,beta,beta,beta,beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha,alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
      @define ib2 @{beta,beta,beta,beta}@
      @define ia2 @{alpha,alpha,alpha,alpha}@
      @define in2 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m256d
      @define andC @0x1F@
      @define andL @3@
      @define vtyp2 @__m128d@
      @define andC2 @0xF@
      @define andL2 @1@
      @define ibe @{beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
      @define ib2 @{beta,beta}@
      @define ia2 @{alpha,alpha}@
      @define in2 @{ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m128
      @define andC @0xF@
      @define andL @3@
      @define ibe @{beta,beta,beta,beta}@
      @define ial @{alpha,alpha,alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone,ATL_rnone,ATL_rnone}@
   @endmif
   @mif vtyp = "__m128d
      @define andC @0xF@
      @define andL @1@
      @define ibe @{beta,beta}@
      @define ial @{alpha,alpha}@
      @define in1 @{ATL_rnone,ATL_rnone}@
   @endmif

@skip void Mjoin(PATL,cmat2ablk_@(mu)x@(nu)_a@(nalp)_b@(nbet))
void ATL_USERCPMM       /* col-major C to access-major C */
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for C */
   const TYPE *C,       /* matrix to be copied to access-major format */
   ATL_CSZT ldc,        /* stride between row elements */
   const SCALAR beta,   /* scalar for b */
   TYPE *b              /* matrix stored in @(mu)x@(nu)-major order */
)
{
   ATL_CINT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CINT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CINT incC = ldc*@(nu), incb = @(mu)*@(nu);
   ATL_INT i, j;
   @mif nbet = "X
   const register @(vtyp) rBETA=@(ibe);
   @endmif
   @mif nbet = "n
   const register @(vtyp) rBETA=@(in1);
   @endmif
   @mif nalp = "X
   const register @(vtyp) rALP=@(ial);
   @endmif
   @mif nalp = "n
   const register @(vtyp) rALP=@(in1);
   @endmif
   @declare "   const TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare

@ROUT ATL_cmat2ablk
/*
 * If C is aligned, use aligned load/stores to C
 */
   if (((((size_t)C) & @(andC))|(ldc&@(andL))) == 0)
   {
      @callproc pcloops 1 @(vtyp) rALP rBETA
   }
   @mif andC = "0x1F
   else if (((((size_t)C) & @(andC2))|(ldc&@(andL2))) == 0)
   {
      @(vtyp2) ralp=@(ia2), rbet=@(ib2);
      @callproc pcloops 1 @(vtyp2) ralp rbet
   }
   @endmif
   else
@ROUT ATL_cmat2ablk C2blk_sse C2blk_avx
   {
      @callproc pcloops 0 @(vtyp) rALP rBETA
   }
   @mif nu ! "1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < m; i += @(mu), b += pansz)
      {
      @iexp k 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @mif nbet = "X
         b[@(k)] = @(malp)C@(j)[i+@(i)] + beta*b[@(k)];
            @endmif
            @mif nbet = "1
         b[@(k)] += @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         b[@(k)] = @(malp)C@(j)[i+@(i)] - b[@(k)];
            @endmif
            @mif nbet = "0
         b[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @iexp k @(k) 1 +
         @iexp i @(i) 1 +
         @endiwhile
      @iexp j @(j) 1 +
      @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
               @mif nbet = "n
         b[@(k)] = @(malp)C@(j)[i+@(i)] - b[@(k)];
               @endmif
               @mif nbet = "X
         b[@(k)] = @(malp)C@(j)[i+@(i)] + beta*b[@(k)];
               @endmif
               @mif nbet = "1
         b[@(k)] += @(malp)C@(j)[i+@(i)];
               @endmif
               @mif nbet = "0
         b[@(k)] = @(malp)C@(j)[i+@(i)];
               @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         b += incb;
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endmif
}
   @undef ial
   @undef ibe
   @undef in1
   @undef andC
   @undef andL
@endproc
@ROUT C2blk_avx 
#if defined(ATL_AVX) && defined(DREAL)
   @iif @iexp 0 4 @(mu) % !
   #error "MU must be a multiple of 4!"
   @endiif
   @callproc pcfunc __m256d
#endif
#if defined(ATL_AVX) && defined(SREAL)
   @iif @iexp 0 8 @(mu) % !
   #error "MU must be a multiple of 8!"
   @endiif
   @callproc pcfunc __m256
#endif
@ROUT C2blk_sse
#if defined(ATL_SSE2) && defined(DREAL)
   @iif @iexp 0 2 @(mu) % !
   #error "MU must be a multiple of 2!"
   @endiif
   @callproc pcfunc __m128d
#endif
#if defined(ATL_SSE1) && defined(SREAL)
   @iif @iexp 0 4 @(mu) % !
   #error "MU must be a multiple of 4!"
   @endiif
   @callproc pcfunc __m128
#endif
@ROUT ATL_cmat2ablk
@iexp vtst 4 @(mu) %
@iif vtst = 0
#if 0 && defined(ATL_AVX) && defined(DREAL)  /* AVX loses perf for unaligned */
   @callproc pcfunc __m256d
@endiif
@iif vtst ! 0
#if 0
@endiif
@iexp vtst 8 @(mu) %
@iif vtst = 0
#elif 0 && defined(ATL_AVX) && defined(SREAL) /* AVX loses perf for unaligned */
   @callproc pcfunc __m256
@endiif
@iif vtst ! 0
#elif 0
@endiif
@iexp vtst 2 @(mu) %
@iif vtst = 0
#elif defined(ATL_SSE2) && defined(DREAL) && defined(__GNUC__)
   @callproc pcfunc __m128d
@endiif
@iif vtst ! 0
#elif 0
@endiif
@iexp vtst 4 @(mu) %
@iif vtst = 0
#elif defined(SREAL) && defined(ATL_SSE1) && defined(__GNUC__)
   @callproc pcfunc __m128
@endiif
@iif vtst ! 0
#elif 0
@endiif
#else
void Mjoin(PATL,cmat2ablk_@(mu)x@(nu)_a@(nalp)_b@(nbet))
(
   ATL_CSZT M,          /* number of rows in A */
   ATL_CSZT N,          /* number of columns in A */
   const SCALAR alpha,  /* scalar for C */
   const TYPE *C,       /* matrix to be copied to access-major format */
   ATL_CSZT ldc,        /* stride between row elements */
   const SCALAR beta,   /* scalar for b */
   TYPE *b              /* matrix stored in @(mu)x@(nu)-major order */
)
{
   ATL_CINT m = (M/@(mu))*@(mu), n = (N/@(nu))*@(nu), mr = M-m, nr = N-n;
   ATL_CINT pansz = (nr) ? (n+@(nu))*@(mu) : n*@(mu);
   ATL_CINT incC = ldc*@(nu), incb = @(mu)*@(nu);
   ATL_INT i, j;
   @declare "   const TYPE " n n ";"
      *C0=C
      @define j @1@
      @iwhile j < @(nu)
         @iexp i @(j) -1 +
         *C@(j)=C@(i)+ldc
         @iexp j @(j) 1 +
      @endiwhile
   @enddeclare

   for (j=0; j < n; j += @(nu), b += incb)
   {
      TYPE *p = b;
      for (i=0; i < m; i += @(mu), p += pansz)
      {
   @iexp k 0 0 +
   @iexp j 0 0 +
   @iwhile j < @(nu)
      @iexp i 0 0 +
      @iwhile i < @(mu)
         @mif nalp = "n
            @mif nbet = "X
         p[@(k)] = beta*p[@(k)] - C@(j)[i+@(i)];
            @endmif
         @mif nbet = "1
         p[@(k)] -= C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
         p[@(k)] = @(malp)C@(j)[i+@(i)] + beta*p[@(k)];
            @endmif
         @mif nbet = "1
         p[@(k)] += @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = @(malp)C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @endmif
         @iexp k @(k) 1 +
      @iexp i @(i) 1 +
      @endiwhile
   @iexp j @(j) 1 +
   @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
         @mif nalp = "n
            @mif nbet = "X
         p[@(k)] = beta*p[@(k)] - C@(j)[i+@(i)];
            @endmif
            @mif nbet = "1
         p[@(k)] -= C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = -(p[@(k)] + C@(j)[i+@(i)]);
            @endmif
         @endmif
         @mif nalp ! "n
            @mif nbet = "X
         p[@(k)] = @(malp)C@(j)[i+@(i)] + beta*p[@(k)];
            @endmif
            @mif nbet = "1
         p[@(k)] += @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "0
         p[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         p[@(k)] = @(malp)C@(j)[i+@(i)] - p[@(k)];
            @endmif
         @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
   @iexp j 0 0 +
   @iwhile j < @(nu)
      C@(j) += incC;
      @iexp j @(j) 1 +
   @endiwhile
   }
   @mif nu ! "1
   switch(nr)
   {
   @iexp n 1 0 +
   @iwhile n < @(nu)
   case @(n):
      for (i=0; i < m; i += @(mu), b += pansz)
      {
      @iexp k 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(n)
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @mif nbet = "X
         b[@(k)] = @(malp)C@(j)[i+@(i)] + beta*b[@(k)];
            @endmif
            @mif nbet = "1
         b[@(k)] += @(malp)C@(j)[i+@(i)];
            @endmif
            @mif nbet = "n
         b[@(k)] = @(malp)C@(j)[i+@(i)] - b[@(k)];
            @endmif
            @mif nbet = "0
         b[@(k)] = @(malp)C@(j)[i+@(i)];
            @endmif
            @iexp k @(k) 1 +
         @iexp i @(i) 1 +
         @endiwhile
      @iexp j @(j) 1 +
      @endiwhile
      }
      @mif mu ! "1
      switch(mr)
      {
      @iexp m 1 0 +
      @iwhile m < @(mu)
      case @(m):
         @iexp j 0 0 +
         @iwhile j < @(n)
            @iexp k @(mu) @(j) *
            @iexp i 0 0 +
            @iwhile i < @(m)
               @mif nbet = "n
         b[@(k)] = @(malp)C@(j)[i+@(i)] - b[@(k)];
               @endmif
               @mif nbet = "X
         b[@(k)] = @(malp)C@(j)[i+@(i)] + beta*b[@(k)];
               @endmif
               @mif nbet = "1
         b[@(k)] += @(malp)C@(j)[i+@(i)];
               @endmif
               @mif nbet = "0
         b[@(k)] = @(malp)C@(j)[i+@(i)];
               @endmif
               @iexp k @(k) 1 + 
            @iexp i @(i) 1 +
            @endiwhile
         @iexp j @(j) 1 +
         @endiwhile
         b += incb;
         break;
      @iexp m @(m) 1 +
      @endiwhile
      default:;
      }
      @endmif
      break;
   @iexp n @(n) 1 +
   @endiwhile
   default:;
   }
   @endmif
}
#endif
