@define ip @0@
@ROUT smvcases.idx dmvcases.idx cmvcases.idx zmvcases.idx
#
# In this file, any line beginning with a '#' is ignored, but the # must be in
# column 0.  All multiple whitespace is reduced to one space (i.e. used only
# to distinguish where words begin/end).  Lines may be extended by putting '\'
# as the *last* character of line.
#
# The file has the following format:
# ROUT='routine name' AUTH='author names' COMP='compiler name' FLAGS='flags'
# ID=<id> NU=<nu> MU=<mu> minN=<#> minM=<#> alignX=<#> alignY=<#> alignA=<#>,
# TA='[t,n,c]' TB='[t,n,c]' SSE=[0,1,2,3] X87=[0,1] 
# LDTOP=[0,1] ALLALIGNXY=[0,1] AXPYBASED=[0,1] GEMMBASED=[0,1] CONJDEF=[0,1]
# ASM=[asmlist], eg., asmlist is "GAS_x8664,GAS_x8632" or "GAS_SPARC"
# ASM defaults to no assembly dialect required.
# If NU/MU is negative, then the routine can only handle multiples of NU/MU.
#
# Assuming N is the length of X, and M is the length of Y, all routines
# are assumed to handle any runtime value of M >= minN, N >= minM.
# They must respect the compile-time macros BETA0, BETA1, & BETAX.
# Some less-obvious keywords:
# LDTOP     : set to 1 if load Y at top of MV loop (more error)
# CONJDEF   : Defining Conj_ will cause A to be conjugated before use
#             if 0, then can only be used for TA setting
# ALLALIGNXY: Create k copies of X and Y, where k is the number of times
#             the native alignment goes into the required alignment.  So,
#             if ALIGNX=16, and we are doing single precision, X will be
#             passed as float *X[4], and X[0] will be 16-byte aligned,
#             X[1]: 4-byte aligned, X[2]: 8-byte aligned, X[3]: 12 byte aligned
#             if ALIGN[X/Y] == native length, then this flag has no effect on
#             that vector.
# AXPYBASED : Routine employs the outer-product matvec (mainly for NoTrans)
# GEMMBASED : Kernel calls GEMM to do matvec
# PFTUNEx   : Kernel uses pref_x(mem) macro for each op=x (A,y,x).  prefetch
#             inst can be varied wt this macro, as can fetch distance.
#
@ROUT mmread
#ifndef ATLAS_MMPARSE_H
   #define ATLAS_MMPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MMF_LDCTOP      0  /* 1: load C before K-loop, 0: ld after */
#define MMF_X87         1  /* 1: requires the Intel x87 unit */
#define MMF_MRUNTIME    2  /* 1: M dim is run-time variable */
#define MMF_NRUNTIME    3  /* 1: M dim is run-time variable */
#define MMF_KRUNTIME    4  /* 1: M dim is run-time variable */
#define MMF_KUISKB      5  /* 1: KU == KB */
#define MMF_LDISKB      6  /* 1: lda=ldb=KB */
#define MMF_BETAN1      7  /* 1: kernel has special support for BETA = -1 */
#define MMF_LDAB        8  /* 1: lda = ldb */
#define MMF_AOUTER      9  /* 1: MNK loop order, 0: NMK loop order */
#define MMF_LDFLOAT    10  /* 1: use single prec load for double */
#define MMF_STFLOAT    11  /* 1: use single prec load for double */
#define MMF_PFACOLS    12  /* 1: prefetch next mu cols of A */
#define MMF_PFABLK     13  /* 1: prefetch next KBxNB block of A */
#define MMF_PFBCOLS    14  /* 1: prefetch next nu cols of B */
#define MMF_PFCELTS    15  /* 1: pf elts of C at top of loop, load at bottom */
#define MMF_SINGLE     16  /* 1: single precision, else double */
#define MMF_COMPLEX    17  /* 1: complex type, else real */
#define MMF_L14NB      18  /* 1: need to fit all 3 matrices+nextA in L1 */

#define MMF_DEFAULT ( (1<<MMF_LDISKB) | (1<<MMF_LDAB) )
#ifndef  FLAG_IS_SET
   #define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )
#endif

typedef struct MMNode ATL_mmnode_t;
struct MMNode
{
   double mflop[8];     /* 1st entry perf using mbB, nbB, kbB */
   int ID, mu, nu, ku;  /* ID, and unrolling on each loop */
   int kbmin, kbmax;    /* min/max KB this kernel can handle */
   int SSE;             /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int lat, muladd, pref, clean, fftch, iftch, nftch; /* used for gened codes */
   int mbB, nbB, kbB;  /* best blocking dims found by search */
   enum ATLAS_TRANS TA, TB;
   int asmbits;   /* bitfield indicating which assembly(ies) is required */
   char *rout, *auth, *comp, *cflags;
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   int flag;
   ATL_mmnode_t *next;
};

@ROUT r1read
#ifndef ATLAS_R1PARSE_H
   #define ATLAS_R1PARSE_H

#include "atlas_genparse.h"


#define R1F_INCACHE     0  /* consider kernel for in-cache gemv */
#define R1F_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define R1F_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define R1F_ALIGNX2A    3  /* X forced to same alignment as A */
#define R1F_SINGLE      4  /* single precision */
#define R1F_COMPLEX     5  /* complex arithmetic */
#define R1F_APTRS       6  /* use ptrs rather than lda for column indexing */
#define R1F_X87         7  /* requires the Intel x87 unit */
#define R1F_FNU         8  /* N must be a multiple of NU */
#define R1F_ADDCFLAGS   9  /* don't replace: append cflags to default flags */
#define R1F_INCYISONE  10
#define R1F_NFLAGS     11
#define R1F_PFTUNABLE  14  /* Can tune PFDIST & INST? */
char *R1F_exp[R1F_NFLAGS] = 
{
"Consider kernel for in-cache use only",
"Consider kernel for out-of-cache use only",
"X&Y are copied into all legal alignments",
"X forced to have same alignment as A",
"Data uses single precision",
"Data is of complex type",
"use ptrs rather than lda for column indexing",
"Kernel requires the x87 unit for correct operation",
"N must be a multiple of NU"
};

#define R1F_DEFAULT ((1<<R1F_INCACHE) | (1<<R1F_OUTCACHE))
typedef struct R1NODE ATL_r1node_t;
struct R1NODE
{
   double mflop[8];
   ATL_r1node_t *next;
   char *rout;                  /* filename/path for kernel */
   char *auth;                  /* author of kernel */
   char *comp;                  /* particular compiler required for kernel */
   char *cflags;                /* compiler flags required for kernel */
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *exflags;               /* extra flags to pass test/time call */
   char *genstr;                /* system(genstr) will generate gened kernel */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int NMU;                     /* # of repetitions of MU */
   int minN, minM;              /* min veclen to call the rout with */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int rankR;                   /* restriction rank, higher faster kern */
   int flag;                    /* bit vector of R1F_* */
};

@ROUT mvread
#ifndef ATLAS_MVPARSE_H
   #define ATLAS_MVPARSE_H

#include "atlas_genparse.h"
#include "atlas_enum.h"

#define MVF_INCACHE     0  /* consider kernel for in-cache gemv */
#define MVF_OUTCACHE    1  /* consider kernel for out-of-cache gemv */
#define MVF_ALLALIGNXY  2  /* X&Y are copied into all legal alignments */
#define MVF_AXPYBASED   3  /* 0:ddot based, 1: axpy-based */
#define MVF_GEMMBASED   4  /* gemm-based */
#define MVF_LDYTOP      5  /* 0: load Y value after dot product */
#define MVF_CONJDEF     6  /* 1: conj(A) if Conj_ is defined */
#define MVF_X87         7  /* requires the Intel x87 unit */
#define MVF_FNU         8  /* Length of Y must be a multiple of NU */
#define MVF_SINGLE      9  /* 1: single precision, else double */
#define MVF_COMPLEX    10  /* 1: complex type, else real */
#define MVF_ADDCFLAGS  11  /* don't replace: append cflags to default flags */
#define MVF_ALIGNX2A   12  /* X (Y if AXPYBASED) forced to same alignmnt as A */
#define MVF_INCYISONE  13
#define MVF_PFTUNABLE  14  /* Can tune PFDIST & INST? */

#define MVF_DEFAULT ((1<<MVF_INCACHE) | (1<<MVF_OUTCACHE))
typedef struct MVNODE ATL_mvnode_t;
struct MVNODE
{
   double mflop[8];
   ATL_mvnode_t *next;
   char *rout, *auth, *comp, *cflags;
   char *kname;                 /* The name kernel should be compiled to */
   char *str;                   /* tmp string used in generation */
   char *genstr;                /* system(genstr) will generate gened kernel */
   char *exflags;               /* extra flags to pass test/time call */
   int alignA, alignX, alignY;  /* required alignments */
   int ldamul;                  /* lda must be a multiple of ldamul */
   int ID, NU, MU;              /* unrolling for Y & X vectors */
   int minN, minM;              /* min veclen to call the rout with */
   int CacheElts;               /* # of cache elts to assume for blocking */
   int SSE;                     /* 0: no SSE, 1: SSE1 req, 2: SSE2 req, etc */
   int asmbits;                 /* valid assemblies in this file */
   int rankR;                   /* restriction rank, higher faster kern */
   int ntlb;                    /* for dot-based alg, col blocking for TLB */
   enum ATLAS_TRANS TA;         /* transpose setting */
   int flag;                    /* bit vector of MVF_* */
};

@ROUT genparse
#ifndef ATLAS_GENPARSE_H
   #define ATLAS_GENPARSE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
@extract -b @(basd)/atlconf.base rout=asmconf.h
/*
 * Basic data structure for forming queues with some minimal info
 */
typedef struct SIDNode ATL_sidnode_t;
struct SIDNode  /* holds string, integer, and double */
{
   double d;
   char *str;
   int i;
   ATL_sidnode_t *next;
};

#define SET_FLAG(bits_, flg_, val_) \
{\
   if (val_) (bits_) |= (1<<(flg_)); \
   else (bits_) &= ~(1<<(flg_)); \
}
#define FLAG_IS_SET(field_, bit_) ( ((field_) & (1<<(bit_))) != 0 )

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_NewSIDNode(void)
{
   ATL_sidnode_t *sp;
   sp = calloc(1, sizeof(ATL_sidnode_t));
   assert(sp);
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) : allocates ATL_sidnode_t */
static ATL_sidnode_t *ATL_FreeSIDNode(ATL_sidnode_t *die)
{
   ATL_sidnode_t *sp=NULL;
   if (die)
   {
      sp = die->next;
      if (die->str)
         free(die->str);
      free(die);
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheElts(char pre)
{
   FILE *L1f;
   int L1Size, i;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   assert(L1Size > 0);
   if (pre == 'c' || pre == 'd')
      i = 1024/8;
   else if (pre == 's')
      i = 1024/4;
   else if (pre == 'z')
      i = 1024/16;
   else
      assert(0);
   return(i*L1Size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *DupString(char *str)
{
   int i,n;
   char *s;

   if (!str)
      return(NULL);
   n = strlen(str)+1;
   s = malloc(sizeof(char)*n);
   assert(s);
   for (i=0; i < n; i++)
      s[i] = str[i];
   return(s);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetSingleQuoteString(char *str)
{
   char *sp;
   int i, n;

   assert(str[0] == '\'');
   for (i=1; str[i] && str[i] != '\''; i++);
   assert(str[i]);
   sp = malloc(i*sizeof(char));
   for (n=i,i=1; i < n; i++)
      sp[i-1] = str[i];
   sp[n-1] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int asmNames2bitfield(char *str)
/*
 * Takes str containing an assembly name list.  The list is ended by the first
 * white space or end of string.  List items are seperated by ',', and there
 * can be no whitespace in list.
 * RETURNS: bitfield with bits set corresponding to assemblies, 0 on error.
 */
{
   char asmname[64];
   int i, KeepOn, bits=0;

   do
   {
      for (i=0; !isspace(str[i]) && str[i] != ',' && str[i] && i < 64; i++)
         asmname[i] = str[i];
      asmname[i] = '\0';
      KeepOn = str[i] == ',';
      str += i+1;
      if (i >= 64)
         return(0);  /* no asm name > 63 in length */
      for (i=0; i < NASMD; i++)
      {
         if (!strcmp(ASMNAM[i], asmname))
         {
            bits |= (1<<i);
            break;
         }
      }
   }
   while(KeepOn);
   return(bits);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetDoubleArr(char *str, int N, double *d)
/*
 * Reads in a list with form "%le,%le...,%le"; N-length d recieves doubles.
 * RETURNS: the number of doubles found, or N, whichever is less
 */
{
   int i=1;
   assert(sscanf(str, "%le", d) == 1);
   while (i < N)
   {
      str = strstr(str, ",");
      if (!str)
         break;
      str++;
      assert(sscanf(str, "%le", d+i) == 1);
      i++;
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetLongerString(char *shrt, int newlen)
/*
 * Allocates new string of size newlen, copies shrt into it, and frees shrt.
 */
{
   char *sp;

   sp = malloc(sizeof(char)*newlen);
   assert(sp);
   if (shrt)
   {
      strcpy(sp, shrt);
      free(shrt);
   }
   else if (newlen >= 0)
      sp[0] = '\0';
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetOneLine(FILE *fpin)
/*
 * RETURNS: string of one line from stream fpin,  NULL if stream exhausted.
 */
{
   const int inc=256;
   static int len=0;
   static char *ln, *sp;
   int i, j, KeepOn;

   if (!len)
   {
      ln = malloc(inc*sizeof(char));
      assert(ln);
      len = inc;
   }
   if (!fgets(ln, len, fpin))
      return(NULL);

   for (i=0; ln[i]; i++);  /* find end of string */
   if (!i) return(ln);
   while (ln[i-1] != '\n')    /* if last char not \n, read rest of line */
   {
      len += inc;
      ln = GetLongerString(ln, len);
      if (!fgets(ln+i, inc, fpin))
         return(ln);
       for (; ln[i]; i++);  /* find end of string */
   }
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetJoinedLines(FILE *fpin)
/*
 * Gets lines from file fpin; if last non-whitespace char is '\', joins lines
 * RETURNS: line from file including joining, NULL if fpin exhausted
 */
{
   char *ln, *sp;
   static char *join=NULL;
   static int jlen=0;
   int i, j, k;

   sp = ln = GetOneLine(fpin);
   if (!sp)
      return(NULL);
   j = 0;   /* current length of join string */
   if (ln)
   {
      for (i=0; ln[i]; i++);  /* find end of string */
      if (!i) return(NULL);
      for (i--; isspace(ln[i]) && i > 0; i--);  /* find last non-wspace char */
      while (ln[i] == '\\')
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k < i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j++] = ' ';
         join[j] = '\0';
         ln = GetOneLine(fpin);   /* get new line that should be joined */
         assert(ln);              /* can't end file with continue */
         for (i=0; ln[i]; i++);   /* find end of new line */
         for (i--; isspace(ln[i]) && i > 0; i--); /* find last non-wspc char */
         sp = join;
      }
      if (sp == join)
      {
         if (jlen < j+i+3)
         {
            jlen = j+i+i+3;
            join = GetLongerString(join, jlen);
         }
         for (k=0; k <= i; k++)
            join[j+k] = ln[k];
         j += k;
         join[j] = '\n';
         join[j+1] = '\0';
         sp = join;
      }
   }
   return(sp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetGoodGcc()
/*
 * Gets gcc path and name along with mandatory flags (-g/-m64/-pg,etc) by
 * querying Make.inc setting
 */
{
   static char gcc[2048];
   static int INIT=0;
   if (!INIT)
   {
      FILE *fpin;
      assert(system("make res/goodgcc.txt > /dev/null 2>&1") == 0);
      fpin = fopen("res/goodgcc.txt", "r");
      assert(fpin);
      assert(fscanf(fpin, "'%[^\']", gcc) == 1);
      fclose(fpin);
   }
   return(gcc);
}

static char *GetKCFlags(char pre)
/*
 * Gets flags being used for <pre>KCFLAGS
 */
{
   char ln[4096];
   FILE *fpin;
   int i;

   if (pre == 'z')
      pre = 'd';
   else if (pre == 'c')
      pre = 's';
   i = system("rm -f res/kcflags.txt");
   sprintf(ln, "grep \"%cKCFLAGS = \" Make.inc | sed s/%cKCFLAGS\\ =\\ // > res/kcflags.txt", toupper(pre), toupper(pre));
   assert(system(ln) == 0);
   fpin = fopen("res/kcflags.txt", "r");
   assert(fpin);
   assert(fgets(ln, 4096, fpin) != NULL);
   fclose(fpin);
/*
 * Get rid of trailing and leading whitespaces
 */
   for (i=0; ln[i]; i++);
   for (i--; isspace(ln[i]); i--);
   ln[i+1] = '\0';
   for (i=0; isspace(ln[i]); i++);
   return(DupString(ln+i));
}
#endif /* end atlas_genparse.h guard */
@ROUT mmread
   @define rt @mm@
@ROUT mvread
   @define rt @mv@
@ROUT r1read
   @define rt @r1@
@ROUT r1read mvread mmread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Get@up@(rt)Node(void)
{
   ATL_@(rt)node_t *p;
   p = calloc(1, sizeof(ATL_@(rt)node_t));
   assert(p);
@ROUT mvread `   p->TA = AtlasNoTrans;`
@ROUT mmread `   p->TA = AtlasTrans; p->TB = AtlasNoTrans;`
   p->flag = @up@(rt)F_DEFAULT;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Clone@up@(rt)Node(ATL_@(rt)node_t *dup)
{
   ATL_@(rt)node_t *p;
   p = malloc(sizeof(ATL_@(rt)node_t));
   assert(p);
   memcpy(p, dup, sizeof(ATL_@(rt)node_t));
   if (dup->rout)
      p->rout = DupString(dup->rout);
   if (dup->auth)
      p->auth = DupString(dup->auth);
   if (dup->comp)
      p->comp = DupString(dup->comp);
   if (dup->cflags)
      p->cflags = DupString(dup->cflags);
   if (dup->str)
      p->str = DupString(dup->str);
   if (dup->genstr)
      p->genstr = DupString(dup->genstr);
   if (dup->exflags)
      p->exflags = DupString(dup->exflags);
@ROUT r1read mvread
   if (dup->kname)
      p->kname = DupString(dup->kname);
@ROUT r1read mvread mmread
   p->next = NULL;
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of @up@(rt) structs */
static ATL_@(rt)node_t *Clone@up@(rt)Queue(ATL_@(rt)node_t *dupb)
{
   ATL_@(rt)node_t *p, *pd, *nb;
   if (!dupb)
      return(NULL);
   p = nb = Clone@up@(rt)Node(dupb);
   for (pd=dupb->next; pd; pd = pd->next)
   {
      p->next = Clone@up@(rt)Node(pd);
      p = p->next;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): clones a queue of strided @up@(rt) structs */
static ATL_@(rt)node_t *CloneStrided@up@(rt)Queue
(
   ATL_@(rt)node_t *dupb,   /* queue of nodes to clone */
   int stride               /* increment between nodes to take */
)
/*
 * Creates a queue of cloned nodes from dupb; move stride each time
 * (stride must be >= 1); i.e. skip stride-1 structs in original queue
 */
{
   ATL_@(rt)node_t *p, *pd, *nb;
   int i;

   if (!dupb)
      return(NULL);
   if (stride == 1)
      return(Clone@up@(rt)Queue(dupb));
   assert(stride > 1);
   p = nb = Clone@up@(rt)Node(dupb);
   pd = nb;
   while(pd)
   {
      for (i=0; i < stride && pd; i++, pd = pd->next);
      if (pd)
      {
         p->next = Clone@up@(rt)Node(pd);
         p = p->next;
      }
      else
         p->next = NULL;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)Node(ATL_@(rt)node_t *die)
{
   ATL_@(rt)node_t *p=NULL;
   if (die)
   {
      p = die->next;
      if (die->rout)
         free(die->rout);
      if (die->auth)
         free(die->auth);
      if (die->comp)
         free(die->comp);
      if (die->cflags)
         free(die->cflags);
      if (die->str)
         free(die->str);
      if (die->genstr)
         free(die->genstr);
      if (die->exflags)
         free(die->exflags);
@ROUT r1read mvread
      if (die->kname)
         free(die->kname);
@ROUT r1read mvread mmread
      free(die);
   }
   return(p);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): safely remove nukeme from Q, reseting all links */
static ATL_@(rt)node_t *Remove@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
/*
 * Removes nukeme from Q, sets nukeme->next=NULL, and returns updated Q
 */
{
   ATL_@(rt)node_t *p, *prev;

   if (!nukeme)
      return(Q);
   assert(Q);
   if (Q == nukeme)
   {
      Q = Q->next;
      nukeme->next = NULL;
      return(Q);
   }
   prev = Q;
   for (p=Q->next; p && p != nukeme; p = p->next)
      prev = p;
   assert(p);
   prev->next = nukeme->next;
   nukeme->next = NULL;
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Kill@up@(rt)NodeFromQ
(
   ATL_@(rt)node_t *Q,     /* queue of nodes */
   ATL_@(rt)node_t *nukeme /* node to remove from queue */
)
{
   Q = Remove@up@(rt)NodeFromQ(Q, nukeme);
   Kill@up@(rt)Node(nukeme);
   return(Q);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void KillAll@up@(rt)Nodes(ATL_@(rt)node_t *die)
{
   while (die)
      die = Kill@up@(rt)Node(die);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_SubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 *  Gets GOODGCC (from Make.inc), and substitutes it for all comp == "gcc"
 *  in the queue.  This gets us mandatory flags like -pg,-m64,etc.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, "gcc"))
      {
         free(kp->comp);
	 kp->comp = DupString(gcc);
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ATL_UnsubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make reverse sub in */
)
/*
 *  Gets GOODGCC (from Make.inc); Any comp string matching that is switched
 *  back to "gcc".  This is usually necessary so that output files don't
 *  use an old GOODGCC that lacks something like -pg.
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void ResubGoodGccIn@up@(rt)Nodes
(
   ATL_@(rt)node_t *bp   /* queue to make sub in */
)
/*
 * Takes gcc compiler that use GOODGCC, and replaces them with "gcc"
 * to help portability
 */
{
   ATL_@(rt)node_t *kp;  /* queue to make sub in */
   char *gcc;
   gcc = GetGoodGcc();
   for (kp=bp; kp; kp = kp->next)
   {
      if (kp->comp && !strcmp(kp->comp, gcc))
      {
         free(kp->comp);
	 kp->comp = DupString("gcc");
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_CountNumberOf@up@(rt)Nodes
(
    ATL_@(rt)node_t *bp   /* queue to count */
)
{
   int i;
   for (i=0; bp; i++, bp = bp->next);
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Last@up@(rt)Node(ATL_@(rt)node_t *bp)
/*
 * RETURNS: pointer to last node in queue
 */
{
   ATL_@(rt)node_t *p;
   if (!bp)
      return(NULL);
   for (p=bp; p->next; p = p->next);
   return(p);
}

@multidef cmp < >
@whiledef op Min Max
   @iexp ip @(ip) 1 +
/* procedure @(ip): finds @low@(op) integer at ip0 in struct */
static ATL_@(rt)node_t *Find@(op)IntIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0           /* ptr to integer withinin node bp */
)
/*
 * RETURNS: ptr to structure containing @low@(op) int value at byte offset 
 *          offset in struct
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   int val;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   mp = bp;
   ip = (int*)(((char*)bp) + offset);
   val = *ip;
   for (p=bp->next; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip @(cmp) val)
      {
         mp = p;
         val = *ip;
      }
   }
   return(mp);
}
   @undef cmp
@endwhile

@iexp ip @(ip) 1 +
/* procedure @(ip): finds first integer equal to val at ip0 in struct */
static ATL_@(rt)node_t *FindIntValIn@up@(rt)Q
(
   ATL_@(rt)node_t *bp,   /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node bp */
   int val             /* value being searched for */
)
/*
 * RETURNS: ptr to first structure containing value val at byte offset 
 *          offset in struct, or NULL if no such value found
 */
{
   ATL_@(rt)node_t *mp=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   for (p=bp; p; p = p->next)
   {
      ip = (int*)(((char*)p) + offset);
      if (*ip == val)
         return(p);
   }
   return(NULL);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): sorts Q from least-to-greatest on int val at ip0 in struc */
static ATL_@(rt)node_t *Sort@up@(rt)QByIntVal
(
   ATL_@(rt)node_t *bp,   /* queue to be sorted */
   void *ip0           /* ptr to integer withinin node bp to sort on*/
)
/*
 * RETURNS: possibly new queue base, sorted from least-to-greatest on int at ip0
 */
{
   ATL_@(rt)node_t *sb=NULL, *p;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   if (!bp)
      return(NULL);
   
   while(bp)
   {
      ip = (int*)(((char*)bp) + offset);
      p = FindMaxIntIn@up@(rt)Q(bp, ip);
      bp = Remove@up@(rt)NodeFromQ(bp, p);
      p->next = sb;
      sb = p;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): reverses order in Q */
static ATL_@(rt)node_t *Reverse@up@(rt)Q(ATL_@(rt)node_t *bp)
/*
 * RETURNS: new base ptr of reversed queue
 */
{
   ATL_@(rt)node_t *nb=NULL, *p;
   while(bp)
   {
      p = bp;
      bp = bp->next;
      p->next = nb;
      nb = p;
   }
   return(nb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip): places all nodes wt int value val at ip0 in new queue */
static ATL_@(rt)node_t *Yank@up@(rt)NodesByIntVal
(
   ATL_@(rt)node_t **bp0,  /* queue to be searched */
   void *ip0,          /* ptr to integer withinin node *bp */
   int val             /* value to be yanked out of original Q */
)
/*
 * Finds all nodes that have the integeral value val stored in position
 * ip0-bp0 in nodes.  These nodes are removed from bp0, and placed in
 * their own queue, which is returned.  bp0 is modified in the process.
 * RETURNS: ptr to queue of nodes wt integer value val
 */
{
   ATL_@(rt)node_t *bp=(*bp0), *p, *valb=NULL, *vp;
   int *ip;
   const int offset = (int)((char*)((char*) ip0) - ((char*)bp));

   while(bp)
   {
      p = FindIntValIn@up@(rt)Q(bp, (((char*)bp)+offset), val);  /* find node */
      if (!p)       /* if there are no more in bp, we are done */
         break;
      bp = Remove@up@(rt)NodeFromQ(bp, p);   /* remove it from original queue */
/*
 *    Add node at front of new value-only queue 
 */
      if (valb)
      {
         vp->next = p;
         vp = p;
      }
      else
         vp = valb = p;
   }
   *bp0 = bp;
   return(valb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_Sort@up@(rt)NodesByMflop
(
   int imf,            /* which mflop entry to sort on */
   ATL_@(rt)node_t *bp    /* queue to be sorted */
)
/* 
 * kills original queue, and returns a greatest-to-least sorted queue
 * on p->mflop[imf].  Does it with O(N^2) alg, but if this is a bottleneck,
 * we never get here because timing takes an eternity.
 */
{
   ATL_@(rt)node_t *p, *prev, *sb=NULL;   /* ptr, prev, sorted base */
   ATL_@(rt)node_t *minp;
   double mf;

/*
 * Sort from greatest-to-least by always adding smallest entry in old
 * list to head of greatest-to-least list
 */
   while (bp)
   {
/*
 *    Find slowest remaining kernel
 */
      mf = bp->mflop[imf];
      for (minp=prev=bp, p=bp->next; p; p = p->next)
      {
         if (p->mflop[imf] < mf)
         {
            minp = p;
            mf = p->mflop[imf];
         }
      }
/*
 *    Remove it from unsorted queue, and add as new head of sorted
 */
      if (minp == bp)
      {
         bp = bp->next;
         minp->next = sb;
      }
      else   /* in the middle of unsorted queue */
      {
         prev->next = minp->next;
         minp->next = sb;
      }
      sb = minp;
   }
   return(sb);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Parse@up@(rt)Line(char *ln)
/*
 * Given a line from a @(rt) index file (with multiple lines pasted together
 * into one line (ln), return a structure describing that line.
 */
{
   ATL_@(rt)node_t *p;
   char *sp;
   int itmp;
   char ch;

   p = Get@up@(rt)Node();

@ROUT r1read mvread
@whiledef kk ldamul
   sp = strstr(ln, "@up@(kk)=");
   if (sp)
      p->@(kk) = atoi(sp+@len@(kk)+1);
   else
      p->@(kk) = 0;

@endwhile
@ROUT mmread 
@whiledef jj mu nu ku kbmin kbmax fftch iftch nftch lat pref muladd
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;
@endwhile
@whiledef jj kb nb mb
   sp = strstr(ln, "@up@(jj)=");
   if (sp)
      p->@(jj)B = atoi(sp+@len@(jj)+1);
   else
      p->@(jj)B = 0;
@endwhile
   @multidef jj ID SSE
@ROUT mvread r1read 
   @multidef jj ID MU NU minN minM alignX alignY alignA SSE CacheElts rankR
@ROUT r1read mvread mmread
@whiledef jj
   sp = strstr(ln, "@(jj)=");
   if (sp)
      p->@(jj) = atoi(sp+@len@(jj)+1);
   else
      p->@(jj) = 0;

@endwhile
@ROUT mmread
@multidef fl 
   X87 LDCTOP MRUNTIME NRUNTIME KRUNTIME KUISKB LDISKB BETAN1 LDAB AOUTER
   LDFLOAT STFLOAT PFACOLS PFABLK PFBCOLS PFCELTS L14NB
@endmultidef

@ROUT mvread
@multidef fl X87 LDYTOP ALLALIGNXY AXPYBASED GEMMBASED CONJDEF FNU ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read
@multidef fl X87 ALLALIGNXY FNU INCYISONE ALIGNX2A ADDCFLAGS PFTUNABLE
@ROUT r1read mvread mmread
@whiledef fl
   sp = strstr(ln, "@(fl)=");
   if (sp)
   {
      if (atoi(sp+@len@(fl)+1))
         p->flag |= (1<<@up@(rt)F_@(fl));
      else
         p->flag &= ~(1<<@up@(rt)F_@(fl));
   }
@endwhile

   sp = strstr(ln, "MFLOP=");
   if (sp)
      GetDoubleArr(sp+6, 8, p->mflop);

   sp = strstr(ln, "ASM=");
   if (sp)
      p->asmbits = asmNames2bitfield(sp+4);


@ROUT mmread
@multidef TA TA TB
@ROUT mvread
@multidef TA TA 
@ROUT mvread mmread
@whiledef TA
   sp = strstr(ln, "@(TA)='");
   if (sp)
   {
      ch = tolower(sp[4]);
      if (ch == 'n')
         p->@(TA) = AtlasNoTrans;
      else if (ch == 'c')
         p->@(TA) = AtlasConjTrans;
      else if (ch == 't')
         p->@(TA) = AtlasTrans;
      else
         assert(0);
   }
@endwhile
@ROUT mvread r1read mmread
@skip   sp = strstr(ln, "MFLOP=");
@skip   if (sp) p->mflop = atof(sp+6);

@ROUT mvread r1read `@define kw @kname@`
@whiledef kw rout auth comp cflags
   sp = strstr(ln, "@up@(kw)='");
   if (sp)
      p->@(kw) = GetSingleQuoteString(sp+@len@(kw)+1);
   else
      p->@(kw) = NULL;

@endwhile
   return(p);
}

/* procedure 18 */
static void Print@up@(rt)Line(FILE *fpout, ATL_@(rt)node_t *np)
{
   int i, j, k;
   char ta, tb;

   if (!np)
      return;
   if (!np->rout)
      np->ID = 0;
@ROUT r1read
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley");
@ROUT mvread mmread
   if (np->TA == AtlasConjTrans) ta = 'C';
   else if (np->TA == AtlasTrans) ta = 'T';
   else ta = 'N';
@ROUT mvread
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c'",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta);
@ROUT mvread r1read
   if (np->kname)
      fprintf(fpout, " KNAME='%s' \\\n", np->kname);
   else
      fprintf(fpout, " \\\n");
@ROUT mmread
   if (np->TB == AtlasConjTrans) tb = 'C';
   else if (np->TB == AtlasTrans) tb = 'T';
   else tb = 'N';
   fprintf(fpout, "ID=%d ROUT='%s' AUTH='%s' TA='%c' TB='%c' \\\n",
           np->ID, np->rout ? np->rout : "generated", 
           np->auth ? np->auth : "R. Clint Whaley", ta, tb);

@ROUT mvread r1read mmread
   fprintf(fpout, "   ");
   i = 3;
@ROUT mvread r1read
@whiledef kw MU NU minN minM alignX alignY alignA SSE CacheElts rankR
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", np->@(kw));
@endwhile
@whiledef kw ldamul
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

@ROUT mmread 
@whiledef kw mu nu ku kbmin kbmax fftch iftch nftch lat pref muladd
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@up@(kw)=%d ", np->@(kw));
@endwhile

   @define kwd @@
   @multidef kw
      X87 LDCTOP MRUNTIME NRUNTIME KRUNTIME KUISKB LDISKB BETAN1 LDAB AOUTER
      LDFLOAT STFLOAT PFACOLS PFABLK PFBCOLS L14NB
   @endmultidef
@ROUT r1read 
   @define kwd @X87 INCYISONE FNU ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mvread 
   @define kwd @X87 FNU LDYTOP ALLALIGNXY AXPYBASED GEMMBASED ADDCFLAGS ALIGNX2A PFTUNABLE@
@ROUT mmread
@whiledef jj kb nb mb
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   if (np->@(jj)B != 0)
      i += fprintf(fpout, "@up@(jj)=%d ", np->@(jj)B);
@endwhile
@ROUT mvread r1read mmread
@whiledef kw @(kwd)
   if (i > 70) { fprintf(fpout, " \\\n   "); i = 3; }
   i += fprintf(fpout, "@(kw)=%d ", FLAG_IS_SET(np->flag, @up@(rt)F_@(kw)));
@endwhile

   if (np->mflop[0]+np->mflop[1]+np->mflop[2]+np->mflop[3]+np->mflop[4]+
       np->mflop[5]+np->mflop[6] != 0.0)
   {
      if (i > 3) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "MFLOP=%le", np->mflop[0]);
      for (j=7; j && np->mflop[j] == 0.0; j--);
      for (k=1; k <= j; k++)
         i += fprintf(fpout, ",%le", np->mflop[k]);
   }
   if (np->asmbits)
   {
      if (i > 40) { fprintf(fpout, " \\\n   "); i = 3; }
      for (j=0; !(np->asmbits & (1<<j)); j++);
      assert(j < NASMD);
      i += fprintf(fpout, "  ASM=%s", ASMNAM[j]);
      for (j++; j < NASMD; j++)
         if (np->asmbits & (1<<i))
            i += fprintf(fpout, ",%s", ASMNAM[j]);
   }
@whiledef kw comp cflags
   if (np->@(kw))
   {
      if (i+strlen(np->@(kw)) > 70) { fprintf(fpout, " \\\n   "); i = 3; }
      i += fprintf(fpout, "  @up@(kw)='%s'", np->@(kw));
   }
@endwhile
   if (i)
      fprintf(fpout, "\n");
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Print@up@(rt)Nodes(FILE *fpout, ATL_@(rt)node_t *bp)
{
   while (bp)
   {
      Print@up@(rt)Line(fpout, bp);
      bp = bp->next;
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)File(char *file, ATL_@(rt)node_t *nq)
{
   FILE *fpout;

   if (!file || !strcmp(file, "stdout"))
      fpout = stdout;
   else if (!strcmp(file, "stderr"))
      fpout = stderr;
   else
   {
      fpout = fopen(file, "w");
      assert(fpout);
   }
   Print@up@(rt)Nodes(fpout, nq);
   if (fpout != stdout && fpout != stderr)
      fclose(fpout);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void Write@up@(rt)FileWithPath
   (char pre, char *path, char *file, ATL_@(rt)node_t *nq)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   Write@up@(rt)File(ln, nq);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)File(char *file)
/*
 * Reads in a standard ATLAS parsable @up@(rt) index file, and returns a
 * list of all the kernels defined there.
 */
{
   ATL_@(rt)node_t *nq=NULL, *p;
   FILE *fpin;
   char *ln, *sp;
   int i, j, KeepOn, len;

   if (!file || !strcmp(file, "stdin"))
      fpin = stdin;
   else
      fpin = fopen(file, "r");
   if (!fpin)
      return(NULL);
   nq = p = Get@up@(rt)Node();
   while (ln = GetJoinedLines(fpin))
   {
      if (ln[0] != '#')
      {
         p->next = Parse@up@(rt)Line(ln);
         p = p->next;
      }
   }
   fclose(fpin);
   return(Kill@up@(rt)Node(nq));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *Read@up@(rt)FileWithPath
   (char pre, char *path, char *file)
{
   char ln[2048];
   sprintf(ln, "%s/%c%s", path, pre, file);
   return(Read@up@(rt)File(ln));
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelRepeated@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Deletes any repeated IDs
 */
{
   ATL_@(rt)node_t *prev, *p, *np;
   int ID;

   for (p=bp; p; p = p->next)
   {
      ID = p->ID;
      prev = p;
      do
      {
         for (np=p->next; np && np->ID != ID; np = np->next)
            prev = np;
         if (np)  /* found duplicate */
            prev->next = Kill@up@(rt)Node(np);
      }
      while (np);
   }
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *DelBadArch@up@(rt)Kernels(ATL_@(rt)node_t *bp)
/*
 * Weeds out kernels that require SSE/assembly that we haven't got
 */
{
   int asmb=0, die;
   ATL_@(rt)node_t *p, *prev;
@multidef sh          1         2        3        4          5        6       7
@whiledef asm GAS_x8632 GAS_x8664 GAS_SPARC GAS_PPC GAS_PARISC GAS_MIPS GAS_ARM
   #ifdef ATL_@(asm)
      asmb |= (1<<@(sh));
   #endif
   @undef sh
@endwhile

   prev = p = bp;
   while (p)
   {
      die = (p->asmbits) ? !(asmb & p->asmbits) : 0;
      #ifndef ATL_SSE3
         if (p->SSE)
         {
            die |= (p->SSE >= 3);
            #ifndef ATL_SSE2
               die |= (p->SSE >= 2);
            #endif
            #ifndef ATL_SSE1
               die |= (p->SSE >= 1);
            #endif
         }
      #endif
      if (die) 
      {
         if (p == bp) 
            bp = p = Kill@up@(rt)Node(p);
         else 
            prev->next = p = Kill@up@(rt)Node(p);
      }
      else
      {
         prev = p;
         p = p->next;
      }
   }
   return(bp);
}

@ROUT mvread r1read
#define MAXBASES 4
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int ATL_@up@(rt)SplitContexts
(
   ATL_@(rt)node_t *kb,   /* pointer to all read in kernels */
   ATL_@(rt)node_t **ocb, /* set to all out-of-cache kernels */
   ATL_@(rt)node_t **i2b, /* set to all in-L2 kernels */
   ATL_@(rt)node_t **i1b, /* set to all in-L1 kernels */
   ATL_@(rt)node_t **syb  /* NULL, or all SYR/SYR2 kernels (may not exist) */
)
/*
 *  Takes unified bp, and splits it into separate pieces.  bp is invalidated
 *  in the process (is split into child queues)
 *  RETURNS: number of children found
 */
{
   ATL_@(rt)node_t *kp, *kn;
   ATL_@(rt)node_t *bases[MAXBASES] = {NULL, NULL, NULL, NULL};
   int nbases;

/*
 * Kernels come as a series of kernels that are ranked by efficiency from
 * high to low based on the integer rankR.  All series must end with a
 * general kernel with no restrictions with a rankR of 0 (all non-zero
 * kernels have restrictions).  This loop splits these kernels into 
 * their seperate series (series indicates calling context).
 */
   kn = kb;
   nbases = 0;
   while (kn)
   {
      bases[nbases++] = kn;
      for (kp=kn; kp && kp->rankR; kp = kp->next);  /* find end of series */
      if (!kp)
         break;
      kn = kp->next;
      kp->next = NULL;
   }
   if (ocb)
      *ocb = bases[0];
   else
      KillAll@up@(rt)Nodes(bases[0]);
   if (i2b)
      *i2b = bases[1];
   else
      KillAll@up@(rt)Nodes(bases[1]);
   if (i1b)
      *i1b = bases[2];
   else
      KillAll@up@(rt)Nodes(bases[2]);
   if (syb)
      *syb = bases[3];
   else
      KillAll@up@(rt)Nodes(bases[3]);
   return(nbases);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *ATL_@up@(rt)LinkContexts
(
   ATL_@(rt)node_t *kp1, /* all out-of-cache kernels */
   ATL_@(rt)node_t *kp2, /* all in-L2 kernels */
   ATL_@(rt)node_t *kp3, /* all in-L1 kernels */
   ATL_@(rt)node_t *kp4  /* all SYR/SYR2 kernels */
)
/*
 *  Takes separate queue, and joins them into one long queue; if any
 *  is NULL, all remaining cases must also be NULL!
 *  Seperate queues are subsumed into returned queue
 */
{
   ATL_@(rt)node_t *kps[MAXBASES] = {kp1, kp2, kp3, kp4};
   ATL_@(rt)node_t *kp, *kprev;
   int i, j;

   for (i=0; i < MAXBASES-1; i++)
   {
      if (!kps[i])
      {
         for (j=i+1; j < MAXBASES; j++)
            assert(!kps[j]);
         return(kp1);
      }
      for (kp=kps[i]; kp->next; kp = kp->next);
      kp->next = kps[i+1];
   }
   return(kp1);
}
#undef MAXBASES

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_@(rt)node_t *FindFastest@up@(rt)Kernel
(  char pre,             /* precision prefix */
   ATL_@(rt)node_t *bp,  /* kernel queue */
   int imf,              /* which mflop entry to sort by */
   int RESTRICTOK        /* consider restricted kernel? */
)
/*
 * A RESTRICTed kernel is one that requires something that can't be fixed
 * by loop peeling or the like.  Examples include forcing lda to a given
 * multiple, or 16-byte alignment for double complex (can't peel 1/2 of
 * a complex number to make 8-byte aligned array 16).
 * RETURNS: pointer to node in bp that is fastest in context imf wt RESTRCT
 */
{
   double mf;
   ATL_@(rt)node_t *kp, *kmax=bp;
   int size, usize, RKERN;

   if (bp)
   {
      usize = (pre == 'c' || pre == 's') ? 4 : 8;
      if (pre == 'c' || pre == 'd') size = 8;
      else if (pre == 's') size = 4;
      else size = 16;
      mf = bp->mflop[imf];
      for (kp=bp->next; kp; kp = kp->next)
      {
         if (kp->mflop[imf] > mf)
         {
            RKERN = (pre == 'z' || pre == 'c') ? (kp->alignA > usize) : 0;
            RKERN = RKERN | (kp->ldamul > size);
            if (RESTRICTOK | !RKERN)
            {
               mf = kp->mflop[imf];
               kmax = kp;
            }
         }
      }
   }
   return(kmax);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)flag2size(int flag)
/*
 * RETURNS: size of type using precision/type bits in flag
 */
{
   int size;

   size = FLAG_IS_SET(flag, @up@(rt)F_SINGLE) ? 4 : 8;
   size *= FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 2 : 1;
   return(size);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char @up@(rt)flag2pre(int flag)
/*
 * RETURNS: correct precision/type prefix based on flag
 */
{
   char pre = 'd';
   if (FLAG_IS_SET(flag, @up@(rt)F_SINGLE))
      return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'c' : 's');
   return(FLAG_IS_SET(flag, @up@(rt)F_COMPLEX) ? 'z' : 'd');
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2@up@(rt)flag(char pre, int flag)
/*
 * RETURNS: flag modified to reflect type/precision indicated by pre
 */
{
   SET_FLAG(flag, @up@(rt)F_COMPLEX, (pre == 'c' || pre == 'z'));
   SET_FLAG(flag, @up@(rt)F_SINGLE, (pre == 'c' || pre == 's'));
   return(flag);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SetAll@up@(rt)TypeFlags(char pre, ATL_@(rt)node_t *bp)
{
   ATL_@(rt)node_t *p;
   for (p=bp; p; p = p->next)
      p->flag = pre2@up@(rt)flag(pre, p->flag);
}
@ROUT r1read

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void PutKernNameInStr(ATL_@(rt)node_t *r1B)
/*
 * Fills in the proper name for all kernels in r1->str
 */
{
   char ln[32] = {"ATL_dgerk_L0_restrict"};
   char pre;
   const int ipre=4, iL=11, irest=12;

   pre = @up@(rt)flag2pre(r1B->flag);
   ln[ipre] = pre;
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '2';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   ln[iL] = '1';
   r1B->str = DupString(ln);
   ln[irest] = '\0';
   r1B->next->str = DupString(ln);
   ln[irest] = '_';
   r1B = r1B->next->next;

   sprintf(ln, "ATL_%cgerk_L1b_restrict", pre);
   r1B->str = DupString(ln);
   ln[irest+1] = '\0';
   r1B->next->str = DupString(ln);
}

@beginskip
@iexp ip @(ip) 1 +
/* procedure @(ip) */
ATL_r1node_t *GetSortedUniqueR1Kerns
   (char pre, ATL_r1node_t *r1kerns, char **aliases)
/*
 * Takes the 8-length queue of rank-1 update kernels:
 *    First 2 are restricted and normal GER out-of-cache kernels
 *    next 2 are restricted & normal in-L2 GER kernels
 *    next 2 are restristed & normal in-L1 GERM kernels
 *    next 2 are restristed & normal out-of-cache, L1-blocked kernels
 *
 * ALIASES: a null-terminated list of string pointers, where pairs
 *          of strings give the correct aliasing: 1st entry is the
 *          routine to be aliased, 2nd is what it should be aliased to.
 *          Every kernel that uses the same actual routine as another
 *          in the 8-length queue is deleted, and a #define is used
 *          to call the appropriate kernel, to avoid unnecessary
 *          code size expansion.
 *          If ALIASES is NULL, then ALIASES is not accessed.
 *          ALIASES must be at least 15 pointers long.
 *
 * RETURNS: new queue with only the unique kernels left (unrestricted
 *          kernels appear first in list), and the p->str entry having
 *          the correct routine/file name.  
 * NOTE   : Leaves the original queue intact.
 */
{
   ATL_r1node_t *r1b, *r1p, *r1k, *r1prev;
   char *kern = "gerk";
   int i, ialias=0;
   char *suff[8] = {"_L0", "_L0_restrict", "_L2", "_L2_restrict",
                    "_L1", "_L1_restrict", "_L1b", "_L1b_restrict"};

@skip   kern = (pre == 'z' || pre == 'c') ? "geru" : "ger";
/*
 * Make sure all routines are present, and there are no extra
 */
  for (i=0, r1p = r1kerns; i < 8; i++, r1p=r1p->next)
     assert(r1p);
  assert(!r1p);
/* 
 * Build new queue with the "normal" kernels first
 */
   r1b = CloneR1Node(r1kerns->next);
   r1b->next = r1p = CloneR1Node(r1kerns);
   r1p->next = CloneR1Node(r1kerns->next->next->next);
   r1p->next->next =  CloneR1Node(r1kerns->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next);
   r1p = r1p->next->next;
   r1p->next = CloneR1Node(r1kerns->next->next->next->next->next->next->next);
   r1p->next->next = CloneR1Node(r1kerns->next->next->next->next->next->next);
   r1p->next->next->next = NULL;
/*
 * Label queue entries with proper kernel names
 */
   for (i=0,r1p = r1b; i < 8; i++, r1p = r1p->next)
   {
       r1p->str = malloc(32*sizeof(char));
       assert(r1p->str);
       sprintf(r1p->str, "ATL_%c%s%s", pre, kern, suff[i]);
   }
/* 
 * Add duplicated kernels to alias array, and then get rid of them from Q
 */
   r1prev = r1b;
   r1p = r1b->next;
   while (r1p)
   {
      for (r1k=r1b; r1k != r1p; r1k = r1k->next)
         if (r1k->ID == r1p->ID) break;
      if (r1k != r1p)  /* got duplicate */
      {
         if (aliases)
         {
            aliases[ialias++] = r1p->str;
            r1p->str = NULL;
            aliases[ialias++] = DupString(r1k->str);
         }
         r1prev->next = r1p = KillR1Node(r1p);
      }
      else
      {
        r1prev = r1p;
        r1p = r1p->next;
      }
   }
   if (aliases)
      aliases[ialias] = NULL;
   return(r1b);
}
@endskip
@ROUT mvread
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortByTrans
(
   ATL_@(rt)node_t *bp,    /* original kernels wt mixture of trans cases */
   ATL_@(rt)node_t **bN0,  /* No trans cases */
   ATL_@(rt)node_t **bT0,  /* trans cases */
   ATL_@(rt)node_t **bNC0, /* ConjNotrans cases */
   ATL_@(rt)node_t **bTC0  /* Conjtrans cases */
) 
/*
 * Sorts bp into the separate transpose queues, destroying bp in the process.
 * If a bp entry has the CONJDEF property, then its entry is duplicated to
 * put it on both queues (it can be used for normal and conjugate cases).
 */
{
   ATL_@(rt)node_t *bN=NULL, *bT=NULL, *bNC=NULL, *bTC=NULL,
                   *p, *next, *new;

   for (p=bp; p; p = next)
   {
      next = p->next;
      if (p->TA == AtlasNoTrans)
      {
         p->next = bN;
         bN = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConj;
               new->next = bNC;
               bNC = new;
            }
         #endif
      }
      else if (p->TA == AtlasTrans)
      {
         p->next = bT;
         bT = p;
         #ifdef TCPLX
            if (p->flag & (1<<@up@(rt)F_CONJDEF))
            {
               new = Clone@up@(rt)Node(p);
               new->TA = AtlasConjTrans;
               new->next = bTC;
               bTC = new;
            }
         #endif
      }
   #ifdef TCPLX
      else if (p->TA == AtlasConjTrans)
      {
         p->next = bTC;
         bTC = p;
      }
      else /* TA == AtlasConj */
      {
         p->next = bNC;
         bNC = p;
      }
   #endif
   }
   *bN0 = bN;
   *bT0 = bT;
   *bNC0 = bNC;
   *bTC0 = bTC;
}
@ROUT mvread r1read mmread
#endif  /* end atlas_@(rt)parse.h guard */
@ROUT atlas_mvtesttime.h
   @define rt @mv@
   @define ru @mv@
   @define at @mvt@
@ROUT atlas_r1testtime.h
   @define rt @r1@
   @define ru @r1@
   @define at @r1@
@ROUT atlas_r2testtime.h
   @define rt @r2@
   @define ru @r1@
   @define at @r2@
@ROUT atlas_mmtesttime.h
   @define rt @mm@
   @define ru @mm@
   @define at @mm@
@ROUT atlas_gentesttime.h
#ifndef ATLAS_GENTESTTIME_H
   #define ATLAS_GENTESTTIME_H

#include "atlas_fopen.h"

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int GetL1CacheSize()
{
   FILE *L1f;
   int L1Size;

   L1f = fopen("res/L1CacheSize", "r");
   if (!L1f)
   {
      assert(system("make res/L1CacheSize\n") == 0);
      L1f = fopen("res/L1CacheSize", "r");
   }
   assert(L1f != NULL);
   assert(fscanf(L1f, "%d", &L1Size) == 1);
   fclose(L1f);
   fprintf(stderr, "\n      Read in L1 Cache size as = %dKB.\n",L1Size);
   return(L1Size);
}

@ROUT mvres mmres atlas_gentesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int pre2size(char pre)
{
   int iret=8;
   if (pre == 's')
      iret = 4;
   else if (pre == 'z')
      iret = 16;
   return(iret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void SortDoubles(int N, double *d)
/* 
 * Sorts N-length array d from least to greatest using N^2 selection sort
 */
{
   double min;
   int imin, i, j;

   for (i=0; i < N-1; i++)
   {
      imin = i;
      min = d[i];
      for (j=i+1; j < N; j++)
      {
         if (d[j] < min)
         {
            imin = j;
            min = d[j];
         }
      }
      if (imin != i)
      {
         d[imin] = d[i];
         d[i] = min;
      }
   }
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static void *ReadResultsFile(int FULL, int nsample, char *resfile)
/*
 * Reads an ATLAS results file, which has the following form:
 *    <N> <walltime>   -> walltime of 0 means CPU timing was used
 *    sample1
 *    ....
 *    sampleN
 * RETURNS: NULL on error or if nsample > N, else if (FULL) it returns
 *          an array of form:  <N> <wall> <sample1> .... <sampleN>
 *          where samples have been sorted from least-to-greatest.
 *          where <N> is the number of samples.
 *          If (!FULL) then a pointer to the max value is returned for
 *          walltime, and a pointer to the median value is returned for
 *          for cputime.
 */
{
   static double dret;
   double *dres;
   FILE *fpin;
   char ln[1024];
   int i, n, wall, ierr;

   fpin = fopen(resfile, "r");
   if (!fpin)
      return(NULL);
   ierr = (fgets(ln, 1024, fpin) == NULL);
   if (ierr || sscanf(ln, " %d %d", &n, &wall) != 2)
   {
      fclose(fpin);
      return(NULL);
   }
   if (n < nsample)
   {
      fclose(fpin);
      return(NULL);
   }
   dres = malloc((n+2)*sizeof(double));
   assert(dres);
   dres[0] = n;
   dres[1] = wall;
   for (i=0; i < n; i++)
   {
      ierr = (fgets(ln, 1024, fpin) == NULL);
      if (ierr || sscanf(ln, " %le", dres+i+2) != 1)
      {
         fclose(fpin);
         return(NULL);
      }
   }
   fclose(fpin);
   SortDoubles(n, dres+2);
   if (FULL)
      return(dres);
   dret = (wall) ? dres[n+1] : dres[2+n/2];
   free(dres);
   return(&dret);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double PrintResultsFromFile(FILE *fpout, double *darr)
{
   const int N=darr[0], wall=(darr[1] != 0.0);
   double *dres=darr+2;
   double dret;
   int i;

   assert(N > 0);
   for (i=0; i < N; i++)
      fprintf(fpout, "   %le\n", dres[i]);
   if (wall)
   {
      fprintf(fpout, "MAX = %.2f\n", dres[N-1]);
      return(dres[N-1]);
   }
   else 
      fprintf(fpout, "MED = %.2f\n", dres[N/2]);
   return(dres[N/2]);
}

@ROUT atlas_gentesttime.h
#endif  /* end guard around atlas_gentesttime.h */
@ROUT atlas_mmtesttime.h atlas_r1testtime.h atlas_r2testtime.h @\
      atlas_mvtesttime.h
#ifndef ATLAS_@up@(rt)TESTTIME_H
   #define ATLAS_@up@(rt)TESTTIME_H

#include "atlas_@(ru)parse.h"
#include "atlas_gentesttime.h"

@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
static int SprintAlignStr
(
   char pre,            /* precision modifier */
   ATL_@(ru)node_t *kp, /* kernel pointer */
   char *str            /* (OUTPUT) string to print to */
)
/*
 * Prints alignment string to str, based on alignment setting.
 * This routine assumes to force the alignment to sizeof(TYPE) unless 
 * restrictions are enabled.
 * RETURNS: number of chars added to str
 */
{
   const int size = (pre == 'd' || pre == 's') ? pre2size(pre) 
                                                 : (pre2size(pre)>>1);
   int alignA, alignX, alignY, i;

   alignA = (kp->alignA) ? kp->alignA : size;
   alignX = (kp->alignX) ? kp->alignX : size;
   alignY = (kp->alignY) ? kp->alignY : size;
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;  /* ALIGNX2A overrides alignX */
@ROUT atlas_mvtesttime.h
@beginskip
   {
      if (kp->TA == AtlasNoTrans) /* ALIGNX2A affects Y for No-Trans */
         alignY = alignA; /* ALIGNX2A overrides alignY */
      else
         alignX = alignA; /* ALIGNX2A overrides alignX */
   }
@endskip
/*
 * If we are doing an AXPY-based No-Trans GEMV, it is Y, not X that must
 * be aligned to A.  Therefore, alignX/ALIGNX2A actually refer to Y, and
 * alignY refers to X.  Do this confusing transpose for the non-trans case.
 */
   if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
   {
      i = alignX;
      alignX = alignY;
      alignY = i;
      if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
         alignY = alignA; /* ALIGNX2A overrides alignY */
   }
   else if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
      alignX = alignA;
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
/*
 * If ALIGNX2A, we must force to vectors to have the same remainder when
 * divided by the vector length.  We do this by insisting they have the
 * the same modulo by ATL_Cachelen, which by definition is always a 
 * multiple of the vector length (eg, veclen=16/32 (SSE/AVX), ATL_cl=32). 
 */
   if (FLAG_IS_SET(kp->flag, @up@(ru)F_ALIGNX2A))
   {
      int myalign = ATL_Cachelen - size;
      if (alignA)
      {
         myalign = ((ATL_Cachelen-size)/alignA)*alignA;
         if (!myalign) 
            myalign = alignA;
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      if (myalign < ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                     myalign, ATL_Cachelen, myalign, ATL_Cachelen);
      else
         i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
@ROUT atlas_mvtesttime.h
      if (kp->TA == AtlasNoTrans) /* ALIGNX* affects Y for No-Trans */
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fy %d -Fy -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fy %d", myalign, myalign);
         if (2*alignX <= ATL_Cachelen)
            i += sprintf(str+i, " -Fx %d -Fx -%d\"", alignX, 2*alignX);
         else
            i += sprintf(str+i, " -Fx %d\"", alignX);
      }
      else
      {
         if (myalign < ATL_Cachelen)
            i = sprintf(str, " align=\"-Fa %d -Fa -%d -Fx %d -Fx -%d",
                        myalign, ATL_Cachelen, myalign, ATL_Cachelen);
         else
            i = sprintf(str, " align=\"-Fa %d -Fx %d", myalign, myalign);

         if (2*alignY <= ATL_Cachelen)
            i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
         else
            i += sprintf(str+i, " -Fy %d\"", alignY);
      }
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   }
   else
   {
      if (2*alignA <= ATL_Cachelen)
         i = sprintf(str, " align=\"-Fa %d -Fa -%d", alignA, 2*alignA);
      else
         i = sprintf(str, " align=\"-Fa %d ", alignA);
      if (2*alignX <= ATL_Cachelen)
         i += sprintf(str+i, " -Fx %d -Fx -%d", alignX, 2*alignX);
      else
         i += sprintf(str+i, " -Fx %d", alignX);
      if (2*alignY <= ATL_Cachelen)
         i += sprintf(str+i, " -Fy %d -Fy -%d\"", alignY, 2*alignY);
      else
         i += sprintf(str+i, " -Fy %d\"", alignY);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static int @up@(rt)KernelFailsTest
   (int verb, char pre, ATL_INT M, ATL_INT N, ATL_INT lda, ATL_@(ru)node_t *kn)
{
   char ln[4096];
   char *sp;
   int i, lda0;
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (kn->genstr)
   {
      i = sprintf(ln, "%s", kn->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", kn->genstr);
         if (verb < 3)
         {
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            i = system(ln);
         }
         remove(outnam);
         exit(-1);
      }
   }
   assert(kn->rout);
   assert (M >= kn->minM);
   assert (N >= kn->minN);
@ROUT atlas_mvtesttime.h
   sp = (kn->TA == AtlasNoTrans) ? "mvn" : "mvt";
   if (kn->TA == AtlasNoTrans)
      i = sprintf(ln, "make %cmvnktest mvnrout=%s", pre, kn->rout);
   else
      i = sprintf(ln, "make %cmvtktest mvtrout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   i = sprintf(ln, "make %c@(rt)ktest @(at)rout=%s", pre, kn->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, kn, ln+i);
   if (FLAG_IS_SET(kn->flag, @up@(ru)F_FNU))
       i += sprintf(ln+i, " Nt=%d ", (1008/kn->NU)*kn->NU);
   if (kn->exflags)
      i += sprintf(ln+i, " %s", kn->exflags);
   if (1)   /* NOTE: replace with test on restrict or not! */
      i += sprintf(ln+i, " incy=1");
   if (kn->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, kn->comp);
   if (kn->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, kn->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += sprintf(ln+i, " Mt=%d Nt=%d ldat=%d", M, N, lda);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else 
      i += sprintf(ln+i, "\n");
   if (verb > 1)
      fprintf(stdout, "system call:%s\n", ln);
   i = system(ln);
   if (verb)
   {
      if (i)
      {
         fprintf(stderr, "\n%s(ID=%d) FAILS TESTER!!\n", kn->rout,kn->ID);
         fprintf(stderr, "FAILING CALL: '%s'\n", ln);
         if (verb < 3 && verb > 0)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
      }
      else
         fprintf(stderr, "%s(ID=%d) *PASSES* TESTER!!\n", kn->rout,kn->ID);
   }
   if (verb < 3)
      remove(outnam);
   return(i);
}


@iexp ip @(ip) 1 +
/* procedure @(ip) */
static char *GetResIdStr(ATL_@(ru)node_t *r1p, ATL_INT M, ATL_INT N,
                         ATL_INT lda, ATL_INT percL1, int mflop)
{
/* 
 * Return filename suffix that disambiguates most kernels:
 * <ID><TA>_<M>x<N>_<lda>-<ldamul>_<MU>x<NU>_<percL1>_a<alignA>x<aX>x<aY>_<flag>
 */
   static char ln[512];
@ROUT atlas_mvtesttime.h
   sprintf(ln, "%d%c_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           (r1p->TA == AtlasNoTrans) ? 'N' : 'T', M, N, lda, r1p->ldamul,
            r1p->MU, r1p->NU, percL1, r1p->alignA, r1p->alignX, r1p->alignY, 
            r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   sprintf(ln, "%d_%dx%d_%d-%d_%dx%d_%d_a%dx%dx%d_%d", r1p->ID, 
           M, N, lda, r1p->ldamul, r1p->MU, r1p->NU, percL1, 
           r1p->alignA, r1p->alignX, r1p->alignY, r1p->flag);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   return(ln);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static double Time@up@(rt)Kernel
(int verb,              /* 0: no output, 1 min ouput, 2: full output */
 int FORCETIME,         /* if nonzero, ignore existing timing file */
                        /* if negative, don't retain timing file */
 ATL_@(ru)node_t *r1p,     /* ptr to kernel structure */
 char pre,              /* precision prefix */
 ATL_INT M, ATL_INT N,  /* dimensions to time */
 ATL_INT lda,           /* stride between row elements */
 ATL_INT percL1,        /* if 0, time kernel directly wt no blocking */
                        /* if non-zero, block for that % of L1 cache size */
 int nrep,              /* if >=1, # of trials, else use default (3) */
 int mflop,             /* force mflop flops in each timing interval */
 int cflush             /* if >= 0, size of cache flush area, else ignored */
)
{
   char ln[2048], resf[256], *sp;
   double *dp, mf;
   int i, align = pre2size(pre);
   static char outnam[L_tmpnam];
   static int FirstTime=1;

   if (FirstTime)
   {
      
      FirstTime = 0;
      assert(tmpnam(outnam));
   }
/*
 * If the file is generated, call generator to create it
 */
   if (r1p->genstr)
   {
      i = sprintf(ln, "%s", r1p->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > %s 2>&1\n", outnam);
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", r1p->genstr);
         if (verb < 3)
         {
            int itmp;
            fprintf(stderr, "\nOUTPUT OF system():\n");
            sprintf(ln, "cat %s 1>&2\n", outnam);
            itmp = system(ln);
         }
         exit(-1);
      }
   }

   if (r1p->minN)
      N = Mmax(N, r1p->minN);
   if (r1p->minM)
   {
      M = Mmax(M, r1p->minM);
      if (lda < M) 
         lda = M;
   }
   if (FLAG_IS_SET(r1p->flag, @up@(ru)F_FNU))
      N = Mmax(r1p->NU, (N/r1p->NU)*r1p->NU);
   i = r1p->ldamul / pre2size(pre);
   lda = (i) ? ((lda+i-1)/i)*i : lda;

   if (FORCETIME < 0)
      sprintf(resf, "res/%c@(rt)tmp", pre);
   else
      sprintf(resf, "res/%c@(rt)%s", pre, 
              GetResIdStr(r1p, M, N, lda, percL1, mflop));
   if (FORCETIME)
      remove(resf);
   dp = FORCETIME ? NULL : ReadResultsFile(0, nrep, resf);
   if (dp)
   {
      if (verb > 0)
         fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
                 r1p->ID, r1p->rout, M, N, lda, *dp);
      return(*dp);
   }

@ROUT atlas_mvtesttime.h
   sp = (r1p->TA == AtlasNoTrans || r1p->TA == AtlasConj) ? "mvn" : "mvt";
   if (percL1)
      i = sprintf(ln, "make %c%stime M=%d N=%d lda=%d l1mul=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, percL1, sp, r1p->rout);
   else
      i = sprintf(ln, "make %c%sktime M=%d N=%d lda=%d %srout=\"%s\"",
                  pre, sp, M, N, lda, sp, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
   if (percL1)
      i = sprintf(ln, "make %c@(rt)time M=%d N=%d lda=%d l1mul=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, percL1, r1p->rout);
   else
      i = sprintf(ln, "make %c@(rt)ktime M=%d N=%d lda=%d @(rt)rout=\"%s\"",
                  pre, M, N, lda, r1p->rout);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   if (r1p->flag)
      i += sprintf(ln+i, " iflag=%d", r1p->flag);
   if (r1p->exflags)
      i += sprintf(ln+i, " %s", r1p->exflags);
   if (r1p->comp)
      i += sprintf(ln+i, " %c@up@(rt)CC=\"%s\"", pre, r1p->comp);
   if (r1p->cflags)
@ROUT atlas_mvtesttime.h
      i += sprintf(ln+i, " %c@up@(rt)FLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i += sprintf(ln+i, " %c@up@(rt)CFLAGS=\"%s\"", pre, r1p->cflags);
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
   i += SprintAlignStr(pre, r1p, ln+i);
   if (cflush >=0)
      i += sprintf(ln+i, " flushKB=%d", cflush);
   i += sprintf(ln+i, " tflags=\"-f %s", resf);
   if (nrep > 0)
      i += sprintf(ln+i, " -# %d", nrep);

   if (mflop >= 0)
      i += sprintf(ln+i, " -F %d", mflop);
   i += sprintf(ln+i, "\"");
   i += sprintf(ln+i, " mu=%d nu=%d", r1p->MU, r1p->NU);
   if (verb < 3)
      i += sprintf(ln+i, " > %s 2>&1\n", outnam);
   else
      i += sprintf(ln+i, "\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "\nERROR %d, LINE %d OF %s\n", i, __LINE__, __FILE__);
      fprintf(stderr, "SYSTEM CALL FAILED: %s\n", ln);
      if (verb < 3)
      {
         int itmp;
         fprintf(stderr, "\nOUTPUT OF system():\n");
         sprintf(ln, "cat %s 1>&2\n", outnam);
         itmp = system(ln);
         remove(outnam);
      }
      exit(-1);
   }
   if (verb < 3)
      remove(outnam);
   if (verb > 1)
   {
      dp = ReadResultsFile(1, nrep, resf);
      mf = PrintResultsFromFile(stdout, dp);
      free(dp);
      dp = &mf;
   }
   else
      dp = ReadResultsFile(0, nrep, resf);
   assert(dp);
   if (verb == 1)
      fprintf(stdout, "   %d:%s (M=%d, N=%d, lda=%d) gets %.2f MFLOPS\n", 
              r1p->ID, r1p->rout, M, N, lda, *dp);
   return(*dp);
}
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h

static void FillIn@up@(rt)ExtractGenStrings(char pre, ATL_@(ru)node_t *kb)
/*
 * Creates generator strings to match kb settings
 */
{
   char ln[4096], *suff;
   int i, CL=8, mu;
   if (pre != 'd' && pre != 'c')
      CL = (pre == 'z') ? 4 : 16;
   while(kb)
   {
      if (kb->ID < 900000 || kb->ID >= 1000000) 
      {
         kb = kb->next;
         continue;
      }
      if (kb->asmbits == asmNames2bitfield("GAS_x8664"))
      {
         assert(kb->MU%CL == 0);
         suff = "sse";
         mu = kb->MU/CL;
      }
      else
      {
         mu = kb->MU;
         if (kb->SSE)
            suff = "Csse";
         else
            suff = "C";
      }
@ROUT atlas_mvtesttime.h
      if (kb->TA == AtlasNoTrans)
         i = sprintf(ln, "make %cmvnext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
      else
         i = sprintf(ln, "make %cmvtext_%s order=clmajor mu=%d nu=%d", pre, 
                     suff, mu, kb->NU);
@ROUT atlas_r1testtime.h atlas_r2testtime.h
      i = sprintf(ln, "make %c@(rt)ext_%s order=clmajor mu=%d nu=%d", pre, 
                  suff, mu, kb->NU);
@ROUT atlas_mvtesttime.h atlas_r1testtime.h atlas_r2testtime.h
      if (kb->alignA && kb->alignA%16==0 && kb->ldamul && kb->ldamul%16==0)
         i += sprintf(ln+i, " genflags=\"-def ALIGNED 1\"");
         
      if (kb->genstr)
         free(kb->genstr);
      kb->genstr = DupString(ln);
      kb = kb->next;
   }
}
@ROUT atlas_r1testtime.h atlas_r2testtime.h atlas_mvtesttime.h
#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT atlas_mmtesttime.h
@iexp ip @(ip) 1 +
/* procedure @(ip) */
int MMKernelFailsTest
(
   char pre,                    /* precision/type prefix */
   int mb, int nb, int kb,      /* dimensions to test */
   int beta,                    /* beta case to test */
   ATL_mmnode_t *umm            /* mmkern ptr */
)
/*
 * RETURNS: 0 on success, non-zero on failure
 */
{
   char ln[4096];
   int i, lda, ldb, ldc;
   char ch;

/*
 * If the file is generated, call generator to create it
 */
   if (umm->genstr)
   {
      if (system(umm->genstr))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", umm->genstr);
         exit(-1);
      }
   }
   ldc = mb*2+4;
   if (FLAG_IS_SET(umm->flag, MMF_LDISKB))
      lda = ldb = kb;
   else if (FLAG_IS_SET(umm->flag, MMF_LDAB))
      lda = ldb = kb+8;
   else
   {
      lda = kb+8;
      ldb = kb+16;
   }
   if (pre == 'c' || pre == 'z')
      i = sprintf(ln, "make cmmutstcase mmrout=%s csC=2 ", umm->rout);
   else
      i = sprintf(ln, "make mmutstcase mmrout=%s ", umm->rout);
   if (umm->comp)
   {
      ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
      i += sprintf(ln+i, "%cMC=\"%s\" %cMCFLAGS=\"%s\" ",
                   ch, umm->comp, ch, umm->cflags);
   }
   i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d ",
                pre, mb, nb, kb, 
                FLAG_IS_SET(umm->flag, MMF_MRUNTIME) ? 0 : mb, 
                FLAG_IS_SET(umm->flag, MMF_NRUNTIME) ? 0 : nb, 
                FLAG_IS_SET(umm->flag, MMF_KRUNTIME) ? 0 : kb);
   i += sprintf(ln+i, "lda=%d ldb=%d ldc=%d", lda, ldb, ldc);
   i += sprintf(ln+i, " > /dev/null 2>&1\n");
   i = system(ln);
   if (i)
   {
      fprintf(stderr, "%d of %s: FAILED COMMAND : %s\n",__LINE__,__FILE__,ln);
      if (umm->genstr)
         fprintf(stderr, "   genstr was = '%s'\n", umm->genstr);
   }
   return(i);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
static ATL_mmnode_t *DelBadMMKernels(char pre, int verb, ATL_mmnode_t *bp)
/*
 * Deletes all kernels that can't pass basic usage test
 * RETURNS: modifed bp queue wt failing kernels removed
 */
{
   ATL_mmnode_t *p, *prev;
   int die;

   if (verb > 0)
       printf("\nBEGIN BASIC MATMUL KERNEL TESTS:\n");

   prev = p = bp;
   while (p)
   {
      if (MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 0, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 1, p) ||
          MMKernelFailsTest(pre, p->mbB, p->nbB, p->kbB, 2, p))
      {
         if (verb > 0)
            printf("   NUKING bad kernel %s(%d)\n", p->rout, p->ID);
         if (p == bp)
            bp = p = KillMMNode(p);
         else
            prev->next = p = KillMMNode(p);
      }
      else
      {
         if (verb > 0)
            printf("   Kernel %s(%d) passes basic tests\n", p->rout, p->ID);
         prev = p;
         p = p->next;
      }
   }
   printf("DONE BASIC KERNEL TESTS.\n\n");
   return(bp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
char *GetGmmGenString
(
   int verb,                    /* verbosity */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf                       /* prefetch strategy */
)
/*
 * returns a string that will result in generating a user-style kernel
 * specialized for non-cleanup cases by invoking a make target that
 * in turn invokes the scalar generator routine, emit_mm.c
 * Because it is specialized for kernel cases, we don't specify leading
 * dimensions, transpose cases, etc, but just take the defaults.
 */
{
   char ln[4096];
   int i;

   if (!LDTOP)
      pf |= 512;
   i = sprintf(ln, "make mmgencase pre=%c muladd=%d lat=%d beta=%d mb=%d nb=%d kb=%d mu=%d nu=%d ku=%d if=%d nf=%d ff=%d, pfA=%d, csC=%d",
               pre, MACC, lat, beta, nb, nb, nb, mu, nu, ku, iftch, nftch, 
               Fftch, pf, (pre == 'c' || pre == 'z') ? 2 : 1);
   if (verb < 3)
      i += sprintf(ln+i, " > /dev/null 2>&1");
   else
      i += sprintf(ln+i, "\n");
   if (verb > 2)
      printf("genstr='%s'\n", ln);
   return(DupString(ln));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void FillInGMMNode(int verb, ATL_mmnode_t *mmp, char pre, int MACC, int lat, 
                   int beta, int nb, int mu, int nu, int ku, 
                   int fftch, int iftch, int nftch, int LDTOP, int pf)
/*
 * Take emit_mm's flags and fill in the standard ATL_mmnode_t struct mmp
 * making all the correct assumptions for the standard copy code
 */
{
   int i;

   if (ku > (nb>>1))
      ku = nb;
   mmp->mbB = mmp->nbB = mmp->kbB = nb;
   mmp->mu = mu;
   mmp->nu = nu;
   mmp->ku = ku;
   mmp->muladd = MACC;
   mmp->lat = lat;
   mmp->fftch = fftch;
   mmp->iftch = iftch;
   mmp->nftch = nftch;
   mmp->pref = pf;
   mmp->SSE = 0;
   mmp->TA = AtlasTrans;
   mmp->TB = AtlasNoTrans;
   mmp->asmbits = 0;
   if (mmp->auth)
      free(mmp->auth);
   if (mmp->rout)
      free(mmp->rout);
   if (mmp->comp)
      free(mmp->comp);
   if (mmp->cflags)
      free(mmp->cflags);
   if (mmp->str)
      free(mmp->str);
   if (mmp->genstr)
      free(mmp->genstr);
   mmp->comp = mmp->cflags = mmp->str = NULL;
   mmp->rout = DupString("dgmm.c");
   mmp->rout[0] = pre;
   mmp->genstr = GetGmmGenString(verb, pre, MACC, lat, beta, nb, mu, nu, ku, 
                                 fftch, iftch, nftch, LDTOP, pf);
   mmp->auth = DupString("Whaley/emit_mm");
   i = 0;
   SET_FLAG(i, MMF_KUISKB, (ku == nb));
   SET_FLAG(i, MMF_LDISKB, 1);
   SET_FLAG(i, MMF_LDAB, 1);
   if (pre == 's' || pre == 'c')
      SET_FLAG(i, MMF_SINGLE, 1);
   if (pre == 'c' || pre == 'z')
      SET_FLAG(i, MMF_COMPLEX, 1);
   mmp->flag = i;
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeGMMKernel            /* times kernels generated by emit_mm */
(
   int verb,                    /* verbosity */
   int FORCETIME,               /* 1: ignore any prior output file */
   char pre,                    /* precision */
   int MACC,                    /* 0 : separate mult&add, else MACC */
   int lat,                     /* multiply latency */
   int beta,                    /* 0,1 beta, else beta=X */
   int nb,                      /* blocking factor */
   int mu, int nu, int ku,      /* unrolling factors */
   int Fftch,                   /* do bogus fetch of C at top of loop? */
   int iftch,                   /* # of initial fetches to do */
   int nftch,                   /* # of fetches to do thereafter */
   int LDTOP,                   /* 1: load C at top, 0: at bottom */
   int pf,                      /* prefetch strategy */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   int i;
   char *bet;
   FILE *fp;
   double *dp;
   char fnam[256];
   char ln[4096];

   if (beta == 1)
      bet = "_b1";
   else if (beta == 0)
      bet = "_b0";
   else if (beta == -1)
      bet = "_bn1";
   else
      bet = "_bX";
   if (!LDTOP)
      pf |= 512;
   if (ku > nb/2)
      ku = nb;
   else if (ku == -1)
      ku = nb;
   sprintf(fnam,
           "res/%c%smm%c%c%d_%dx%dx%d_%dx%dx%d_%dx%dx%d%s%s_%dx%d_%d_pf%d_cf%d",
            pre, "JIK", 'T', 'N', nb, nb, nb, nb, nb, nb, 0, mu, nu, ku,
            "_a1", bet, MACC, lat, 1, pf, cflush);
   dp = (FORCETIME) ? NULL : ReadResultsFile(0, 0, fnam);
   if (!dp)
   {
      i = sprintf(ln, "make mmcase pre=%c loopO=JIK ta=T tb=N mb=%d nb=%d kb=%d lda=%d ldb=%d ldc=%d mu=%d nu=%d ku=%d alpha=1 beta=%d muladd=%d lat=%d cleanup=1 pfA=%d casnam=\"%s\"",
                  pre, nb, nb, nb, nb, nb, 0, mu, nu, ku, beta, MACC, lat, pf,
                  fnam);
      if (pre == 'c' || pre == 'z')
         i += sprintf(ln+i, " csA=1 csB=1 csC=2");
       
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
      dp = ReadResultsFile(0, 0, fnam);
   }
   assert(dp);
   return(*dp);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
double TimeMMKernel
(
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmp,           /* ptr to mmkern struct */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int mb, int nb, int kb,      /* dimensions to time */
   int lda,                     /* >0: lda to use, else kb */
   int ldb,                     /* >0: ldb to use, else kb */
   int ldc,                     /* >0: ldc to use, else mb+8 */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   char fnam[128], ln[2048];
   const char *LO = FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "IJK": "JIK";
   char *be;
   int i, j;
   char ch;
   double *dp;
/*
 * If it's a emit_mm generated file w/o the genstring, create the genstring
 * assuming it is a mmK
 */
   if (mmp->ID == 0 && !mmp->genstr && mmp->iftch > 0)
      mmp->genstr = GetGmmGenString(verb, pre, mmp->muladd, mmp->lat, beta, nb,
                                    mmp->mu, mmp->nu, mmp->ku,
                                    mmp->fftch, mmp->iftch, mmp->nftch, 
                                    FLAG_IS_SET(mmp->flag, MMF_LDCTOP), 
                                    mmp->pref);

   if (FLAG_IS_SET(mmp->flag, MMF_LDISKB))
      lda = ldb = kb;
   else
   {
      if (lda < 1)
         lda = kb;
      if (ldb < 1)
         ldb = kb;
      if (ldc < 1)
         ldc = mb + 8;
   }
   if (FLAG_IS_SET(mmp->flag, MMF_LDAB))
      ldb = lda;
/*
 * If the file is generated, call generator to create it
 */
   if (mmp->genstr)
   {
      i = sprintf(ln, "%s", mmp->genstr);
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      if (system(ln))
      {
         fprintf(stderr, "ERROR, LINE %d of %s\n", __LINE__, __FILE__);
         fprintf(stderr, "UNABLE TO GENERATE WITH COMMAND: %s\n", mmp->genstr);
         exit(-1);
      }
   }

   if (beta == 0)
      be = "b0";
   else if (beta == 1)
      be = "b1";
   else if (beta == -1)
      be = "bn1";
   else 
      be = "bX";
/*   dmm%d_TNMBxNBxKB_muxnuxku_ldc_rtMxrtNxrtK_LDTOP_pf_a1_bX_flushKB */
   sprintf(fnam, "res/%cmm%s%d_%c%c%dx%dx%d_%dx%dx%d_%d_%dx%dx%d_%d_%d_a1_%s_%d",
           pre, FLAG_IS_SET(mmp->flag, MMF_AOUTER) ? "MNK" : "NMK",
           mmp->ID, 'T', 'N', mb, nb, kb, mmp->mu, mmp->nu, mmp->ku, ldc, 
           FLAG_IS_SET(mmp->flag, MMF_MRUNTIME), 
           FLAG_IS_SET(mmp->flag, MMF_NRUNTIME), 
           FLAG_IS_SET(mmp->flag, MMF_KRUNTIME), 
           FLAG_IS_SET(mmp->flag, MMF_LDCTOP), mmp->pref, be, cflush);

   if (FORCETIME || !FileExists(fnam))
   {
      if (pre == 'c' || pre == 'z')
         i = sprintf(ln, "make cmmucase mmrout=%s csC=2 ", mmp->rout);
      else i = sprintf(ln, "make mmucaseN mmrout=%s ", mmp->rout);
      if (mmp->cflags)
      {
         ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
         i += sprintf(ln+i, "%cMCFLAGS=\"%s\" ", ch, mmp->cflags);
      }
      if (mmp->comp)
      {
         ch = (pre == 'c' || pre == 's') ? 'S' : 'D';
         i += sprintf(ln+i, "%cMC=\"%s\" ", ch, mmp->comp);
      }
      if (mmp->exflags)
         i += sprintf(ln+i, " %s ", mmp->exflags);
         
      if (!cflush)
         i += sprintf(ln+i, "moves=\"\" ");
         
@skip      i += sprintf(ln+i, "moves=\"-DMoveA -DMoveC\" ");
      i += sprintf(ln+i, "casnam=%s ", fnam);
      i += sprintf(ln+i, "pre=%c M=%d N=%d K=%d mb=%d nb=%d kb=%d ",
                   pre, mb, nb, kb, 
                   FLAG_IS_SET(mmp->flag, MMF_MRUNTIME) ? 0:mb,
                   FLAG_IS_SET(mmp->flag, MMF_NRUNTIME) ? 0:nb,
                   FLAG_IS_SET(mmp->flag, MMF_KRUNTIME) ? 0:kb);
      i += sprintf(ln+i, "mu=%d nu=%d ku=%d lda=%d ldb=%d ldc=%d beta=%d",
                   mmp->mu, mmp->nu, mmp->ku, lda, ldb, ldc, beta);
      if (verb < 3)
         i += sprintf(ln+i, " > /dev/null 2>&1\n");
      else
         i += sprintf(ln+i, "\n");
      if (verb > 1)
         fprintf(stdout, "SYSTEM: %s", ln);
      if (system(ln))
      {
         fprintf(stderr, "ERROR IN COMMAND: %s", ln);
         fprintf(stderr, "   PROPOSED FILENAME: %s\n", fnam);
         if (mmp->genstr)
            fprintf(stderr, "   GENSTR='%s'\n", mmp->genstr);
         sprintf(ln, "rm -f %s\n", fnam);
         assert(!system(ln));
         exit(-1);
      }
   }
   dp = ReadResultsFile(0, 0, fnam);
   if (!dp)
   {
      fprintf(stderr, "\nEmpty file '%s'!\n", fnam);
      fprintf(stderr, "From command: '%s'\n", ln);
      exit(-1);
   }
   return(*((double*)ReadResultsFile(0, 0, fnam)));
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
void TimeAllMMKernels
(
   int itime,                   /* index of mflop array to set */
   int verb,                    /* 0: no output, 1 min output, 2: full output */
   int FORCETIME,               /* 1: ignore any prior output file */
   ATL_mmnode_t *mmb,           /* ptr to mmkern struct queue */
   char pre,                    /* type/prec prefix: z,c,d,s */
   int lda,                     /* >0: lda to use, else kb */
   int ldb,                     /* >0: ldb to use, else kb */
   int ldc,                     /* >0: ldc to use, else mb+8 */
   int beta,                    /* beta to time */
   int mflop,                   /* >0: force mflop MFLOPs in each time interv */
   int cflush                   /* >0: size of cache flush, else ignored */
)
{
   ATL_mmnode_t *mmp;
   for (mmp=mmb; mmp; mmp = mmp->next)
      mmp->mflop[itime] = TimeMMKernel(verb, FORCETIME, mmp, pre, 
                                       mmp->mbB, mmp->nbB, mmp->kbB,
                                       (lda >= 0) ? lda : mmp->kbB, 
                                       (ldb >= 0) ? ldb : mmp->kbB, 
                                       (ldc >= 0) ? ldc : mmp->mbB+8, 
                                       beta, mflop, cflush);
}
#endif  /* end guard around atlas_@(rt)testtime.h */
@ROUT getflagarrs

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *GetIntList1(int ival)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival
 */
{
   int *iarr;
   iarr = malloc(2*sizeof(int));
   ATL_assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival;
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
TYPE *GetTypeList1(const SCALAR val)
/*
 * Returns a TYPE array with arr[0] = 1.0, arr[1] = val
 */
{
   TYPE *arr;
   arr = malloc(ATL_MulBySize(2));
   ATL_assert(arr);
   arr[0] = 1;
   #ifdef TCPLX
      arr[2] = *val;
      arr[3] = val[1];
   #else
      arr[1] = val;
   #endif
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *GetIntList2(int ival1, int ival2)
/*
 * returns integer array with iarr[0] = 1, iarr[1] = ival1, ival[2] = ival2
 */
{
   int *iarr;
   iarr = malloc(3*sizeof(int));
   ATL_assert(iarr);
   iarr[0] = 1;
   iarr[1] = ival1;
   iarr[2] = ival2;
   return(iarr);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *DupIntList(int *list)
/*
 * Duplicates list of integers, list[0] holds the length, not including 0
 */
{
   int i, n, *ip;

   assert(list);
   n = list[0] + 1;
   ip = malloc(sizeof(int)*n);
   assert(ip);
   for (i=0; i < n; i++)
      ip[i] = list[i];
   return(ip);
}

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *GetIntList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of integers, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atoi(args[i])
 */
{
   int n, *iarr, k;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   ATL_assert(n > 0);
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);
   
   iarr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      iarr[k+1] = atoi(args[i]);
   }
   return(iarr);
}

#ifdef TYPE
@iexp ip @(ip) 1 +
/* procedure @(ip) */
TYPE *GetTypeList(int nargs, char **args, int i, int nmul)
/*
 * Gets a list of TYPEs, whose length is given by atoi(args[i])*nmul
 * list is this length+1, since 0'th location gets atof(args[i])
 */
{
   int n, k;
   TYPE *arr;

   if (++i >= nargs)
      PrintUsage(args[0], i, NULL);
   n = atoi(args[i]) * nmul;
   ATL_assert(n > 0);
   arr = malloc(ATL_MulBySize(n+1));
   ATL_assert(arr);
   
   arr[0] = n / nmul;
   for (k=0; k < n; k++)
   {
      if (++i >= nargs)
         PrintUsage(args[0], i, NULL);
      arr[k+(1 SHIFT)] = atof(args[i]);
   }
   return(arr);
}
#endif

@iexp ip @(ip) 1 +
/* procedure @(ip) */
int *IntRange2IntList(int N0, int NN, int incN)
{
   int i, n;
   int *iarr;

   for (i=N0, n=0; i <= NN; i += incN) n++;
   iarr = malloc(sizeof(int)*(n+1));
   ATL_assert(iarr);
   iarr[0] = n;
   for (i=N0, n=1 ; i <= NN; i += incN, n++)
      iarr[n] = i;
   return(iarr);
}
@ROUT atlas_service.h
#ifndef ATLAS_SERVICE_H
   #define ATLAS_SERVICE_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#ifdef __GNUC__
/*
 * This routine overrides system tmpnam when compiling with GNU, which
 * issues an unkillable warning whenever you use this standard ANSI C
 * routine, telling you to use a non-standard routine instead.  If we
 * are being compiled by gnu gcc, use the non-standard routine in order to shut
 * the warnings up.  Here we hope they won't stop supporting a routine
 * that they force you to use.
 */
#ifdef L_tmpnam
  #undef L_tmpnam
#endif
#define L_tmpnam 16
static char *ATL_tmpnam(char *s)
/*
 * Works like ISO standard C's tmpnam: returns a ptr to a safe temporary
 * filename.  If s is NULL, the return pointer points at a static string
 * that is overwritten on the next call.  If s is non-NULL, return it,
 * and write string to user-controlled buffer s.
 * NOTE: this routine is not thread safe if you pass NULL.
 */
{
   static char *buff=NULL;
   char *sp;
   int n, i;
   
   sp = tempnam(NULL, "attmp");
   assert(sp);
   if (s)
   {
      strcpy(s, sp);
      free(sp);
      return(s);
   }
   if (buff)
      free(buff);
   n = strlen(sp) + 1;
   buff = malloc(sizeof(char)*i);
   strcpy(buff, sp);
   free(sp);
   return(buff);
}
   #define tmpnam ATL_tmpnam
#else
   #define ATL_tmpnam tmpnam
#endif

#endif
@ROUT atlas_tvec.h
#ifndef ATL_TVEC_H
   #define ATL_TVEC_H

#include "atlas_genparse.h"

typedef struct ATL_TVEC ATL_tvec_t;
struct ATL_TVEC
{
   void *vp;            /* pointer to vector, type in pre */
   char *name;          /* name of vector (eg, "MFLOP" or "N") */
   ATL_tvec_t *next;
   int  N;              /* # of elements in vector (inclucing reps) */
   int nrep;            /* # of repititions in timings */
   char pre;            /* double (d), string (s), char (c), integer (i) */
};

ATL_tvec_t *ATL_GetTvec(char *name, int N, int nrep, char pre)
{
   ATL_tvec_t *tp;
   int i;

   tp = malloc(sizeof(ATL_tvec_t));
   i = strlen(name);

   tp->name = malloc(sizeof(char)*(strlen(name)+1));
   strcpy(tp->name, name);
   tp->N = N;
   tp->nrep = nrep;
   tp->next = NULL;
   tp->pre = pre;
   i = N;
   if (pre == 's')
      i *= sizeof(char*);
   else if (pre == 'd')
      i *= sizeof(double);
   else 
      i *= (pre == 'i') ? sizeof(int) : sizeof(char);
   tp->vp = malloc(N*sizeof(double));
   assert(tp->vp);
   return(tp);
}

ATL_tvec_t *ATL_KillThisTvec(ATL_tvec_t *tp)
{
   ATL_tvec_t *retp=NULL;

   if (tp)
   {
      if (tp->pre == 's')
      {
         char **sp = tp->vp;
         int i;

         for (i=0; i < tp->N; i++)
            free(sp[i]);
         free(sp);
      }
      else
         free(tp->vp);
      free(tp->name);
      retp = tp->next;
      free(tp);
   }
   return(retp);
}

void ATL_KillAllTvecs(ATL_tvec_t *tq)
{
   while (tq)
      tq = ATL_KillThisTvec(tq);
}

void ATL_ReadDoubleTvec(FILE *fpin, int N, double *dp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%lf\n", dp+i) == 1);
}

void ATL_ReadIntTvec(FILE *fpin, int N, int *ip)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%d\n", ip+i) == 1);
}

void ATL_ReadCharTvec(FILE *fpin, int N, char *cp)
{
   int i;

   for (i=0; i < N; i++)
      assert(fscanf(fpin, "%c\n", cp+i) == 1);
}

void ATL_ReadStringTvec(FILE *fpin, int N, char **sa)
{
   int i;

   for (i=0; i < N; i++)
   {
      char *sp;
      int n, j;
      char ln[512];

      assert(fgets(ln, 512, fpin));
      n = strlen(ln) + 1;
      sa[i] = sp = malloc(sizeof(char)*n);
      assert(sp);
      for (j=0; j < n; j++)
         sp[j] = ln[j];
   }
}

ATL_tvec_t *ATL_ReadTvec(FILE *fpin, int nrep)
{
   int N;
   char nm[64], pre;
   ATL_tvec_t *tp;

   assert(fscanf(fpin, "%s\n", nm) == 1);
   assert(fscanf(fpin, "%d %c", &N, &pre) == 2);
   tp = ATL_GetTvec(nm, N, nrep, pre);
   if (pre == 'd')
     ATL_ReadDoubleTvec(fpin, N, tp->vp);
   else if (pre == 'i')
     ATL_ReadIntTvec(fpin, N, tp->vp);
   else if (pre == 'c')
     ATL_ReadCharTvec(fpin, N, tp->vp);
   else /* if (pre == 's') */
     ATL_ReadStringTvec(fpin, N, tp->vp);
   return(tp);
}

ATL_tvec_t *ATL_ReadTvecFile(FILE *fpin, char **cmnt, int *nvec, int *nrep)
/*
 * Reads an entire timing vector file.
 * RETURNS: linked list of timing vectors
 */
{
   int i, n, nr;
   char ln[512];
   ATL_tvec_t *tb, *tp;

   assert(fgets(ln, 512, fpin));
   n = strlen(ln);
   while (n > 0 && isspace(ln[n-1]))
      ln[--n] = '\0';;
   *cmnt = malloc(sizeof(char)*n);
   assert(*cmnt);
   strcpy(*cmnt, ln+1);
   assert(fscanf(fpin, " %d %d\n", nvec, nrep) == 2);

   n = *nvec;
   nr = *nrep;
   if (n < 1)
      return(NULL);

   tb = tp = ATL_ReadTvec(fpin, nr);
   for (i=1; i < n; i++)
   {
      tp->next = ATL_ReadTvec(fpin, nr);
      tp = tp->next;
   }
   return(tb);
}

void ATL_WriteTvec(FILE *fpout, ATL_tvec_t *tp)
/*
 * Write a single timing vector to the stream fpout
 */
{
   fprintf(fpout, "%s\n", tp->name);
   fprintf(fpout, "%d %c\n", tp->N, tp->pre);
   if (tp->pre == 'd')
   {
      double *dp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%le\n", dp[i]);
   }
   else if (tp->pre == 'i')
   {
      int *ip = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%d\n", ip[i]);
   }
   else if (tp->pre == 'c')
   {
      char *cp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%c\n", cp[i]);
   }
   else /* if (tp->pre == 's') */
   {
      char **sp = tp->vp;
      const int n = tp->N;
      int i;
      for (i=0; i < n; i++)
         fprintf(fpout, "%s\n", sp[i]);
   }
}

void ATL_WriteTvecs(FILE *fpout, ATL_tvec_t *tp)
/*
 * Writes out a queue of output vectors to a stream that has already had
 * the preample (name, nvec, nrep) written to it
 */
{
   while (tp)
   {
      ATL_WriteTvec(fpout, tp);
      tp = tp->next;
   }
}

void ATL_WriteTvecFile(FILE *fpout, char *cmnt, int nvec, int nrep, 
                       ATL_tvec_t *tp)
/*
 * Writes the entire output file given a queue of timing vectors 
 */
{
   int i;
   fprintf(fpout, "#%s\n", cmnt);
   fprintf(fpout, "%d %d\n", nvec, nrep);
   ATL_WriteTvecs(fpout, tp);
}

ATL_tvec_t *ATL_FindTvecByName(ATL_tvec_t *tb, char *name)
{
   ATL_tvec_t *tp;
   for (tp=tb; tp && strcmp(tp->name, name); tp = tp->next);
   return(tp);
}

@whiledef typ double int char
void ATL_FillComb@up@(typ)VecUsingInts
(
   ATL_tvec_t *np,    /* combined vector */
   ATL_tvec_t *ip1,   /* 1st index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *ip2,   /* 2nd index array (we sort cp1 & cp2 on these ivecs) */
   ATL_tvec_t *cp1,   /* 1st array to be combined */
   ATL_tvec_t *cp2    /* 2st array to be combined */
)
{
   @(typ) *dn = np->vp;
   const @(typ) *d1 = cp1->vp, *d2 = cp2->vp;
   const int *s1 = ip1->vp, *s2 = ip2->vp;
   const int n = np->N, n1 = cp1->N, n2 = cp2->N;
   int ic, i1, i2;

   for (ic=i1=i2=0; ic < n; ic++)
   {
      if (i1 < n1)
      {
         if (i2 < n2)  /* both are available for comparison */
         {
            if (s1[i1] <= s2[i2])
               dn[ic] = d1[i1++];
            else
               dn[ic] = d2[i2++];
         }
         else
         {
            assert(i1 < n1);
            dn[ic] = d1[i1++];
         }
      }
      else
      {
         assert(i2 < n2);
         dn[ic] = d2[i2++];
      }
   }
}
@endwhile

ATL_tvec_t *ATL_CombineTheseVecsUsingInts
(
   ATL_tvec_t *sp1,      /* 1st vector's index array to sort on */
   ATL_tvec_t *sp2,      /* 2nd vector's index array to sort on */
   ATL_tvec_t *cp1,      /* vector to be combined */
   ATL_tvec_t *cp2       /* vector to be combined */
)
{
   ATL_tvec_t *np;
   const pre = cp1->pre;

   assert(sp1->N == cp1->N && sp2->N == cp2->N);
   assert(sp1->pre == sp2->pre && sp1->pre == 'i');
   assert(pre == cp2->pre);
   assert(sp1->nrep == sp2->nrep && sp1->nrep == cp1->nrep && 
          sp1->nrep == cp2->nrep);
   np = ATL_GetTvec(cp1->name, cp1->N+cp2->N, cp1->nrep, pre);
   if (pre == 'i')
      ATL_FillCombINTVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'd')
      ATL_FillCombDOUBLEVecUsingInts(np, sp1, sp2, cp1, cp2);
   else if (pre == 'c')
      ATL_FillCombCHARVecUsingInts(np, sp1, sp2, cp1, cp2);
   return(np);
}

@beginskip
ATL_tvec_t *ATL_KillNamedVecFromList  /* returns list w/ named vec(s) removed */
(
   char *names,         /* names of vectors to grab */
   ATL_tvec_t *tb       /* original list */
)
{
   if (!tb)
      return(NULL);
   while (!strcmp(tb
}
@endskip
void ATL_SuffixTvecNames
(
   ATL_tvec_t *tb,   /* list whose names should be suffixed */
   char *suff 
)
{
   ATL_tvec_t *tp;
   int isu;

   isu = strlen(suff) + 1;
   for (tp=tb; tp; tp = tp->next)
   {
      int i, inm, n;
      char *sp;

      inm = strlen(tp->name);
      sp = malloc((inm+isu)*sizeof(char));
      for (i=0; i < inm; i++)
         sp[i] = tp->name[i];
      for (n=inm+isu; i < n; i++)
         sp[i] = suff[i-inm];
      free(tp->name);
      tp->name = sp;
   }
}
ATL_tvec_t *ATL_PullNamedVecsFromList  /* returns list of pulled vecs */
(
   int N,               /* # of vectors to remove from list to */
   char **names,        /* names of vectors to grab */
   ATL_tvec_t **orig    /* original list has names removed */
)
/*
 * Note that the names will be returned in the provided order, and that
 * we assume a name only appears once in orig.
 */
{
   ATL_tvec_t *prev, *old=(*orig), *po, *pn, *nb=NULL;
   int i;
   if (!old || N < 1)
      return(NULL);
   for (i=0; i < N; i++)
   {
      prev = NULL;
      po = old;
      while (po)
      {
         if (!strcmp(names[i], po->name))
         {
            if (po == old)
               old = old->next;
            if (nb)
            {
               pn->next = po;
               pn = po;
            }
            else
               pn = nb = po;
            if (prev)
               prev->next = po->next;
            pn->next = NULL;
            break;
         }
         prev = po;
         po = po->next;
      }
   }
   *orig = old;
   return(nb);
}

int ATL_CountTVecsInList
(
   ATL_tvec_t *tb      /* list to count */
)
{
   int i;
   for (i=0; tb; i++, tb = tb->next);
   return(i);
}

ATL_tvec_t *ATL_FindLastVecInList  /* RETURNS: last tvec in list */
(
   ATL_tvec_t *tb      /* list to look through */
)
{
   if (tb)
   {
      while (tb->next)
         tb = tb->next;
   }
   return(tb);
}

ATL_tvec_t *ATL_AlphabetizeVecList  /* returns alphabatized list */
(
   int N,              /* # of vectors in list */
   ATL_tvec_t *tb      /* list to alphabetize */
)
/*
 * Alphabatizes N-len tb, and returns new ordered list (old is destroyed).
 */
{
   char **names;
   ATL_tvec_t *tp;
   int i, j;

   names = malloc(sizeof(char*)*N);
   assert(names);
   for (i=0; tp && i < N; i++, tp = tp->next)
      names[i] = tp->name;
   assert(i == N);
/*
 * Sort names using selection sort
 */
   for (j=0; j < N-1; j++)
   {
      for (i=j+1; i < N; i++)
      {
         if (strcmp(names[i], names[j]) < 0)
         {
            char *sp = names[j];
            names[j] = names[i];
            names[i] = sp;
         }
      }
   }
/*
 * Use sorted names to make new alphabetical list, free names and return list
 */
   tb = ATL_PullNamedVecsFromList(N, names, &tb);
   free(names);
   return(tb);
}

void ATL_CopyStridedVec(char pre, int n, int inc, void *vin, void *vout)
{
   if (pre == 'd')
   {
      int i, j;
      double *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'i')
   {
      int i, j;
      int *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 'c')
   {
      int i, j;
      char *in = vin, *out = vout;
      for (j=i=0; i < n; i++, j += inc)
         out[i] = in[j];
   }
   else if (pre == 's')
   {
      int i, j;
      char **in = vin, **out = vout;
      for (j=i=0; i < n; i++, j += inc)
      {
         int n;
         n = strlen(in[i]) + 1;
         out[i] = malloc(n*sizeof(char));
         strcpy(out[i], in[j]);
      }
   }
}

void ATL_PrintTVecElt
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tp,      /* vector to print from */
   int idx              /* index in vector to print */
)
{
   if (tp->pre == 'd')
   {
      double *p = tp->vp;
      fprintf(fpout, "%e", p[idx]);
   }
   else if (tp->pre == 'i')
   {
      int *p = tp->vp;
      fprintf(fpout, "%d", p[idx]);
   }
   else if (tp->pre == 'c')
   {
      char *p = tp->vp;
      fprintf(fpout, "%c", p[idx]);
   }
   else if (tp->pre == 's')
   {
      char **p = tp->vp;
      fprintf(fpout, "%s", p[idx]);
   }
}

void ATL_PrintTVecsInRow
(
   FILE *fpout,         /* stream to print to */
   ATL_tvec_t *tb,      /* list of vectors to print (rowwise) */
   char *sep            /* string to print between elements */
)
{
   ATL_tvec_t *tp;
   const int N = tb->N;
   int i;

   if (!tb)
      return;
   for (tp=tb->next; tp; tp = tp->next)
      assert(tp->N >= N);

   for (i=0; i < N; i++)                        /* loop over rows of vectors */
   {
      for (tp=tb; tp->next; tp = tp->next)      /* loop over columns  */
      {
         ATL_PrintTVecElt(fpout, tp, i);
         fprintf(fpout, "%s", sep);
      }
      ATL_PrintTVecElt(fpout, tp, i);
      fprintf(fpout, "%s\n", sep);
   }
}

ATL_tvec_t *ATL_GetRep1Vector
(
   ATL_tvec_t *tin,    /* vector to split */
   int istart          /* which repetition to grab */
)
{
   char *name;
   ATL_tvec_t *t1=NULL;
   int n;
   const int Nr = tin->N / tin->nrep;
   const char pre = tin->pre;

   assert(tin->nrep < 10000000);
   n = strlen(tin->name) + 9;
   name = malloc(n*sizeof(char));
   assert(name);
   sprintf(name, "%s_%d", tin->name, istart);
   t1 = ATL_GetTvec(name, Nr, 1, pre);
   free(name);
   if (pre == 'd')
      ATL_CopyStridedVec(pre, Nr, tin->nrep,((double*)(tin->vp))+istart,t1->vp);
   else if (pre == 'i')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((int*)(tin->vp))+istart, t1->vp);
   else if (pre == 'c')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char*)(tin->vp))+istart, t1->vp);
   else if (pre == 's')
      ATL_CopyStridedVec(pre, Nr, tin->nrep, ((char**)(tin->vp))+istart,t1->vp);

   return(t1);
}

ATL_tvec_t *ATL_SplitRepsVector  /* returns Q of sep vecs for each rep */
(
   ATL_tvec_t *tin     /* vector to split */
)
{
   int i;
   const int nrep = tin->nrep;
   ATL_tvec_t *tb, *tp;

   tp = tb = ATL_GetRep1Vector(tin, 0);
   for (i=1; i < nrep; i++)
   {
      tp->next = ATL_GetRep1Vector(tin, i);
      tp = tp->next;
   }
   return(tb);
}

ATL_tvec_t *ATL_GetStatVecsDOUBLE  /* returns Q of stat vectors: <,+,> */
(
   ATL_tvec_t *tin     /* vector to get stats for */
)
{
   char *name;
   int i, j, n, N;
   ATL_tvec_t *tavg, *tmin, *tmax;
   double *dmin, *dmax, *davg;

   n = strlen(tin->name) + 5;
   name = malloc(sizeof(char)*n);
   N = tin->N / tin->nrep;
   assert(name);

   sprintf(name, "%s_min", tin->name);
   tmin = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_avg", tin->name);
   tavg = ATL_GetTvec(name, N, 1, tin->pre);
   sprintf(name, "%s_max", tin->name);
   tmax = ATL_GetTvec(name, N, 1, tin->pre);
   dmin = tmin->vp;
   dmax = tmax->vp;
   davg = tavg->vp;

   n = tin->nrep;
   for (j=0; j < N; j++)
   {
      double min, max, sum, *din;

      din = ((double*)(tin->vp)) + j*n;
      min = max = sum = *din;
      for (i=1; i < n; i++)
      {
         if (din[i] < min)
            min = din[i];
         if (din[i] > max)
            max = din[i];
         sum += din[i];
      }
      dmin[j] = min;
      dmax[j] = min;
      davg[j] = sum / n;
   }
   tmin->next = tavg;
   tavg->next = tmax;
   return(tmin);
}

#endif  /* end ifdef multi-inclusion guard */
