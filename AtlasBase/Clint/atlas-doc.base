@ROUT AtlasCredits.txt
********************************* ATLAS TEAM **********************************
ATLAS is currently developed and maintained by R. Clint Whaley at the
University of Texas at San Antonio.  Several UTSA students/staff have made
strong contributions, including Tony Castaldo and Siju Samuel.  The
present ATLAS team is:
   Clint Whaley, PI 
   Tony Castaldo, Research Professor
   Md. Rakib Hasan, PhD candidate: parallel algorithms
   Md. Majedul Haque Sujon, PhD candidate: iterative compilation

ATLAS was originally developed at the Innovative Computing Laboratory (ICL),
at the University of Tennessee, though no team members remain there now.
The original ATLAS team was:

                                Antoine Petitet
                              petitet@cs.utk.edu
       ** Recursive Level 3 BLAS
       ** Codeveloped Level 2 gemv- & ger-based BLAS
       ** Codeveloped ATLAS level 2 blas tester
       ** Reference BLAS
       ** BLAS F77 interface
       ** Developed original pthreads implementation
       ** Level 2 packed and banded gemv- and ger-based BLAS
       ** Level 1 BLAS tester/timer

                                R. Clint Whaley
                              whaley@cs.utsa.edu
       ** General ATLAS design
       ** config, install & tuning routines
       ** Matrix multiply
       ** Code generators for real & complex matrix multiply
       ** Kernel routines used in the recursive Level 3 BLAS
       ** Codeveloped Level 2 gemv- & ger-based BLAS
       ** Codeveloped ATLAS level 2 blas tester
       ** GEMV & GER and associated files
       ** C interface to BLAS
       ** Recursive LU, Cholesky, xLAUUM and xGETRI routines and testers
       ** LAPACK interfaces
       ** ATLAS Level 1 BLAS routines
       ** Tools and docs necessary to allow user contribution of all kernels
       ** Quite a few GEMV, GER, and GEMM kernels
       ** New threading infrastructure (as of 3.9.5)
       ** Help with new QR design and some coding, some help with qr tester,
          and wrote the C/F77 interface files for all QR variants (see
          Siju Samuel for more details on QR)
       -> Pretty much anything not attributed to someone else :)

During the original development at UTK, Jeff and Peter also helped out:

                                  Jeff Horner
                              jhorner@cs.utk.edu
       ** Level 3 BLAS tester/timer
       ** Beta versions of
          ** Non-generated complex matrix multiply code
          ** C interface to the Level 3 BLAS

                              Peter Soendergaard
                              soender@cs.utk.edu
       ** Recursive xTRTRI and tester


ATLAS has been modified to allow for outside contribution, and the
following people have contributed to ATLAS (alphabetic order):

                                 Doug Aberdeen 
       ** Work on emmerald (an SSE-enabled SGEMM) was the starting point
          for a lot of the people doing SSE-enabled kernels.

                                 Matthew Brett
       ** Help with getting ATLAS to build dynamic libraries.
       ** Lots of help in switching from CVS/sourceforge to git/github
       ** Provided basis for ATLAS/git documentation by creating
          first version gitwash subdir now in AtlasBase/TexDoc/gitwash

                                 Tony Castaldo (2008, 2009, 2012)
       ** UTSA student and research professor.
       ** Figured out PowerPC970 required issuing 4 inst of same type in a row,
          and intermixing of M-loop iterations for full performance.  
       ** Discovered the importance of master-last, leading to full threading
          rewrite.
       ** Did main prototyping and helped with design of the of ATLAS 
          QR variants.  See Siju Samuel entry for more details.
       ** Main developer of PCA QR panel factorization prototype code

                                 Nicholas Coult
       ** Initial version of AltiVec enabled SGEMM.

                                 Markus Dittrich
       ** Provided the trick needed to get configure to pass multiple words
          as a single flag in configure.

                                 Saurabh Garg
       ** Help with building MSVC++ compatible shared libraries.  See:
          https://sf.net/projects/math-atlas/forums/forum/1026734/topic/5349864

                                 Dean Gaudet
       ** CPUID for config (see ATLAS/CONFIG/archinfo_x86.c), Efficeon tuning
          information, and many informative atlas-devel discussions.

                                 Kazushige Goto 
       ** Assembly language GEMM for Compaq/DEC ev5x and ev6 machines. See
          ATLAS/src/blas/gemm/GOTO for details.  Code no longer in ATLAS 
          v > 3.7.12, as we have dropped support for alphas.

                           Jeff Hammond & BLIS project
      ** Jeff announced Intel PHI support in BLIS (GotoBLAS redesign) on 
         atlas-devel list as part of a discussion on sharing architectural
         knowledge for our respective BLAS projects.
         I looked at BLIS code to figure out how to do vector permutation as
         part of computation on the PHI, which I was confused on from the
         Intel docs.  The routine in question does not credit the author,
         but Jeff reports it was worked on by Mikhail Smelyanskiy of
         Intel and Tyler Smith.  For BLIS details, see:
            https://code.google.com/p/blis/

                                 Md. Rakib Hasan             
       ** UTSA student.  Wrote ARM NEON kernels for GER2K.
          See ATLAS/tune/blas/gemv/MVTCASES/ATL_sger2K_NEON*.S for details.

                                 Camm Maguire   
       ** SSE enabled [S,D,C,Z]GEMM, [S,D,C,Z]GEMV and [S,D,C,Z]GER kernels,
          see ATLAS/tune/blas/gemm/CASES, ATLAS/tune/blas/gemv/CASES 
          and ATLAS/tune/blas/ger/CASES for details.

                                 Ryan Moon (2009)
       ** Wrote the first version of the OpenMP Level 3 threaded BLAS
          based on the new threading framework while an undergrad at UTSA.
          See ATLAS/src/threads/blas/level3/omp for details.

     
                             Tim Mattox and Hank Dietz
       ** Extremely efficient 3DNow! kernel for Athlon, see
          ATLAS/tune/blas/gemm/CASES/ATL_smm_3dnow_90.c for details.

                       Viet Nguyen and Peter Strazdins
       ** UltraSparc-optimized [D,Z]GEMM kernels, see
          ATLAS/tune/blas/gemm/CASES for details.

                           Pearu Peterson
       ** A lot of 3.6 stable testing.
       ** Initial work on building ATLAS to dynamic libraries.

                              Julian Ruhe
       ** Excellent Athlon-optimized assembly kernels, see
          ATLAS/tune/blas/gemm/CASES/objs/ for details.

                              Siju Samuel (2009)
       ** UTSA student.  Took prototype QR factorization written by Tony
          Castaldo (mostly based on the Elmroth & Gustavson recursive QR, see
          www.cs.utsa.edu/~whaley/papers/ppopp143-castaldo.pdf for details)
          and wrote native implementations of all required QR variants.
          See ATLAS/src/lapack for all the QR/RQ/QL/LQ related files,
          and ATLAS/bin/qrtst.c for their tester.
       ** Took Tony Castaldo's prototype QR PCA code and produced versions for
          QR and LQ for all precisions for parallel lapack


                              Peter Soendergaard
       ** SSE and 3DNow! GEMM routines.  See ATLAS/tune/blas/gemm/CASES
          for details.  Also, translation of Julian Ruhe's Athlon kernels
          from NASM to gnu assembler, and extension to all precisions.
          See ATLAS/tune/blas/gemm/CASES/ATL_dmm_julian_gas_30.c for details.

                              Carl Staelin       
       ** Initial work on parallelizing ATLAS make.

                              Md. Majedul Haque Sujon
       ** UTSA student.  Wrote ARM NEON kernel for transpose GEMV.
          See ATLAS/tune/blas/gemv/MVTCASES/ATL_sgemvT_8x4_neon.S for details.

                              Yevgen Voronenko
       ** Provided code template for Core2Duo-friendly 2-D register block
          which allowed us to greatly increase our Core2Duo GEMM performance.
          See ATLAS/tune/blas/gemm/CASES/ATL_dmm4x2x128_sse2.c for details.
                            
                             Tom Wallace (2011, 2012)
      ** Did a lot of work on adding ARM support to ATLAS's configure, as
         well as some tuning for the ARM.   Also, a lot of testing and
         submission of patches.  Provided ARM NEON s/c GEMM kernel.

                             Chad Zalkin (2009)
      ** Wrote code generator which uses gcc intrinsics to autovectorize and
         tune matrix multiply.  Contributed to the search over the same.
         See ATLAS/tune/blas/gemm/mmgen_sse.c and 
         ATLAS/tune/blas/gemm/mmksearch_sse.c for details.
@ROUT INDEX.txt
This is the README index file.  If you want install intructions, 
read ATLAS/INSTALL.txt.  Windows users should read 
ATLAS/doc/Windows.txt as well.  Note that all of this documentation is
probably out of date.  The website always contains the most current versions:
   http://math-atlas.sourceforge.net/faq.html#doc


A listing of the ATLAS documentation files is:

                                 in ATLAS/
INSTALL.txt       : Basic ATLAS installation instructions as text
README            : This file


                              in ATLAS/doc/
AtlasCredits.txt : The ATLAS team
atlas_install.pdf: Relatively complete guide to configuring, building,
                   installing and testing ATLAS.
BootSequence.txt : Rough outline of how the ATLAS install works, and what
                   files it creates.
ChangeLog.txt    : Brief summmary of changes from previous releases.
DirStruct.txt    : A graphic of the general organization of the ATLAS files
INDEX.txt        : This index file again
LibReadme.txt    : Information on generated libraries.
TestTime.txt     : Information on using the ATLAS testing and timing programs
TroubleShoot.txt : Help with troubleshooting your installation, including
                   where to find more help
Windows.txt      : Special information users of Microsoft Windows (95/98/NT/2K)
                   should read
atlas_contrib.pdf: Information on how users can speedup and contribute to
                   ATLAS by providing low-level kernel routines
altas_over.pdf   : Paper describing ideas and basic methods of ATLAS
cblas.pdf        : Extract of the BLAST standard document, describing the
                   standard C interface to the BLAS.
fblasqr.pdf      : Quick reference to the F77 interface to the BLAS.
@ROUT TestTime.txt
************************  TIMING AND TESTING ATLAS  ***************************

The ATLAS distribution has several different testing and timing methods.  For
testing, the most important testers are the standard API testers for the 
C and Fortran77 BLAS libraries, and the Fortran77 lapack tester.  Sections
1, 2, and 3 deal with performing these tests.

ATLAS also provides its own timer programs that do some rudimentary testing
as well as performing relatively sophisticated timings (involving cache
flushing, etc).  The remaining sections deal with using these timer/testers.

1. THE FORTRAN77 INTERFACE BLAS TESTERS

   The official BLAS testers for the Fortran77 interface to the legacy BLAS
   can be ran in BLDdir/interfaces/blas/F77/testing/.  Typing "make" with
   no arguments will compile all of the testers (all levels & precisions).
   The user may then run the testers by:

   ./xsblat1
   ./xdblat1
   ./xcblat1
   ./xzblat1

   ./xsblat2 < SRCdir/interfaces/blas/F77/sblat2.dat
   ./xdblat2 < SRCdir/interfaces/blas/F77/dblat2.dat
   ./xcblat2 < SRCdir/interfaces/blas/F77/cblat2.dat
   ./xzblat2 < SRCdir/interfaces/blas/F77/zblat2.dat

   ./xsblat3 < SRCdir/interfaces/blas/F77/sblat3.dat
   ./xdblat3 < SRCdir/interfaces/blas/F77/dblat3.dat
   ./xcblat3 < SRCdir/interfaces/blas/F77/cblat3.dat
   ./xzblat3 < SRCdir/interfaces/blas/F77/zblat3.dat

   The user may edit the input files to perform more or less comprehensive
   tests. For more information on the legacy BLAS testers, go to :

   www.netlib.org/blas/faq.html

2. THE ANSI/ISO C INTERFACE BLAS TESTERS

   The official BLAS testers for the ANSI/ISO C interface to the legacy BLAS
   can be ran in BLDdir/interfaces/blas/C/testing/.  Typing "make" with
   no arguments will compile all of the testers (all levels & precisions).
   The user may then run the testers by:

   ./xscblat1
   ./xdcblat1
   ./xccblat1
   ./xzcblat1

   ./xscblat2 < SRCdir/interfaces/blas/C/testing/c_sblat2.dat
   ./xdcblat2 < SRCdir/interfaces/blas/C/testing/c_dblat2.dat
   ./xccblat2 < SRCdir/interfaces/blas/C/testing/c_cblat2.dat
   ./xzcblat2 < SRCdir/interfaces/blas/C/testing/c_zblat2.dat

   ./xscblat3 < SRCdir/interfaces/blas/C/testing/c_sblat3.dat
   ./xdcblat3 < SRCdir/interfaces/blas/C/testing/c_dblat3.dat
   ./xccblat3 < SRCdir/interfaces/blas/C/testing/c_cblat3.dat
   ./xzcblat3 < SRCdir/interfaces/blas/C/testing/c_zblat3.dat

   The user may edit the input files to perform more or less comprehensive
   tests. For more information on the legacy BLAS testers, go to :

   www.netlib.org/blas/faq.html

3. TESTING THE FORTRAN77 INTERFACE TO LAPACK

   You will need to throw the --with-netlib-lapack-tarfile=<lapack.tgz>
   flag to use this feature, since ATLAS does not natively provide a complete
   LAPACK implementation.  Here are some important targets, all of which can
   be issued from the BLDdir directory:
      make lapack_test_al_ab : test ATLAS's serial lapack
      make lapack_test_pt_pt : test ATLAS's threaded lapack
      make lapack_test_fl_fb : test the F77 LAPACK wt F77 BLAS
   To get a summary of the output of such tests, add "scope_" to the name, eg.:
      make scope_test_fl_fb
   Since the lapack testers always fail tests when using any blas, it is
   typical to contrast an optimized install with a reference install to
   narrows down the cases that must be investigated for true errors.
   See atlas_install.pdf for a few more details.

4. USING ATLAS BLAS TIMER/TESTERS WITH A SYSTEM BLAS LIBRARY

   The ATLAS Level 1-3 tester/timers programs all test one BLAS
   implementation against another.  These programs compute the Mflop/s
   rate for each routine called. In addition, they check the result
   matrices computed by calls to the system BLAS and ATLAS library
   routines.  For more information about the testing implementation in
   the Level 3 programs, read section 6.1.

   To properly build the programs with your BLAS library, make sure to
   set the BLASlib variable in the BLDdir/Make.inc include file correctly:
   
   BLASlib = /path/to/library/libblas.a

   By default, this will be set to $(FBLASlib), which means ATLAS will
   test and time itself against the Fortran reference BLAS which ATLAS
   autocompiles during the install.  You can reset this to a vendor-supplied
   BLAS if you like.
   
   On some machines, the compiler will recognize certain flags that link
   in the vendor-optimized BLAS library. You can place these in the BLASlib
   variable as well.  There are too many of these to list in detail here, but
   here are a few examples of vendor-supplied BLAS:
   
   BLASlib = -xlic_lib=sunperf    # on sun machines using Sun workshop compiler
   
   BLASlib = -ldxml               # Using Dec/Compaq's compiler
   BLASlib = -lcxml               # Using Compaq/Dec's compiler

   BLASlib = -lessl               # IBM machines using IBM compiler
   BLASlib = -lesslp2             # IBM Power2 machines using IBM compiler
   BLASlib = -lesslp3             # IBM Power3 machines using IBM compiler

   BLASlib = -lblas               # IRIX using SGI's compiler

   After you're sure that the BLASlib variable is set properly, read section
   3 and 4 on the ATLAS LEVEL 3 TIMER/TESTER PROGRAMS to learn how to build
   and run them.

5. TESTING _WITHOUT_ A BLAS LIBRARY

   You may still build and run the ATLAS TESTER/TIMERs programs without a
   system BLAS library by testing against the ATLAS provided C reference BLAS.
   Just leave the BLASlib variable in the ATLAS/Make.<arch> makefile blank:

   BLASlib =                    
   
   Then, edit ATLAS/bin/l3blastst.c, and change line 87 from:
#define USE_F77_BLAS
   to:
#define USE_L3_REFERENCE

   Edit ATLAS/bin/l2blastst.c and change line 56 from:
#define USE_F77_BLAS
   to:
#define USE_L2_REFERENCE

6. THE ATLAS LEVEL 3 TIMER/TESTER PROGRAMS

   To make the single, double, single complex, and double complex
   programs, type:

   make xsl3blastst
   make xdl3blastst
   make xcl3blastst
   make xzl3blastst

   Running the programs without arguments will time _GEMM with square
   problem sizes from 100 to 1000 by 100,  alpha=1.0 and beta=1.0, and A
   and B are non-transpose:

   ./xdl3blastst

DGEMM
TEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS
====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ====  ====

   1   N   N  100  100  100    1.0    0.0    0.02  200.0  1.00   ---
   1   N   N  100  100  100    1.0    0.0    0.01  200.0  1.00   YES
   2   N   N  200  200  200    1.0    0.0    0.09  177.8  1.00   ---
   2   N   N  200  200  200    1.0    0.0    0.09  177.8  1.00   YES
   3   N   N  300  300  300    1.0    0.0    0.35  154.3  1.00   ---
   3   N   N  300  300  300    1.0    0.0    0.29  186.2  1.21   YES
   4   N   N  400  400  400    1.0    0.0    0.73  175.3  1.00   ---
   4   N   N  400  400  400    1.0    0.0    0.68  188.2  1.07   YES
   5   N   N  500  500  500    1.0    0.0    1.48  168.9  1.00   ---
   5   N   N  500  500  500    1.0    0.0    1.35  185.2  1.10   YES
   6   N   N  600  600  600    1.0    0.0    2.47  174.9  1.00   ---
   6   N   N  600  600  600    1.0    0.0    2.30  187.8  1.07   YES
   7   N   N  700  700  700    1.0    0.0    4.01  171.1  1.00   ---
   7   N   N  700  700  700    1.0    0.0    3.65  187.9  1.10   YES
   8   N   N  800  800  800    1.0    0.0    5.74  178.4  1.00   ---
   8   N   N  800  800  800    1.0    0.0    5.43  188.6  1.06   YES
   9   N   N  900  900  900    1.0    0.0    8.38  174.0  1.00   ---
   9   N   N  900  900  900    1.0    0.0    7.68  189.8  1.09   YES
  10   N   N 1000 1000 1000    1.0    0.0   11.25  177.8  1.00   ---
  10   N   N 1000 1000 1000    1.0    0.0   10.58  189.0  1.06   YES

NTEST=10, NUMBER PASSED=10, NUMBER FAILURES=0


   Notice that there are two entries for each run. The first entry
   corresponds to a call to the library that you supply, and the second
   entry corresponds to a call to the ATLAS library.

   An explanation of each argument follows:

   ./xd3blastst -help
   USAGE: ./xd3blastst -R <rout> -Side <nsides> L/R -Uplo <nuplo> L/U 
   -Atrans <ntrans> n/t/c -Btrans <ntrans> n/t/c -Diag <ndiags> N/U 
   -M <m1> <mN> <minc> -N <n1> <nN> <ninc> -K <k1> <kN> <kinc> 
   -n <n> -m <m> -k <k> -a <nalphas> <alpha1> ... <alphaN> 
   -b <nbetas> <beta1> ... <betaN> -Test <0/1>

   -R <rout>    Specifies the routines which you would like to
                test/time. The routines for the single and double
                precision programs are gemm, symm, syrk, syr2k, trmm,
                and trsm (note the omission of the prefix s and d). The
                additional routines for the single complex and double 
                complex programs are hemm, herk, and her2k. You can
                also specify the argument like this:
                
                ./xd3blastst -R all
                
                which will time all the routines. Or you can specify
                some of the routines like this:
                
                ./xd3blastst -R 1 symm
                ./xd3blastst -R 4 syrk trsm symm gemm
                
                but NOT like this:
                
                ./xd3blastst -R 2 syr2k all
                
   -Side <nsides> L/R   
                Specifies the number of Side parameters you would like
                to test for the appropriate routines. If a routine does
                not take the side parameter, then the argument is ignored. 
                You can specify the argument like this:
                
                ./xd3blastst -R symm -Side 1 L
                ./xd3blastst -R symm -Side 2 L R
                ./xd3blastst -R symm -Side 3 R R L
                
                The <nsides> argument is not optional; it must be present.

   -Uplo <nuplo> L/U
                Specifies the number of Uplo parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R 2 syrk syr2k -Uplo 1 U
                ./xd3blastst -R 2 syrk syr2k -Uplo 2 U L
                ./xd3blastst -R 2 syrk syr2k -Uplo 4 U U U U

   -Diag <ndiag> N/U
                Specifies the number of Diag parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R trmm -Diag 1 N
                ./xd3blastst -R trmm -Diag 2 U N
                ./xd3blastst -R trmm -Diag 4 U N U U

   -Btrans <ntrans> N/T/C
                Specifies the number of Btrans parameters you would like to
                test (only used with gemm). It's use follows the same 
                behavior as -Side, like this:
                
                ./xd3blastst -R gemm -Btrans 1 N
                ./xd3blastst -R gemm -Btrans 2 T N
                ./xd3blastst -R gemm -Btrans 4 T N T T

   -Atrans <ntrans> N/T/C
                Specifies the number of Atrans parameters you would like to
                test. It's use follows the same behavior as -Side, like this:
                
                ./xd3blastst -R gemm -Atrans 1 N
                ./xd3blastst -R gemm -Atrans 2 T N
                ./xd3blastst -R gemm -Atrans 4 T N N T
                
                Also, use -Atrans for routines which only take one TRANS 
                argument:

                ./xd3blastst -R trmm -Atrans 2 T N
                
   -M <m1> <mN> <mInc>
   -N <n1> <nM> <nInc>
   -K <k1> <kK> <kInc>
                Specifies the combination of problem sizes to run.
                To specify square problem sizes, use -N:
                
                ./xd3blastst -R gemm -N 1 10 1
                
                will time all square matrices from dimension 1 to 10.
                
                ./xd3blastst -R gemm -M 10 100 10 -N 10 100 10 -K 10 100 10
                
                will time every single problem size imaginable between
                10 and 100 incrementing by 10.
                
   -m <m>
   -n <n>
   -k <k>
                Fixes the dimension in question to one value:
                
                ./xd3blastst -R gemm -K 1 100 1 -m 100 -n 100
                
   -a <nalphas> <alpha1> ... <alphan>
   -b <nbetas> <beta1> ... <betan>
                Specifies the number and the value of alphas/betas to try.
                
                ./xd3blastst -R gemm -a 4 -1.0 0.0 1.0 2.0 -b 1 0.0

                For the complex precision programs, you must specify both
                the real and imaginary parts for alpha and beta.

                ./xz3blastst -R gemm -a 2 -1.0 0.0 1.0 0.0 -b 1 0.0 0.0

               For those complex routines that take a real scalar
               alpha/beta instead of a complex scalar alpha/beta, the
               imaginary part must still be specified, but is
               ignored.

                ./xz3blastst -R her2k -a 1 2.0 3.0
                
                will time her2k with alpha=2.0.
                
   -Test 0/1
                Specifies whether or not to test the results of each run.
                A brief explanation of testing is provided below.
                 
6.1 TESTING IMPLEMENTATION

   The LEVEL 3 TESTER/TIMER programs were created to make performance
   analysis easier, not as a validation tool, thus the testing
   implementation is modest. For a complete test of ATLAS's LEVEL 3
   BLAS implementation, run the CBLAS TESTER described in section 5.

   For all routines, except _TRSM, we compute:
   
      
                          ||C-D||
      x = -----------------------------------------
         ||A|| * ||B|| * |alpha| * eps * max(M,N,K)

   where A, B, and alpha are arguments to the routine, C is the result
   matrix from the call to a trusted BLAS library, D is the result matrix from
   the call to ATLAS, eps is the epsilon value for the machine, and
   max(M,N,K) is the largest value of M, N, K which describe the
   dimensions for the argument and result matrices to the routine. The
   operation ||N|| is the column norm of matrix N, and x <= O(1).

   For _TRSM, we compute:
   
                           ||B-A*X||
       x =  ----------------------------------------
            ||A|| * ||X|| * |alpha| * eps * max(M,N)
   
   where A, B, and alpha are arguments to the routine, X is the result
   matrix from the ATLAS _TRSM call, and max(M,N) is the larger
   value of M an K.

   The data for the argument matrices are generated internally, using the
   ANSI C rand() function, and are distributed over the interval (-.5,+.5). 
   In any case, if x > 1 then an error will be output:

   DGEMM
   TEST  TA  TB    M    N    K  alpha   beta    Time  Mflop  SpUp  PASS
   ====  ==  ==  ===  ===  ===  =====  =====  ======  =====  ====  ====
   
      1   N   N  100  100  100    1.0    0.0    0.01  259.7  1.00   ---
   ERROR: ferr is 4860974538.606986
      1   N   N  100  100  100    1.0    0.0    0.01  227.9  0.88    NO
      2   N   N  200  200  200    1.0    0.0    0.05  291.6  1.00   ---
   ERROR: ferr is 8411267408.031064
      2   N   N  200  200  200    1.0    0.0    0.06  274.5  0.94    NO
      3   N   N  300  300  300    1.0    0.0    0.17  327.2  1.00   ---
   ERROR: ferr is 2895940442.476244
      3   N   N  300  300  300    1.0    0.0    0.20  272.5  0.83    NO

   Ferr is the value of x.  

   What can we infer from the error?  Not much. If the two result
   matrices are 'roughly the same', then no error is
   produced. Otherwise, the result matrices are 'not roughly the same'.

   However, if you see this error message it's best to test both
   libraries (if ATLAS doesn't fail, test your ``trusted'' BLAS)
   with the BLAS testers from netlib:
   
   www.netlib.org/blas/sblat3
   www.netlib.org/blas/dblat3
   www.netlib.org/blas/cblat3
   www.netlib.org/blas/zblat3

7. Timing the Level 2 BLAS
   
   The level 2 timer/tester is very similar in action to the level 3 timer.
   to make, in BLDdir/bin/, type:

   make xsl2blastst
   make xdl2blastst
   make xcl2blastst
   make xzl2blastst

   The flags are very similar to those accepted by the level 3 BLAS timer.
   For usage help, type 
   ./xdl2blastst -h

8. Timing the Level 1 BLAS
   The level 1 timer/tester is very similar in action to the level 2 timer.
   to make, in BLDdir/bin/, type:

   make xsl1blastst
   make xdl1blastst
   make xcl1blastst
   make xzl1blastst

   The flags are very similar to those accepted by the level 2 BLAS timer.
   For usage help, type 
   ./xdl1blastst -h

9. Timing the factorization/solves

   You can time and test the factor and solve of square linear systems by:

   make xsslvtst
   make xdslvtst
   make xcslvtst
   make xzslvtst

   You can vary the type of factor timed by setting the -U flag:
      l/u : perform Cholesky factor of Lower or Upper positive def matrix
      g   : perform a LU factor and solve
      q   : perform a QR factor and solve
   You can test all factors at once using this flag, i.e.
      -U 4 l u g q

   If you want to test/time non-square cases, then you will need to use
   the individal factorization testers described next.

10.Timing ATLAS LU, QR and Cholesky

   The factor timers may be built in ATLAS/bin/<arch> by:

   make xslutst
   make xdlutst
   make xclutst
   make xzlutst

   make xsqrtst
   make xdqrtst
   make xcqrtst
   make xzqrtst

   make xsllttst
   make xdllttst
   make xcllttst
   make xzllttst

   These timers time ATLAS's LU and Cholesky.  If you wish to time LAPACK or
   some other library's LU and Cholesky for comparison purposes, set your
   Make.inc macro FLAPACKlib to point to the appropriate library, and then

   make xslutstF
   make xdlutstF
   make xclutstF
   make xzlutstF

   make xsllttstF
   make xdllttstF
   make xcllttstF
   make xzllttstF

   Both LU and Cholesky testers will run default cases between 100 and 1000
   if no arguments are supplied.  Both will supply terse usage information
   if the -h flag is thrown.  These testers are similar to the level 3 tester
   in the flags they accept (i.e., -m, -M, -n -N, etc. all work the same).  In
   addition, the user may pass:
   -O <norders> <order1>...<orderN> :
      Whether Row-Major or Column-major storage LU/LLt is to be tested 
      (i.e., R and C are the only legal values for orderX).  Note that
      non-ATLAS implementations (such as provided by x<pre>lutstF) can only
      test Column-major arrays (the default).
   -T <thresh> : 
      supply a floating point threshhold the residual must pass.  If set to
      negative, no testing is done (saving time and space).  If set to zero,
      all tests will be flagged as failed.
    The QR tester is similar.

11. More detailed LAPACK timings with latime.
    The factor/solve timers above are relatively crude.  We have a general
    LAPACK timer which is more sophisticated, but does only timing and no
    testing.  The most important targets are:
       x<pre>[s,t]latime
       x<pre>[s,t]latime_al_ab
       x<pre>[s,t]latime_sl_sb
       x<pre>[s,t]latime_fl_fb
    Where:
       <pre> : selectcs type/precision: s/d/c/z
       [s,t]: s: serial, t: threaded
       _al : ATLAS's lapack
       _sl : The system LAPACK
       _fl : F77 reference LAPACK
       _ab : ATLAS's BLAS
       _sb : The system BLAS
       _fb : F77 reference BLAS

    There are many more variants, as you can fin in BLDdir/bin/Makefile.

12. Other timers/testers, including threading.
   ATLAS provides other timer/testers.  In particular, note that the timers
   in the bin directory have versions to test the threaded interface.  To
   build these, one simply adds the "_pt" suffix to the timer/tester name
   (eg., "make xdlutst_pt" rather than "make xdlutst").  Many of these
   timers also have a "_dyn" suffix, which allows you to test against
   the dynamically-linked ATLAS libs, assuming you have built them.
   In addition to the lu and llt tests mentioned above, we also have
   an inversion tester ("make xdinvtst"), an U*U' tester ("make xduumtst").
   and a solver tester ("make xdslvtst").  These work similarly to the
   LU and LLt testers covered above.  The solve tester allows for testing
   LU, Cholesky, and for some cases, QR solves.
@ROUT BootSequence.txt
This file documents the order in which files are generated in ATLAS.  If you
are crazy enough, it can be used as a starting point for building ATLAS
by hand, rather than letting install do it.  This document was out of date
before it was stored to disk, so don't bust a vein if it seems to be wrong.

Stage 1 : System discovery/aux compile
  (1) cd BLDdir/src/auxil/ ; make lib
      HEADERS                       RESULTS
      atlas_type.h                  res/[s,d]MULADD
      atlas_[s,d,c,z]sysinfo.h      res/[s,d]nreg
                                    res/L1CacheSize
Stage 2 : Type-dependent tuning (pre = d, s, z, c)
  NOTE: right now, the Level 3 are tuned first, followed by Level 2
        because the Level 2 can call the Level 3 for gemv.  It should be
        the other way around, but it ain't :)
  (1) Run ATLAS/tune/blas/gemm/<arch>/xmmsearch -p <pre>, creating
      BLDdir/include/<pre>mm.h & ATL_<pre>NCmm.h, and 
      res/:
         dgMMRES.sum : generated NBmm kernel results
         dMMKSSE.sum : results of search of Chad Zalkin's SSE generator
         deMMRES.sum : best of external searches
         dMMRES.sum  : generated & user NBmm kernel results
         dClean[M,N,K] : generated cleanup results
         duMMRES : User-supplied kernel NBmm results
         duClean[M,N,K]: Best user-supplied cleanups
         duClean[M,N,K]F : User supplied cleanups that beat generated cases
         dbest[N,T][N,T]_0x0x0: best no-copy case with no fixed loop dimension
         dbest[N,T][N,T]_0x0x<nb>: best no-copy case with M and N loop 
            parameters variable, but K-loop fixed at <nb>
         dbest[N,T][N,T]_<nb>x<nb>x<nb>: best no-copy case with all loop
            dimensions fixed to <nb>
  (2) if first precision, run BLDdir/tune/blas/gemm/x<pre>findCE,
      creating BLDdir/include/atlas_cacheedge.h
  (3) Run BLDdir/tune/blas/gemm/x<pre>Run_tfc, creating
      BLDdir/include/<pre>Xover.h
  (4) GEMV tune, creating BLDdir/include/atlas_<pre>mv.h,
      atlas_<pre>mv[N,T].h
  (5) GER tune, creating BLDdir/include/atlas_<pre>r1.h

Stage 3: General library build
  (1) Finish all compilation
@ROUT TroubleShoot.txt
This file is rudementary and out of date.  See ATLAS/doc/atlas_install.pdf
for more accurate information.

You should always first check the ATLAS errata file at:
   http://math-atlas.sourceforge.net/errata.html
This file contains info about any known bugs and their fixes, compiler errors
that effect ATLAS, etc.


********************************* CONFIG **************************************
If your configure command fails because it can't compile config.c, you may
need to point configure at your ANSI C compiler (usually gcc).  Add the flags 
   --cc=<ANSI C Compiler> --cflags='<flags>'
If you need to throw a flag to cause your compiler to assume ANSI C, include
this as well.  For instance, on an old HP systems I would pass:
   --cc=cc --cflags='-Aa'
This assumes you understand configure and what it is doing, as explained in 
   ATLAS/doc/atlas_install.pdf

******************************** INSTALL **************************************
Most problems occur during installation.  If you have built the library as
recommended in atlas_install.pdf, a complete log of the installation process
will have been kept in BLDdir/bin/INSTALL_LOG.  If an error occurred which
prevented installation from completing, this directory should contain a file
ERROR.LOG, which provides some information, and perhaps points to another log
file where more details are available.  Typical problems would be invalid
compilers, compile flags, out of disk space, etc.

The user should examine the indicated log files for error messages.  If install
does not point the user at a specific log file, do an ls -l, and examine
the newest file aside from ERROR.LOG & SUMMARY.LOG.

Under Unix, you may want to do
   fgrep -i error *
in your INSTALL_LOG directory to look for problems (though some errors occur
naturally in an ATLAS install, since ATLAS tests things that are only legal
on some platforms).

If you are able to correct the problem (or it was a one-time thing, for
instance filesystem problems), you can restart the install.  To restart where
you left off, first edit your Make.inc file, and if the INSTFLAG macro contains
the flags '-a 1' change that to '-a 0' (this will prevent ATLAS from
overwriting your intermediate results with the architectural defaults again),
and then issue make in your BLDdir, and the ATLAS build will continue
where it left off before.  If you wish to restart the install from scratch, the
easiest method is to simply do a 'rm -rf BLDdir', and reconfigure in a new
BLDdir.

If the problem is inadequate performance, the file 
   BLDdir/bin/INSTALL_LOG/SUMMARY.LOG
should be examined in detail.  Make sure that ATLAS detected the correct
level 1 cache size, number of registers, etc. 

If after these steps you are unable to fix the problem, you can submit a
support request as discussed here:
   http://math-atlas.sourceforge.net/faq.html#help

Include a thorough description of your system, what problem you are
encountering, what you were doing when it happened, etc.  All questions and
bug reports should minimally include the Make.inc file you were using, and
the contents of your INSTALL_LOG directory.  If ATLAS's install detected the
error, and was not killed, it will have created a file containing all this
information in BLDdir/error_<arch>.tar.bz2.  If it has not, you can create it
from your BLDdir directory with:
   make error_report

MAKE SURE TO ATTATCH THIS ERROR REPORT WHEN REPORTING PROBLEMS!!!

******************************  LINKING  **************************************
If you have missing symbols on link make sure you are linking in all of the
libraries you need.  For instance, a code calling the Fortran77 interface
to the BLAS would need:
   -L$(MY_HOME)/ATLAS/lib/$(MY_ARCH)/ -lf77blas -latlas

The full LAPACK library created by merging ATLAS and netlib LAPACK requires
both C and Fortran77 interfaces, and thus that link line would be:
   -L$(MY_HOME)/ATLAS/lib/$(MY_ARCH)/ -llapack -lf77blas -lcblas -latlas

REMEMBER: Order *is* important, so -latlas -lcblas will *not* work.
@ROUT ChangeLog.txt
This is ATLAS version 3.2, released December 2000.  The highlights of
changes from v3.0Beta are:
  ** SMP support via posix threads for Level 3 BLAS
  ** Addition of infrastructure for contribution of kernels, thus allowing:
     ** SSE support
     ** 3DNow! support
     ** Speedups on ev6x, ev5x, UltraSparcs, IA64, PowerPC archs
  ** Level 1 BLAS tester/timer added
  ** Additional OS and architectural support
  ** Bug fixes and misc. speedups

ATLAS version 3.0Beta, released December 1999.  The highlights of
changes from v2.0 are:
  ** ATLAS now supplies complete BLAS, although some level 1 and 2 BLAS not
     fully optimized on all architectures
  ** Some LAPACK routines explicitly supported (LU, Cholesky and related 
     routines)
  ** Standard C and Fortran77 APIs for all BLAS and provided LAPACK routines;
     C routines support both row- & column-major access
  ** Improved small-case GEMM performance made possible by code generator that
     can generate all transpose cases (and thus avoid data copy), with
     associated speed boost in many Level 3 BLAS routines.
  ** Support for complex matrix multiplication without copying user data
  ** Support for additional looping structures for complex GEMM, providing
     better performance and reducing memory usage for many cases

ATLAS version 2.0, released February 1999.  The highlights of changes
from 1.1 are:
  ** Support for all 4 types/precisions
  ** All Level 3 BLAS routines now supported
  ** Fortran77 is not required for installation
  ** Install & configure steps are now automated & logged
  ** Timer/tester for all Level 3 BLAS now included
  ** C interface to BLAS supported, and tester provided
  ** Improved small-case matrix multiply performance

ATLAS version 1.0, released September 1998.  The highlights of changes
from version 0.1 are:
  ** Support for entire real Level 3 BLAS via the Superscalar gemm-based
     BLAS (written in Fortran77)
  ** Improved matmul generator, including support for explicit
     register blocking in GEMM

First ATLAS release, version 0.1, released December 1997.  Provided:
  ** Optimized, real matrix multiplication
  ** Real GEMM tester/timer
@ROUT LAPACK.txt
ATLAS now includes replacements for the following LAPACK routines:
   ?gesv ?getrf ?getrs
   ?posv ?potrf ?potrs
   ?getri ?trtri
   ?potri ?lauum 
Where ? is replaced with the appropriate data type prefix, d, s, c, or z.

These routines are provided with both C and Fortran77 interfaces.  ATLAS's
LAPACK C interface, like the C interface to the BLAS, accepts both row- and
column-major arrays.  For details on the C interface API, consult the interface
code in
   ATLAS/interfaces/lapack/C/src/

The Fortran77 API is exactly that of LAPACK, and thus ATLAS's LU and Cholesky
routines can simply replace those provided by LAPACK.

************************** COMPILING A FULL LAPACK LIBRARY ********************
ATLAS does not provide a full lapack library.  However, there is a simple way
to get ATLAS to provide its faster LU and Cholesky to the LAPACK library.
This is described in detail in ATLAS/doc/atlas_install.pdf.

If you have already built ATLAS, you can still easily build one monolithic
LAPACK library.  First, obtain the LAPACK src from netlib and build the LAPACK
library as normal.  Then, go to your BLDdir/lib/ directory, and issue the
following commands:
  mkdir tmp
  cd tmp
  ar x ../liblapack.a
  mv <your LAPACK lib & path> ../liblapack.a
  ar r ../liblapack.a *.o
  cd ..
  rm -rf tmp
@ROUT Windows.txt

                               IMPORTANT: 
Windows 95/98/ME does a remarkably poor job of process load balance.  If you
change the focus from the cygnus window, performance will immediately drop by
at least 1/3, and the timings will be inaccurate.  It is recommended that you
leave the focus on the install window throughout the entire install procedure.
This is not necessary for Windows NT/2K/XP.

ATLAS requires unix-style make and /bin/sh commands in order to install on a 
windows system.  A fairly complete unix-style environment is available free of
charge at:
   http://www.cygwin.com/

From this website, you can download the package, get installation instructions,
etc.  You will want to download the "full" version of cygwin, which includes
compilers, shells, make, etc.  Be sure you get all the compilers you are
interested in (ATLAS requires gcc, and you will probably want g77 or gfortran
as well).

The cygwin installation is quite simple, involving downloading an executable
and installing with Windows' usual install procedure (you can remove it from
your machine with Windows' ADD/REMOVE if you later decide you don't want it).

After this is done, simply follow the instructions given in atlas_install.pdf,
running all command in a cygwin window.  By default, ATLAS will be compiled
with the gnu gcc compiler that comes with cygnus.  Gnu gcc provides better
ATLAS performance than does MSVC++, Watcom C, or Intel icl, so we recommend
that you leave gcc as the compiler.  If you need to interoperate with Native
windows compilers like Intel icl or MSVC++, we suggest you build using the
MinGW compilers.  See the install guide for further details, and check
the errata file at:
   http://math-atlas.sourceforge.net/errata.html#WinBuild

@beginskip
Because people often miss them in the install instructions, I repeat two
very important pieces of information about the cygnus install here:

                              (1)
If, after installing cygnus, you get the message:
    Out of environment space
add the line 
    shell=C:\command.com /e:4096 /p
to your c:\config.sys

                              (2)
After installation, ATLAS needs to find /bin/sh, so you should (assuming you
don't already have this directory made):
   mkdir -p /bin
Then, you should copy sh.exe from the cygwin bin directory to this one.
The location of the cygwin bin directory changes depending on where you
did the install, what type of machine you have, and the version of cygnus.
Here is an example:
    /cygnus/cygwin-b20/H-i586-cygwin32/bin
the cygwin-b20 is a version number, so you might see cygwin-b21, if you have
a newer release, for instance.  The i586 refers to your processor, you might
expect to see i386, i486, i586 or i686, for instance.
@endskip

@ROUT DirStruct.txt
***************************** DIRECTORY STRUCTURE ******************************
NOTE: This graphic is *way* out of date (for instance, the pthreads directory is
      not shown), but still gives the general idea, so I leave it in.

The directory structure of ATLAS can be summarized by the following graphic:
      ---------------------------------------------------------
      |       |        |                |          |          |
     bin  interfaces  tune             lib      include      src
              |        |                                      |
              |   -----------------------       ----------------------------
              |   |                     |       |       |     |            |
              |   |                    blas   auxil  testing  |          lapack
              |   |                     |                     |
              |   |      ------------------------------     blas
              |sysinfo   |           |        |       |       |
              |          gemm       gemv     ger     level3   |
              |                                               |
        ----------------------           -----------------------------------
        |                    |           |       |       |      |     |    |
      blas                 lapack      level1  level2  level3  gemm  ger  gemv
        |                    |
    ---------            ---------
    |       |            |       |
   src    testing       src    testing

This directory structure is duplicated in the SRCdir and BLDdir directories,
with SRCdir containing the original source files (obtained from the ATLAS
tarfile) and BLDdir (created by the configure step) containing the generated
libraries, headers, objects, and executables.

A summary of each of the main directories is given below:

** interfaces : The official C and Fortran77 interfaces that ATLAS supplies.
                Users needing to examine the API can go to the appropriate
                src subdirectory.  If it exists, the official API tester is
                available in the appropriate testing subdirectory.
** bin        : ATLAS's user-runnable testers & timers are built here
** lib        : Libraries are compiled by default into this directory
** tune       : The code generators and timing programs that allow ATLAS to
                tune itself to specific architectures are here
** include    : All of atlas's include files.  Architecture-dependent include
                files appear in the appropriate <arch> subdirectory.
** src        : Stores the routines supported by atlas; once optimal cases have
                been found, this is also where the generated code is stored.

In addition to those shown above, the user should be aware of the directories:
   ATLAS/doc                    : ATLAS documentation
   BLDdir/bin/INSTALL_LOG : Log of the build step for each architecture
@ROUT INSTALL.txt
This file is outdated and not very comprehensive.  ATLAS installation is
covered in detail in ATLAS/doc/atlas_install.pdf.

Before doing anything, scope the ATLAS errata file for known errors/problems:
   http://math-atlas.sourceforge.net/errata.html
and apply any bug fixes/workarounds you find there.

Note that the documentation on the website will repeat most of this
information, and will be much more current.  The docs in this tarfile
are here mainly for convenience and for users not connected to the net.
Others should scope the website for the most current documentation:
   http://math-atlas.sourceforge.net/faq.html#doc

If you are a Windows user please read ATLAS/doc/Windows.txt before proceeding.

There are two mandatory steps to ATLAS installation (config & build), as
well as three optional steps (test, time, install) and these steps are
described in detail below.  For the impatient, here is the basic outline:
**************************************************
   mkdir my_build_dir ; cd my_build_dir
   /path/to/ATLAS/configure [flags]
   make              ! tune and compile library
   make check        ! perform sanity tests
   make ptcheck      ! checks of threaded code for multiprocessor systems
   make time         ! provide performance summary as % of clock rate
   make install      ! Copy library and include files to other directories
**************************************************

If you want to build a dynamic/shared library, see below at header:
                       BUILDING DYNAMIC/SHARED LIBRARIES
If you want to build a full LAPACK library (i.e. all of the lapack library,
including those lapack routines not natively provided by ATLAS), see:
                   NOTE ON BUILDING A FULL LAPACK LIBRARY

********** Important Install Information: CPU THROTTLING ***********
Most OSes (including Linux) now turn on CPU throttling for power management
**even if you are using a desktop**.  CPU throttling makes pretty much all
timings completely random, and so any ATLAS install will be junk.  Therefore,
before installing ATLAS, turn off CPU throttling.  For most PCs, you can
switch it off in the BIOS (eg., on my Athlon-64 machine, I can say "No" to 
"Cool and Quiet" under "Power Management").  Most OSes also provide a way
to do switch off CPU throttling, but that varies from OS to OS.  Under Fedora,
at any rate, the following command seemed to work:
     /usr/bin/cpufreq-selector -g performance
On my Core2Duo, cpufreq-selector only changes the parameters of the first CPU,
regardless if which cpu you specify.  I suspect this is a bug, because on
earlier systems, the remaining CPUs were controlled via a logical link to
/sys/devices/system/cpu/cpu0/.  In this case, the only way I found to force
the second processor to also run at its peak frequency was to issue the
following as root after setting CPU0 to performance:
   cp /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor \
      /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor

For non-broken systems, you instead issue the above command with -c <#> appended
to change the performance of each core in turn.  For example, to speedup both
processors of a dual system you would issue:
     /usr/bin/cpufreq-selector -g performance -c 0
     /usr/bin/cpufreq-selector -g performance -c 1

On Kubuntu, I had problems with this not working because scaling_max_freq
was set to the minimal speed.  To fix, I had to first increase the max scaling
frequency, which you can do (as root) by (where <#> below is replaced by each processor
number eg., 0 and 1 for dual processor system):
   cd /sys/devices/system/cpu/cpu<#>/cpufreq
   cp cpuinfo_max_freq scaling_max_freq

In Kubuntu 9.10, the only fix I found was to issue:
   sudo echo "performance" > \
        /sys/devices/system/cpu/cpuX/cpufreq/scaling_governor
Where 'X' is replaced by each of your cpu numbers in turn (eg., if you have
a quad processor, you would issue this command four times, using X=[0,1,2,3]).

Under MacOS or Windows, you may be able to change this under the power settings.
I have reports that issuing "powercfg /q" in cmd.exe under windows will tell
you whether windows is throttling or not.

ATLAS config tries to detect if CPU throttling is enabled, but it may not
always detect it, and sometimes may detect it after you have disabled it.
In the latter case, to force the configure to continue regardless of the
results of the CPU throttling probe, pass this flag to configure:
   -Si cputhrchk 0

********************************** CONFIG *************************************
First, create a directory where you will build ATLAS.  It can be anywhere in
your filesystem, and does not need to be under the ATLAS/ subdirectory 
(though it can be if you like).  In general, giving it a descriptive name
is good, for instance:
   mkdir ATLAS_Linux_P4E ; cd ATLAS_Linux_P4E

From this directory, configure the new directory to build atlas with the
command:
   /path/to/ATLAS/configure [flags]
Obviously, "/path/to/ATLAS" is the full or relative path from where you are
to the directory created by the ATLAS tarfile.  To see a list of available
flags to configure type "path/to/ATLAS/configure --help".  In general, no
flags are required, but there are many useful flags for helping with various
problems, in particular changing compilers, setting 32 or 64 bit libraries,
etc.  To ensure building 32 bit libraries, add the flag -b 32, and -b 64
to force 64 bit libraries (must be using a 64 bit-capable compiler on a
64-bit Operating System).

If the machine you are using is not heavily loaded, then you can vastly
improve the accuracy of ATLAS's timings by using the wall timer rather
than the CPU timer.  If you are on a x86, you can get cycle accurate timings
by throwing the flag:
   -D c -DPentiumCPS=<your Mhz>

So, for my 2.4Ghz machine, I would specify:
   -D c -DPentiumCPS=2400

Under Linux, you can find a decent estimate of your clock rate by 
   cat /proc/cpuinfo

If you can't use the cycle-accurate wall timer, the normal WALL timer
is still much more accurate than the CPU timer, and you can use it by
adding this to configure:
   -D c -DWALL

************ Important Compiler Advice **************
For most systems, ATLAS defaults to using the Gnu compiler collection for
its ATLAS install.  This means configure will automatically search for
either g77/gcc or gfortran/gcc.  If it can't find them, it will typically
stop with an error message.  For some platforms, ATLAS knows good flags
to use for multiple compilers, and so you may get good flags by simply
changing the compiler name.  If this doesn't work, you'll need to specify
both the compiler name and the flags to use.  For the fortran compiler,
you can switch the fortran compiler without performance or install penalty
on all platforms.  To do so, simply add the flags:
  -C if <fortran compiler with path> -F if 'fortran flags'
to the configure command.  If you need to install ATLAS on a platform that
doesn't have a working fortran compiler, you can do so by adding the flag:
   --nof77
instead.  Note that the fortran interface to BLAS and LAPACK cannot be built
without a fortran compiler.

Note that all compilers used in an ATLAS install must be able to interoperate.
For more compiler-controlling flags, add --help to the configure command.

*********** Important CLANG Compiler Advice ***********
I have never succesfully built ATLAS with clang.  Clang produces the wrong
answer on many kernels, and poorer performance than gcc on every kernel
I've timed.  I strongly recommend GNU gcc over Clang/LLVM.

********************************** BUILD **************************************
If config finishes without error, start the build/tuning process by:
   make build
(or just "make")

Install times vary widely, depending on whether ATLAS has architectural 
defaults for your platform, and the speed of your compiler and computer.
Under gcc/linux, an install may take as little as 15 minutes for all four
types/precisions.  On a slow machine lacking architectural defaults, it
However, the user is not required to enter any input during
the build phase, and all operations are logged, so it is safe to start the
install and ignore it until completion.

If you experience problems, read the TROUBLESHOOTING section in 
ATLAS/doc/TroubleShoot.txt.  ATLAS/README provides an index of all
included ATLAS documentation files.

You should then read ATLAS/doc/TestTime.txt for instructions on testing 
and timing your installation.

******************************* SANITY TEST ***********************************
This optional step merely verifies that the built ATLAS libraries are able
to pass basic correctness tests.  The standard BLAS testers (i.e. those
that go with the API, as opposed to those written by the ATLAS group) are
written in Fortran77, and so you will need a Fortran compiler installed to
run them.  If you have no Fortran77, you can amend the directions below by
prepending "C_" to all target names (eg., "make C_test") to run only those
testers that require a C compiler, but note that in so doing you will get
a less rigorously tested library.

you can run all the sequential sanity tests by:
   make check

If you have elected to build the threaded library, you can run the same tests
with the threaded library with:
   make ptcheck

A successful sanity test will dump a lot of compilation to the window, followed
with something like:

===========================================================================
DONE BUILDING TESTERS, RUNNING:
SCOPING FOR FAILURES IN BIN TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        bin/Linux_PIIISSE1/sanity.out
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
8 cases: 8 passed, 0 skipped, 0 failed
4 cases: 4 passed, 0 skipped, 0 failed
DONE
SCOPING FOR FAILURES IN CBLAS TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        interfaces/blas/C/testing/Linux_PIIISSE1/sanity.out | \
                fgrep -v PASSED
make[1]: [sanity_test] Error 1 (ignored)
DONE
SCOPING FOR FAILURES IN F77BLAS TESTS:
fgrep -e fault -e FAULT -e error -e ERROR -e fail -e FAIL \
        interfaces/blas/F77/testing/Linux_PIIISSE1/sanity.out | \
                fgrep -v PASSED
make[1]: [sanity_test] Error 1 (ignored)
DONE
make[1]: Leaving directory `/home/rwhaley/TEST/TEST/ATLAS3.3.15'
===========================================================================

Note that the "Error 1 (ignored)" is coming from grepping for failure, and
grep is saying it doesn't find any . . .

Assuming you have a fortran compiler, you can also run the full ATLAS
testing scripts, which may take over a day to run.  If you have
installed a full LAPACK library, you can also run the standard LAPACK
testers.  Please see "EXTENDED ATLAS TESTING" below for more information.

******************* INSTALLING ATLAS FOR MULTIPLE ARCHITECTURES ***************
You can install ATLAS from the same source tree on multiple machines at once
by simply creating different build directories for each architecture.

********************** BUILDING DYNAMIC/SHARED LIBRARIES **********************
ATLAS natively builds to a static library (i.e. libs that usually end in
".a" under unix and ".lib" under windows).  ATLAS always builds such a library,
but it can also optionally be requested to build a dynamic/shared library
(typically ending in .so for unix or .dll windows and .dylib for OS X).  
To do this for GNU compilers, you typically just need to add
   --shared
flag to your configure line.
If you use non-gnu compilers, you'll need to use -Fa to
pass the correct flag(s) to append to force position independent code for
each compiler (don't forget the gcc compiler used in the index files).
NOTE: Since gcc uses one less int register when compiling with this flag, this
      could potentially impact performance of the architectural defaults,
      but we have not seen it so far.

****************** NOTE ON BUILDING A FULL LAPACK LIBRARY *********************
To build lapack, first download the lapack tarfile from
   www.netlib.org/lapack
Then, pass the flag to configure:
   --with-netlib-lapack-tarfile=/path/to/downloaded/tarfile

***************************** EXTENDED ATLAS TESTING **************************
ATLAS has two extended testers beyond the sanity checks that can be
automatically invoked from the BLDdir.  These tests are longer running and
more complex to interpret than the sanity tests, and so not every user will
want to run them.  They are particularly recommended for installers who wish
to use a developer release for production code.

--------------------------------- full_test -----------------------------------
The first is a set of testing scripts written by Antoine Petitet, that
randomly generate testcases for a host of ATLAS's testers.  This testing
phase may take as long as two days to complete (and almost always takes
at least 4 hours).  To perform this long-running test, simply issue:
   make full_test
If you are logged into the host machine remotely, chances are good your
connection will go down before the install completes.  Therefore, you
should consider running the above command with nohup.

At the completion of the tests, the extensive output files will be searched
for errors (much as with the sanity tests), and the output sent to the screen.
If you have lost this screen of data, you can regenerate it with the command:
   make scope_full_test

Running these tests will create a directory BLDdir/bin/AtlasTest where the
tester resides, and your output files will be stored a $(ARCH) subdir.
If you want to rerun the testers from scratch (rather than just searching
old output), you can simply delete the entire BLDdir/bin/AtlasTest
directory tree, and do "make full_test" again.

----------------------------- lapack_test -------------------------------------
If you have installed the full LAPACK library, then you can run the standard
lapack testers as well.  The command you give is:
   make lapack_test_[a,s,f]l_[ab,sb,fb,pt]
The first choice (choose one of three) controls which LAPACK library macro is
used in the link for testing:

   _l    LINK FOR LAPACK       Make.inc MACRO
   ==    ===================   ==============
   a     ATLAS's LAPACK        $(LAPACKlib)
   s     system LAPACK         $(SLAPACKlib)
   f     F77 reference LAPACK  $(FLAPACKlib)

The second choice (choose one of three) controls which BLAS macros are
used in the link for testing:
  _b/pt  LINK FOR BLAS           Make.inc MACRO
  ====   =====================   =========================================
  ab     ATLAS BLAS              $(F77BLASlib) $(CBLASlib) $(ATLASlib)
  sb     system BLAS             $(BLASlib)
  fb     F77 reference BLAS      $(FBLASlib)
  pt     ATLAS' threaded BLAS    $(PTF77BLASlib) $(PTCBLASlib) $(ATLASlib)

Not all of these combinations will work without user modification of Make.inc.
You will need to fill in values for
   $(BLASlib)
   $(SLAPACKlib)
   $(FLAPACKlib)
if you want to run the lapack tester against these libraries.

Usually, you will want to test your newly install ATLAS LAPACK & BLAS:
   make lapack_test_al_ab

As before, once the testing is complete, you will get the output of a search
for errors though all output files, and you can search them again with:
   make scope_lapack_test_al_ab

Unfortunately, the lapack testers always show errors on almost all platforms.
So, how do you know if you have a real error?  Real errors will usually
have residuals in the 10^6 range, rather than O(1) (smaller residuals mean
less error).  If you are unsure, the best way is to contrast ATLAS with an
all-F77 install:
   make lapack_test_fl_fb
(To run this test, you will have to build a stock netlib LAPACK library,
and fill out Make.inc's FLAPACKlib macro appropriately.)  You can then see
how the errors reported by ATLAS stack up against the all-F77 version:
if they  are roughly the same, then you are usually OK.

All the lapack testers create a directory BLDdir/bin/LAPACK_TEST.  For
each test you run there will be a subdirectory
   LAOUT_[A,S,F]L_[AB,SB,FB,PT]
where all your output files will be located.  Additionally, the results
of the scope (search for error) will be stored in 
   BLDdir/bin/LAPACK_TEST/SUMMARY_<lapack>_<blas>

Therefore, a typical round of testing might be:
   make lapack_test_al_ab
   make lapack_test_fl_fb
   # compare SUMMARY_al_ab with SUMMARY_fl_fb to check for error
   make lapack_test_al_pt
   # compare SUMMARY_al_pt with SUMMARY_fl_fb to check for error in parallel lib

If you had an error, you might want to be sure the error was in ATLAS's BLAS
and not lapack, so you could do "make lapack_test_fl_ab", and see if the
error went away.  If you filled in the GotoBLAS for the SLAPACKlib & BLASlib
macros, you could scope the error properties of Goto's BLAS and LAPACK.
Many system/vendor LAPACK/BLAS do not provide all of the routines required
to run the LAPACK testers, and some ATLAS testers call ATLAS internal
routines.  Therefore, the safest thing if you have missing symbol errors
when building system/vendor tests, is to use ATLAS to pick up any missing
symbols.  For instance, here is an example Make.inc output that makes all of
ATLAS testers work with the GotoBLAS on my Athlon-64 workstation:
   BLASlib = /opt/lib/libgoto_opteronp-r1.26.a \
             $(F77BLASlib) $(CBLASlib) $(ATLASlib)
   SLAPACKlib = /opt/lib/libgoto_opteronp-r1.26.a $(FLAPACKlib)


@ROUT LibReadme.txt
***************************** FILE DESCRIPTIONS *******************************
The files in this archive are:

Make.inc      : The Make include file used to build these libs
SUMMARY.LOG   : The SUMMARY.LOG created by atlas_install.  Provides further
                information about the installation machine.
cblas.h       : The C header file for the C interface to the BLAS.
clapack.h     : The C header file for the C interface to LAPACK.
liblapack.a   : The serial LAPACK routines provided by ATLAS.
libcblas.a    : The ANSI C interface to the BLAS.
libf77blas.a  : The Fortran77 interface to the BLAS.
libatlas.a    : The main ATLAS library, providing low-level routines for all
                interface libs.

Your archive may also contain additional libraries, if it has parallel thread
support.  These optional libs are:

libptcblas.a    : The ANSI C interface to the threaded (SMP) BLAS.
libptf77blas.a  : The Fortran77 interface to the threaded (SMP) BLAS.
libptlapack.a   : The parallel LAPACK routines provided by ATLAS.

********************************* LINKING *************************************
When linking, remember that order is important.  So, if you want uniprocessor
libs, your link line would contain IN THIS ORDER:
   -LLIBDIR -llapack -lcblas -lf77blas -latlas 
And if you want to utilize an SMP version, it would be:
   -LLIBDIR -lptlapack -lptcblas -lptf77blas -latlas 

NOTE: On Apple's OS X, the above won't work, since system directories are
searched before the -L directories.  OS X includes ATLAS internally, so
the above link line will always get you OS X's libs instead of the ones
that you have built.  The easiest solution is to explicitly link to each
library using the full path, rather than using the -L/-l combo.

************************** GETTING A FULL LAPACK LIB **************************
To get a full FORTRAN implementation of lapack, download netlib lapack
and use the --with-netlib-lapack-tarfile option discussed in the installation
guide.
@ROUT syscmp.tex
@BEGINPROC typecharts chname chname2 label
\begin{figure}
\begin{minipage}[t]{3.0in}
   @define lab @(d) Double precision complex@
   @define lab @(c) Single precision complex@
   @define lab @(b) Double precision real@
   @define lab @(a) Single precision real@
   @whiledef pre z c d s
\includegraphics[scale=0.50,trim=0 20 0 0]{charts/@(pre)@(chname)}
\centerline{@(lab)}
\vspace*{0.02in}

      @undef lab
   @endwhile
\end{minipage}
\hfill
\begin{minipage}[t]{3.0in}
   @define lab @(h) Double precision complex@
   @define lab @(g) Single precision complex@
   @define lab @(f) Double precision real@
   @define lab @(e) Single precision real@
   @whiledef pre z c d s
\includegraphics[scale=0.50,trim=0 20 0 0]{charts/@(pre)@(chname2)}
\centerline{@(lab)}
\vspace*{0.02in}

      @undef lab
   @endwhile
\end{minipage}
@ifdef caption
\caption{@(caption)}
@undef caption
@endifdef
\label{@(label)}
\end{figure}
@ENDPROC
\documentclass[11pt]{article}

\usepackage{url}
\usepackage{fixltx2e}
%\usepackage{stfloats}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage[caption=false,font=footnotesize]{subfig}

\newcommand{\Wskip}[1]{ }
\newcommand{\Wceil}[1]{\lceil #1 \rceil}
\newcommand{\Wfloor}[1]{\lfloor #1 \rfloor}

\newenvironment{routdef}[1]
{
   \begin{list}{BLANK}
   {
      \setlength{\parsep}{0in}
      \setlength{\itemsep}{.01in}
      \setlength{\partopsep}{0in}
      \setlength{\topsep}{0.1in}
      \setlength{\labelsep}{0in}
      \setlength{\labelwidth}{#1in}
      \setlength{\leftmargin}{#1in}
   }
} {\end{list}}
\newcommand{\rditem}[2]{\item[#1\hfill(~]#2 )}



\textwidth=6in
\textheight=8.7in
\hoffset = -.6in
\voffset = -.6in

\usepackage{fancyhdr}
\pagestyle{fancy}
\lfoot{}
\cfoot{}
\rfoot{}

\begin{document}
\headheight=25.3pt

\begin{titlepage}
\title{ATLAS timing report}
\vspace{.4in}
\author
{
 R. Clint Whaley \thanks { {\tt rwhaley@users.sourceforge.net}, 
 {\tt www.cs.utsa.edu/$\sim$whaley}}
}
\end{titlepage}
\maketitle

\fancypagestyle{plain}{}
%\lhead{\footnotesize \bf ATLAS Installation Guide}}
%\chead{\footnotesize \bf ATLAS Installation Guide}
%\rhead{\footnotesize CONTENTS}

%\fancypagestyle{plain}{\lhead{\bf University of Texas at San Antonio,
%    Department of Computer Science, Technical Report CS-TR-2008-002}\chead{}\rhead{}}
\begin{abstract}
This is an auto-generated timing report skeleton, made to be filled out
with commentary after an ATLAS install.
\end{abstract}

\newpage
\headheight=12.5pt
%\lhead{\footnotesize \bf UTSA/CS Technical Report}
%\chead{\footnotesize \bf CS-TR-2008-002}
\rhead{\footnotesize CONTENTS}
\begin{small}
\tableofcontents
\end{small}
%\listoftables
%\listoffigures

\newpage
\setcounter{page}{1}
%\lhead{\footnotesize \bf UTSA/CS Technical Report}
%\chead{\footnotesize \bf CS-TR-2008-002}
\rhead{{\footnotesize\bf Whaley}~~~~~~\thepage}
\section{BLAS performance}

\subsection{Level 1 BLAS}
Not yet autotimed, not sure worth it anyway.

\subsection{Level 2 BLAS}
Not yet autotimed.

\subsection{GEMM}
Need to survey square and rank-K update here.
Need to build a chart that shows square and rank-K update for ATLAS \& sys
on same chart!

\subsection{Other Level 3 BLAS}
Not yet autotimed.

\section{LAPACK performance}

Figure~\ref{fig-mmla} shows the MFLOPS achieved for serial square GEMM,
and the LU, QR and Cholesky factorizations, while Figure~\ref{fig-mmla_pt}
charts the same data for parallel operations.
Figures~\ref{fig-pcmm} and~\ref{fig-pcmm_pt} show this same data, where
@define caption  @Serial Factorization Summation for ATLAS (left) and SYSTEM (right) in MFLOP.@
@CALLPROC typecharts mmla_atl.eps mmla_sys.eps fig-mmla
@define caption  @Parallel Factorization Summation for ATLAS (left) and SYSTEM (right) in MFLOP.@
@CALLPROC typecharts mmla_atl_pt.eps mmla_sys_pt.eps fig-mmla_pt

@define caption @Serial Factorization as a percentage of square GEMM speed for ATLAS (left) and SYSTEM (right).@
@CALLPROC typecharts pcmm_atl.eps pcmm_sys.eps fig-pcmm
@define caption @Parallel Factorization as a percentage of square tGEMM speed for ATLAS (left) and SYSTEM (right).@
@CALLPROC typecharts pcmm_atl_pt.eps pcmm_sys_pt.eps fig-pcmm_pt

\clearpage
\subsection{LU in detail}
@define caption @ATLAS vs SYS Medium range serial LU, serial (left) parallel (right).@
@CALLPROC typecharts lalusys_med.eps lalusys_med_pt.eps fig-lalu_med
\subsubsection{Small Problems}
@define caption @ATLAS vs SYS tiny range serial LU, serial (left) parallel (right).@
@CALLPROC typecharts lalusys_tiny.eps lalusys_tiny_pt.eps fig-lalu_tiny
\clearpage

\subsection{QR in detail}
@define caption @Serial QR variant overview for ATLAS (left) and SYSTEM (right)@
@CALLPROC typecharts laqrs_atl.eps laqrs_sys.eps fig-laqrs
@define caption @Parallel QR variant overview for ATLAS (left) and SYSTEM (right)@
@CALLPROC typecharts laqrs_atl_pt.eps laqrs_sys_pt.eps fig-laqrs_pt
\subsubsection{Small Problems}

\clearpage
\subsection{Cholesky in detail}
\subsubsection{Small Problems}
\end{document}
@ROUT atltvecs
NAME
   atltvecs - ATLAS timing vectors and manipulation tools

DESCRIPTION
   ATLAS has testers and timers in the BLDdir/bin directory that output
   results into tabular form, where each row is a given time/test run
   and each column is some piece of info about that run (problem size,
   time taken, MFLOP rate, test result, etc). The output of these
   timers is designed for the human eye, but is not optimized for
   automated analysis. Therefore, ATLAS has a series of tools for
   taking this output, and putting it into a standard machine-friendly
   format called a tvec (timing vector, since that is the most common use).
   Each column in the tester/timer output can be optionally selected to
   be printed to a tvec. Tvecs are stored as flat text so that they
   may be manipulated with standard unix pipes, and utilities like 
   sed(1) and cat(1).

   ATLAS addtionally provides a series of commandline tools that are designed
   to manipulate tvecs from the commandline. Like unix utilities, they
   can be combined with pipes to do complex analysis from the command line
   or shell. These tools may be built in BLDdir/bin by:

      make tvec_all

   See the SEE ALSO section below for a list of the presently supported
   atltvec tools. Manpages are provided describing their basic operation.
   These tools all use a common library of tvec manipulation functions which
   can be found in ATLAS/include/atlas_tvec.h, and so each tool consists
   almost exclusively of a main, PrintUsage, and GetFlags routines. Thus
   adding addtional vector manipulation commands is usually simple, and
   we add new ones when we need them for our own analysis. Note that
   the atltvec tools are not optimized for performance or memory, and in fact
   will read the entire input into memory, so it may be possible to
   overflow them on embedded systems if you try to manipulate huge data sets.
   In such a case, either store the tvecs separately and only combine after
   processing using tveccat(1) at end, or move all output files to a
   workstation, and do the processing there.

EXAMPLE
 Here's an example showing everything from running the timers to getting
 human (or machine)-readable output using the majority of the atltvec tools.
 1. Time ATLAS's Upper Cholesky (UtU) factorization for various sizes,
 and modify the output with a line to tell tvecget(1) when to stop reading:
   
  ./xdslatime_al_ab -R 1 potrf -U 1 u -N 20 100 20 -# 8 \\
      > res/tutu.out
  echo "*** END LABEL=_tuu NREP=8" >> res/tutu.out
  ./xdslatime_al_ab -R 1 potrf -U 1 u -N 200 2000 200 -# 3 \\
      > res/mutu.out
   echo "*** END LABEL=_muu NREP=3" >> res/mutu.out
   ./xdslatime_al_ab -R 1 potrf -U 1 u -N 4000 6000 2000 -# 2 \\
      > res/lutu.out
   echo "*** END LABEL=_luu NREP=2" >> res/lutu.out

 2. Translate timings to tvecs:

  cat res/[l,t,m]utu.out | ./tvecget -c "test me!" -H 2 N MFLOP \\
                                     -o t0.tv

 3. Calculate statistics on all repeated timings, and compute simple stat
 vectors like max/min/average. This reduces each MFLOP vector to one entry
 per problem size:

  ./tvecreduce -i t0.tv -o t1.tv -R 3 N_tuu N_muu N_luu \\
               -C 3 MFLOP_tuu MFLOP_muu MFLOP_luu

 4. Get rid of all tvecs except N_luu and MFLOP_luu_max, but join them
 into vectors that span the entire (small-medium-large) range first:

  ./tvecjoin -i t1.tv -o t0.tv \\
      -J 3 N_luu MFLOP_luu_max N_tuu MFLOP_tuu_max N_muu MFLOP_muu_max

 5. Change MFLOP value to percentage of machine peak on my 26.4 GFLOP desktop:
  
  ./tvecscale -i t0.tv -o t1.tv -B 26400 -m 100.0 \\
              -C 1 N_luu -R 1 MFLOP_luu_max

 6. Change vector names to make more sense and reflect changes:

  ./tvecrename -i t1.tv -o t0.tv \\
               -R 2 N_luu N MFLOP_luu_max percPeak_UtU

 7. Print out table with headers:

  ./tvecprint -i t0.tv -C 2 N percPeak_UtU -h 1

EXAMPLE WITH PIPES
 Steps 2-7 can be done with one command:

  cat res/[l,t,m]utu.out | ./tvecget -c "test me!" -H 2 N MFLOP | \\
   ./tvecreduce -R 3 N_tuu N_muu N_luu \\
                -C 3 MFLOP_tuu MFLOP_muu MFLOP_luu | \\
   ./tvecjoin -J 3 N_luu MFLOP_luu_max N_tuu MFLOP_tuu_max \\
                 N_muu MFLOP_muu_max | \\
   ./tvecscale -B 26400 -m 100.0 -C 1 N_luu -R 1 MFLOP_luu_max | \\
   ./tvecrename -R 2 N_luu N MFLOP_luu_max percPeak_UtU | \\
   ./tvecprint -C 2 N percPeak_UtU -h 1

EXAMPLE OUTPUT
 On my machine, I get (ignore the first line):

  Line that exists to make man format correctly
           N    percPeak_UtU            
          20    2.858106e+00    
          40    7.340076e+00    
          60    1.187788e+01    
          80    1.561064e+01    
         100    1.803848e+01    
         200    3.227731e+01    
         400    4.720000e+01    
         600    5.552538e+01    
         800    6.126848e+01    
        1000    6.538731e+01    
        1200    6.827523e+01    
        1400    7.051701e+01    
        1600    7.182420e+01    
        1800    7.356534e+01    
        2000    7.491045e+01    
        4000    8.214818e+01    
        6000    8.508492e+01    

 * I got 85% of peak for N=6000, and only 28.5% for N=200

SEE ALSO
  tvecget(1) tvecselect(1) tveccat(1) tvecunify(1) tvecjoin(1) tvecscale(1) 
  tvecreduce(1) tvecrename(1) tvecprint(1)

AUTHOR
   R. Clint Whaley
@ROUT tvecget tveccat tvecjoin tvecscale tvecreduce tvecrename tvecprint @\
      tvecunify tvecselect
@ROUT @push

NAME
@ROUT tvecget
  tvecget - convert a multiple bin/ timing runs to tvec form
@ROUT tvecselect
  tvecselect - selects (wt rename) specified tvecs from multiple files
@ROUT tveccat 
  tveccat - take selected tvecs from multiple tvec files
@ROUT tvecunify
  tvecunify - unify all tvecs with the same name into one tvec
@ROUT tvecjoin 
   tvecjoin - Join non-interlapping ranges into extended vectors
@ROUT tvecscale 
   tvecscal - Scale tvecs by a num / den; num: scalar, den: scalar or tvec
@ROUT tvecreduce 
   tvecreduce - Gets combines or collapses repetitions within vectors.
@ROUT tvecrename 
   tvecrename - Rename tvecs.
@ROUT tvecprint
   tvecprint - Translate tvecs to tabular/CSV/ploticus form
@ROUT @peek

SYNOPSIS
@ROUT tvecget
  tvecget [-i infile] [-o outfile] [-c "commentln"] [-s sepstr]
          [-H # h1 ... hN] [-C # c1 ... cN] [-S begln stride]
@ROUT tvecunify
  tvecunify [-i infile] [-o outfile] [-r 0/1]
@ROUT tvecselect
tvecselect [-i infile] [-o outfile] [-# Nf] [-S N nam1 ... namN] 
           [-R N nam1 rep1 ...namN repN]  [-s N nam1 ... namN]
           [-r N nam1 rep1 ... namN repN]
@ROUT tveccat 
  tveccat [-i infile] [-o outfile] [-# #]
          [-C N nam1 ... namN] [-c N nam1 ... namN]
@ROUT tvecjoin 
  tvecjoin [-i infile] [-o outfile] [-J N rngv1 joiv1 ... rngvN joivN]
@ROUT tvecscale 
  tvecscale [-i infile] [-o outfile] [-b denV] [-B denS] [-m num]
            [-R # nam1 ... namN] [-C # nam1 ... namN]
@ROUT tvecreduce 
  tvecreduce [-i infile] [-o outfile] 
             [-R # nam1 ... namN] [-C # nam1 ... namN]
@ROUT tvecrename 
  renametvecs [-i infile] [-o outfile] [-s suff]
              [-R # nam1 rep1 ... namN repN]
@ROUT tvecprint
  tvecprint [-i infile] [-o outfile] [-C # nam1 ... namN] [-h 0/1]
@ROUT @peek

DESCRIPTION
@beginindent 1 3
@ROUT tvecget
@(@rout) takes the concatonated output of a series of timer runs from
ATLAS's bin/ directory (all outputs must be from same timer) and produces
standard tvecs (timing vectors) from the selected columns of the input. Every
tvec produced will have the label provided by the END statement suffixed to its
original name, to distinguish it from succeeding runs. NREP is an integer
indicating how many times each case was run (so that you can later produce
average or max/min times, etc). In the input, each individual timing run is
ended by (the first * should occur in the first column):

  *** END LABEL=suff NREP=#
@ROUT tvecselect
@(@rout) takes selected tvecs originally from multiple files and puts
then into one. It has two modes of operation, global and local.
Regardless of mode, tvecselect requires the mandatory
flag [-# Nf], where Nf is the number of tvec files that have
been concatonated in the input.

If the global option is selected (using -s), tvecselect looks for those
names in file order, from first file to last, and takes the first such
instance of a name. So, if we are taking two files, the first one of which
has two vectors called MFLOP, while the second has one, -s will take MFLOP
from the first file's first MFLOP vector. Therefore, if you expect tvecs
with repeated names (in either one or multiple files) to be retained,
you will need to use the local option (-S, see below).

The -s flag can optionally be coupled with the -r flag, which tells
select to rename a series of vectors that have already been selected
by -s. For example, -s 2 M MFLOP -r 1 MFLOP MFLOP_QR results in taking
two vectors from the specified file stream, but renaming only MFLOP to MFLOP_QR.

Local mode is selected using -S, which tells tvecselect to take possibly
different tvecs from each input file. Therefore, in local mode
tvecselect expects up to Nf different -S options,
each of which provides the number of tvecs to take from
the respective tvec input. If the number of -S options is less than Nf, 
any remaining files will be completely ignored.
If there are multiple tvecs with the same name that is given to -S, all
such tvecs are selected. 

To rename tvecs in local mode, the -R flag is used. If -R
appears only once, it means that we are renaming only vectors in the first
file. Therefore, in order to rename vectors only in the second input file,
-R 0 must be specified before our second input file's -R, 
to indicate no tvec is renamed from the first input file.
Renaming multiple vectors with the same name will work as long as the -R list
reflects the file order of the tvecs. Therefore, assuming the tvec named
MFLOP is repeated twice in the same file, the arguments
-S 2 M MFLOP -R 2 MFLOP LU_MF MFLOP QR_MF will result in the MFLOP tvec
that comes first in the file being renamed to LU_MF, while the second
tvec's name is changed to QR_MF.
@ROUT tveccat 
@(@rout) takes selected tvecs originally from multiple files and puts
them into one.
For vectors named with the -c command, @(@rout) just takes the first found
tvec of that name, and ignores the rest. For vectors named with -C,
@(@rout) will create a vector of that name for each file. The vector from
the first file will get the original name, while the vector from the second
file will be suffixed with _1, the third file's name will be suffixed
with _2, etc.
@ROUT tvecunify
@(@rout) searches the input for tvecs that have the same name. Any that do
are combined together by replacing all same-named tvecs with a new one
long enough to hold them all. The tvec values are concatonated starting
with the earliest entry in the stream.
If the -r 1 flag is flown, this process is done in reverse-tvec-order
(so the last tvec of with a particular name starts the accretion).
tvecs without repeated names pass through unchanged.
tvecprint will die if two vectors with the same name have different types
or number of repetitions.
@ROUT tvecjoin 
tvecjoin is used to combine timings of differing ranges into one large tvec.
This is often advantageous because you want to run small problems with
high nrep and large problems with low nrep. Then, after you remove the
repetions with tvecreduce, you combine them into full vectors with
tvecjoin. It takes two types of tvecs: range tvecs and data tvecs.
The range tvecs are usually problem size description. Each -J arglist
represents the combining of the specified original tvecs, with joiv1
overwritten at the end with extended vector that will now have the
combined length of all # joined tvecs, and rngv1 overwritten by the combine
ranges. In subsequent -J iterations, joiv1 cannot appear as either a
source or destination, and rngv1 cannot appear as subsequent rngv1 unless
it is a precise match for the prior rnjv1. Further, any subsequent reference
to rngv1 as a source will receive the original
definition that came into the function (so you can join two different
rngv1's with the same range tvec), not the joined one that will be output
at the end of processing. At the end of processing, only the joined
vectors are output (i.e. only those vectors who have been rngv1 or joiv1).

@ROUT tvecscale 
tvecscale scales tvectors by a fraction.
The numerator of the fraction
is the same for all vector elements, and is provided by -m. The denominator
can be provided using -B, which will result in all elements of the
specified vectors being scaled by the ratio of the -m and -B arguments.
However, if the -b flag is thrown instead, the denominator of the scaling
factor comes from the provided tvec. This allows us to compute 
speedup (-m 1.0) or percentage performance (-m 100.0) of two different tvecs.
@ROUT tvecreduce 
tvecreduce is used to remove repetitions from tvecs, while getting some
simple statistics. It will output two types of nrep=1 tvecs: collapsed (-C)
and reduced (-R). Collapsed vectors are formed by simply taking only the
first entry of each repetition, and on output they will have the same
name as they had before collapsing.

For each reduced tvec, tvecreduce creates several new nrep=1 tvecs, that
have standard suffixes added to their names in order to
distinguish them (if you don't like these suffixes, see tvecrename(1)).
Most interesting, it creates vectors suffixed with _max, _min, and _avg
which contains the maximum, minumum or average of all the repetitions.
It also creates a separate vector for each repetition location
(i.e. _0 will have the first timing for each entry, _1 will have the second,
etc). Therefore, no information is lost in this step for reducec tvecs. 
Other tools like
tveccat(1), tvecjoin(1), tvecscale(1) and tvecprint(1) can then be used 
to get rid of any unneeded tvecs.
@ROUT tvecrename 
tvecrename renames tvecs given as arguments to -R, while leaving other
tvecs in the input alone.
@ROUT tvecprint
tvecprint prints all tvecs in the input out into tabular form with tvecs
in columns separated by tabs, which is a format accepted by office as CSV,
as well as ploticus. Columns are typically 12 spaces wide. tvec names
can be optionally printed; the default is not to print the names
(ploticus likes that).
@ROUT @peek
@endindent

@ROUT tvecrename tvecselect
OPTIONS
   -i infile                     Take input from infile, rather than stdin.
   -o outfile                    Write tvecs to outfile, rather than stdout.
@ROUT tvecselect
   -# Nf                         The number of tvec files concatonated in input.
   -S N nam1 ... namN            tvec namelist to take from each respective
                                 file. -S should appear Nf or less times,
                                 can optionally be combined with -R,
                                 and may not used with either -s or -r.
   -R N nam1 rep1 ... namN repN  Vectors with names namI are replaced with
                                 the associated repI string. -R can be used
                                 with -S, but not -s or -r. -R can legally 
                                 appear 0 to Nf times when -S is used, with
                                 each -R renaming tvecs for the associated
                                 tvec input file. N may be supplied as 0,
                                 indicating no renaming for a particular file.
   -s N nam1 ... namN            Name of tvecs that are looked for in all files.
                                 Should appear only once in tvecselect's 
                                 arguments, and cannot be mixed with -R or -S.
   -r N nam1 rep1 ... namN repN  Vectors with names namI are replaced with
                                 associated repI string.
                                 Should appear only once in tvecselect's 
                                 arguments, and cannot be mixed with -R or -S.
@ROUT tvecrename
   -R N nam1 rep1 ... namN repN  Vectors with names namI are replaced with
                                 the associated repI string.
   -s suff                       all vectors get suff suffixed to their names
                                 (including the renamed vectors!). By default
                                 no suffix is added to any name.
@ROUT tvecjoin
OPTIONS
   -i infile                         Take input from infile, rather than stdin.
   -o outfile                        Write tvecs to outfile, rather than stdout.
   -J N rngv1 joiv1 ... rngvN joivN  List of all vectors to join, and the
                                     range vectors that allow them to be sorted.
@ROUT @peek
@ROUT - tvecjoin tvecrename tvecselect
OPTIONS
   -i infile            Take input from infile, rather than stdin.
   -o outfile           Write tvecs to outfile, rather than stdout.
@ROUT tvecget
   -C # c1 ... cN       Grab the indicated columns, with the first column in
                        the ouput numbered as 1 (eg., -N 2 3 5 will convert
                        the third and 5th columns into tvecs).
   -H # h1 ... hN       Same as -C, but you provide the header names of the
                        columns you want (eg., -H 3 M N MFLOP).
   -c "commentln"       Insert comment line at top of tvec file
   -s sepstr            Columns in seperated by this string rather than spaces
   -S begln stride      Skip the first begln - 1 rows, then take the next
                        row, before skipping stride - 1 rows to get to the
                        next line. Settings of 1 1 causes normal behavior,
                        while -S 2 2 would grab only the the even lines.
@ROUT tvecunify
   -r 0/1               Unify tvecs in normal or reverse order
@ROUT tveccat 
   -# N                 The number of tvec files you are concatonating.
   -C N nam1 ... namN   Name of vectors that can be found in multiple files.
                        The vector from the first file with that name will
                        use the original name, while the second file's name
                        will be suffixed with _1, the third file's _2, etc.
   -c N nam1 ... namN   Name of vectors where you want only one copy. The
                        vector retained will come from the first file that
                        contains the selected name (later tvecs of same
                        name will be ignored).
@ROUT tvecscale 
   -m mul               Numerator of scaling factor. Set to 100.0 for
                        percentages, and 1.0 for speedup.
   -B denom             Denominator of scaling factor: elements of the
                        -C tvecs are scaled by (mul / float).
                        This flag overrides -b.
   -b denV              The elements of denV form the denominator for the
                        corresponding elements of the vectors being scaled.
                        This flag overrides -B.
   -R # nam1 ... namN   vectors to scale.
   -C # nam1 ... namN   vectors to keep unchanged.
@ROUT tvecreduce 
   -R # nam1 ... namN   vectors to reduce.
   -C # nam1 ... namN   vectors to collapse.
@ROUT tvecprint
   -C # nam1 ... namN   vectors in the order in which they become tabular
                        columns
@ROUT @peek
EXAMPLE
@ROUT tvecget

   xdmmtst_atl -T 0 -# 4 -N 200 2000 200 > time.out

   echo "*** LABEL=_mm NREP=8" >> time.out

   xdslatime_al_ab -# 3 -R 1 getrf -N 200 2000 200 >> time.out

   echo "*** LABEL=_lu NREP=3" >> time.out

   tvecget -i time.out -H 2 MFLOP N
@ROUT tvecselect
   The following are roughly equivalent:

    cat lu.tv QR.tv | \\
       tvecselect -# 2 -S 2 N MFLOP_LU -R 1 MFLOP_LU LU \\
                  -S 1 MFLOP_QR -R 1 MFLOP_QR QR

    cat lu.tv QR.tv | \\
        tvecselect -# 2 -s 3 N MFLOP_LU MFLOP_QR \\
                        -r 2 MFLOP_LU LU MFLOP_QR QR
@ROUT tveccat 
   cat LU.tvec QR.tvec MM.tvec | tveccat -# 3 -H 2 MFLOP N
@ROUT tvecunify
   tvecunify -r 1 -i in.tv
@ROUT tvecjoin 
   tvecjoin -i small_med_lrg.tvec -J 3 N_lrg MFLOP_lrg N_sm MFLOP_sm N_med MFLOP_med
@ROUT tvecscale 
   tvecscale -i comb.tvec -m 100.0 -b MFLOP_mm -C 1 N -R 2 MFLOP_lu MFLOP_qr
@ROUT tvecreduce 
   tvecreduce -R 1 N -C 3 MFLOP_lu MFLOP_qr MFLOP_mm
@ROUT tvecrename 
   cat lu.tv QR.tv | tvcat -# 2 | tvecrename  -R 2 MFLOP MFLOP_LU MFLOP_1 MFLOP_QR
@ROUT tvecprint
   tvecprint -h 1 -i comb.tvec -C 4 N MFLOP_lu MFLOP_qr MFLOP_mm
@ROUT @pop
BUGS
   http://math-atlas.sourceforge.net/faq.html#help

SEE ALSO
  atltvecs(7) tvecget(1) tvecunify() tveccat(1) tvecselect(1)
  tvecjoin(1) tvecscale(1) tvecreduce(1) tvecrename(1) tvecprint(1)

AUTHOR
@ROUT - tvecselect
   R. Clint Whaley
@ROUT tvecselect
   Md Rakib Hasan
@ROUT !
