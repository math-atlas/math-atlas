@ROUT !
   @define pre @@(@pre)@
   @PRE S C
      @define typ @FLOAT@
      @define sz @4@
   @PRE D Z
      @define sz @8@
      @define typ @DOUBLE@
   @PRE !
@SKIP #define ATL_VLEN @(vl)
@BEGINSKIP
#if !defined(SREAL) && !defined(DREAL) && !defined(SCPLX) && !defined(DCPLX)
   @PRE C `   #define SCPLX 1`
   @PRE S `   #define SREAL 1`
   @PRE D `   #define DREAL 1`
   @PRE Z `   #define DCPLX 1`
#endif
@ENDSKIP
@ifdef ! TRI
   @iexp TRI 0
@endifdef
@SKIP TRI = 1 means lower triangular C (SYRK)
@SKIP SQSYRK:mu==nu, SYRKU: mu/nu unrelated
@iexp SYRKU 0
@iexp SQSYRK 0
@iif TRI = 1
   @iexp SQSYRK @(mu) @(nu) = 
   @iexp SYRKU @(mu) @(nu) !
@endiif
@SKIP TRMM=1,2,3,4; 1=Left Lower, 2=Left Upper, 3=Right Lower, 4=Right Upper
@ifdef ! TRMM
   @iexp TRMM 0
   @iexp TRMML 0
   @iexp TRMMR 0
@endifdef
@iif TRMM ! 0
   @iexp TRMML 3 @(TRMM) <
   @iexp TRMMR 2 @(TRMM) >
@endiif
@iif TRMML ! 0
   @iexp mku @(mu) @(ku) %
   @iexp kmu @(ku) @(mu) %
   @iif mku ! 0
      @iif kmu ! 0
         @abort "mu (@(mu)) must be multiple of or divisible by ku (@(ku))!"
      @endiif
   @endiif
   @ifdef PBINC
      @abort "PBINC cannot be defined!"
   @endifdef
   @define PBINC @0@
   @ifdef PBLHOIST
      @abort "PBLHOIST cannot be defined!"
   @endifdef
   @define PBLHOIST @0@
   @ifdef PBFLD
      @abort "PBFLD cannot be defined!"
   @endifdef
   @define PBFLD @0@
@endiif
@iif TRMMR ! 0
   @iexp nku @(nu) @(ku) %
   @iexp knu @(ku) @(nu) %
   @iif nku ! 0
      @iif knu ! 0
         @abort "nu (@(nu)) must be multiple of or divisible by ku (@(ku))!"
      @endiif
   @endiif
@endiif
@ROUT amm
@beginskip
Should be called with VEC=[NO,MDIM,KDIM], TYPE=[SREAL,DREAL] and 
following defines:
   mu : m (scalar) unrolling
   nu : n (scalar) unrolling
   ku : k (scalar) unrolling
   vl : vector length to use
The following can be optionally defined:
   kb : compile-time constant K loop bound to use
   kp : # of kits to peel, must be a multiple of vku!
   bc : don't define or set to 1 to use ATL_vbcast, 0 to use vld/vsplat
   pf : bit vec describing prefetch strategy
   pfLS : line size to assume for prefetch (64 bytes by default)
   bc : now used a bitvector, default 1, with following meanings:
    BPOS: SET MEANING
      0 : use bcast (else use splat) for B load (ignored for K-vec)
      1 : use only 1 register for B loads (ignored if using splat)
      2 : nnu=1 (else need N-loop)
      3 : nmu=1 (else need M-loop)

pf bit location meanings:
   prefC always done as just next mu*nu block
   pfA/B : can prefetch next mu/nu A/B within K-loop
   nA/nB : can prefetch next block outside K-loop 
   take pf integer bitvec bit/additive means:
      0/1   : prefetch C before K-loop
      1/2   : prefetch next block of A before K-loop
      2/4   : prefetch next block of B before K-loop
      3/8   : prefetch next mu*K iter of A inside K-loop
      4/16  : prefetch next nu*K iter of B inside K-loop
      5/32  : pref of C should use ATL_pfl1 instead of ATL_pfl2
      6/64  : pref of next blk of A should use ATL_pfl1 not ATL_pfl2
      7/128 : pref of next blk of B should use ATL_pfl1 not ATL_pfl2
      8/256 : pref of C should use ATL_pflX instead of ATL_pflX
      9/512 : pref of next blk of A should use ATL_pflX not ATL_pfl2
     10/1024: pref of next blk of B should use ATL_pflX not ATL_pfl2
     11/2048: K-loop pref of A use ATL_pfl1 not ATL_pfl2
     12/4096: K-loop pref of B use ATL_pfl1 not ATL_pfl2
     13/8192: K-loop pref of A use ATL_pflX not ATL_pfl2
    14/16384: K-loop pref of B use ATL_pflX not ATL_pfl2

   We'll put pf bitvec in rout name, and then the search will find that
   we want to pref everything to L1 for small NB, only C &  block of A for
   medium size, and no pref for large, for instance.

During tuning, think about several regions for prefetch:
1. pref pfnA&B to L1:  m*n + 2*k*(m+n) < L1
   -> n^2 + 4n^2 < L2 ==> nb <= sqrt(L1/5)
2. pref B to L1, A to L2: m*n + 2*k*n + m*k < L1
   -> n^2 + 2n^2 + n^2 < L1 ==> nb <= sqrt(L1/4)
3. pref A&B to L2 so long as all 5 blocks fit (L2 size not known)
4. pref only one of nA/B to L2
5. No prefetch of next blocks (maybe internal prefetch)
@endskip
@SKIP extract info from bc, then set it to bcast value
@ifdef ! bc
   @iexp bc 1
@endifdef
@skip if ((bc&1) == 0 && (bc&2) == 2) bc ^= 2
@iif @iexp @(bc) 1 & 0 = @(bc) 2 & 2 = &
   @iexp bc @(bc) 2 ^
@endiif
@iexp B1R @(bc) 2 & 0 !
@iexp DONLOOP @(bc) 4 & 0 =
@iexp DOMLOOP @(bc) 8 & 0 =
@iexp bc @(bc) 1 &
@print bc=@(bc) B1R=@(B1R) DO_N,M=@(DONLOOP),@(DONLOOP)
@SKIP KVEC & UNVEC can't use splat, so define bcast!
@VEC KDIM NO
@ifdef bc
   @undef bc
@endifdef
@iexp bc 0 1 +
@VEC MDIM
@skip *********************** HIL specific *******************
@ifdef vl
   @iif vl ! 0
      @iif vl ! 1
         @ifdef mu
         @skip "HIL must be scalar, so we multiply mu with vl and make vl 1"
            @skip @iexp mu @(mu) @(vl) *
            @skip @print "Forcing vlen as 1... fko will vectoried the serial kernel"
            @iexp vl 0 1 +
         @endifdef
      @endiif
   @endiif
@endifdef
@skip ********************************************************
@ifdef ! bc
   @iexp bc 0 1 +
@endifdef
@VEC !
@ifdef ! pf
   @define pf @1@
@endifdef
@ifdef ! pfLS
   @define pfLS @64@
@endifdef
@iif pfLS = 0
   @define pfLS @64@
@endiif
@iexp pfLS @(sz) @(pfLS) /
@iexp kk @(pf) 32 &
@iif kk ! 0
   @skip @define pfC @ATL_pfl1W@
   @define pfC @_PREFETCHW(0@
@endiif
@iexp kk @(pf) 256 &
@iif kk ! 0
   @skip @define pfC @ATL_pflXW@
   @define pfC @_PREFETCHW(2@
@endiif
@ifdef ! pfC
   @skip @define pfC @ATL_pfl2W@
   @define pfC @_PREFETCHW(1@
@endifdef
@iexp kk @(pf) 64 &
@iif kk ! 0
   @skip @define pfA @ATL_pfl1R@
   @define pfA @_PREFETCHR(0@
@endiif
@iexp kk @(pf) 512 &
@iif kk ! 0
   @skip @define pfA @ATL_pflXR@
   @define pfA @_PREFETCHR(2@
@endiif
@ifdef ! pfA
   @skip @define pfA @ATL_pfl2R@
   @define pfA @_PREFETCHR(1@
@endifdef
@iexp kk @(pf) 128 &
@iif kk ! 0
   @skip @define pfB @ATL_pfl1R@
   @define pfB @_PREFETCHR(0@
@endiif
@iexp kk @(pf) 1024 &
@iif kk ! 0
   @skip @define pfB @ATL_pflXR@
   @define pfB @_PREFETCHR(2@
@endiif
@ifdef ! pfB
   @skip @define pfB @ATL_pfl2R@
   @define pfB @_PREFETCHR(1@
@endifdef
@iexp kk @(pf) 8 &
@iif kk ! 0
   @skip @define pfAk @ATL_pfl2R@
   @define pfAk @_PREFETCHR(1@
   @iexp kk @(pf) 2048 &
   @iif kk ! 0
      @undef pfAk
      @skip @define pfAk @ATL_pfl1R@
      @define pfAk @_PREFETCHR(0@
   @endiif
   @iexp kk @(pf) 8192 &
   @iif kk ! 0
      @undef pfAk
      @skip @define pfAk @ATL_pflXR@
      @define pfAk @_PREFETCHR(2@
   @endiif
@endiif
@iexp kk @(pf) 16 &
@iif kk ! 0
   @skip @define pfBk @ATL_pfl2R@
   @define pfBk @_PREFETCHR(1@
   @iexp kk @(pf) 4096 &
   @iif kk ! 0
      @undef pfBk
      @skip @define pfBk @ATL_pfl1R@
      @define pfBk @_PREFETCHR(0@
   @endiif
   @iexp kk @(pf) 16384 &
   @iif kk ! 0
      @undef pfBk
      @skip @define pfBk @ATL_pflXR@
      @define pfBk @_PREFETCHR(2@
   @endiif
@endiif
@SKIP npfC = (pf&1) * ((mu*nu + pfLS -1) / pfLS)
@iexp npfC 1 @(pf) & @(pfLS) @(nu) @(mu) * @(pfLS) + -1 + / *
@iexp npfA @(pfLS) 1 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npfB @(pfLS) 2 @(pf) r 1 & @(mu) @(nu) * * /
@iexp npf @(npfC) @(npfA) +
@iif npfA ! 0
   @iexp npfA @(npfA) @(npfC) +
@endiif
@iif npfB ! 0
   @iexp npf @(npf) @(npfB) +
   @iexp npfB @(npf) 0 +
@endiif
@skip bc = (bc != 0 || (vl < 2) || nu%vl != 0);
@iexp bc 0 @(bc) ! 2 @(vl) < | @(vl) @(nu) % 0 ! |
@iif TRI = 1
   @VEC KDIM
      @iif ku ! vl
         @abort "ku (@(ku)) must equal vlen (@(vl))!"
      @endiif
   @VEC MDIM
      @iif ku > 4
         @abort "ku must be <= 4, but it is @(ku)!"
      @endiif
   @VEC !
@endiif
@beginskip 
#ifndef TYPE
   #define TYPE @(typ)
#endif
@endskip
@SKIP #include "atlas_simd.h"
@iexp pf @(pf) 31 &
@iif pf ! 0
#include "atlas_prefetch.h"
@endiif
@ifdef ! vl
   @abort "vl must be defined!"
@endifdef
@ifdef ! mu
   @abort "mu must be defined!"
@endifdef
@ifdef ! nu
   @abort "nu must be defined!"
@endifdef
@ifdef ! ku
   @abort "ku must be defined!"
@endifdef
@ifdef ! kb
   @define kb @0@
@endifdef
@iif kb = 0
   @addkeys KCON=no
@endiif
@iif kb ! 0
   @addkeys KCON=yes
@endiif
@iexp vku @(ku) 0 +
@iexp vmu @(mu) 0 +
@iexp vnu @(nu) 0 +
@VEC MDIM
   @iexp vmu @(vl) @(mu) /
   @iexp kk @(vmu) @(vl) *
   @iif kk ! mu
      @abort "MU=@(mu) illegal with VLEN=@(vl)!"
   @endiif
@VEC KDIM
   @iexp vku @(vl) @(ku) /
   @iif @iexp @(vku) @(vl) * @(ku) !
      @abort "KU=@(ku) illegal with VLEN=@(vl)!"
   @endiif
@VEC NO
   @iif vl ! 1
      @abort "vl must be 1 for scalar code!"
   @endiif
@VEC !
@ifdef ! kp
   @VEC KDIM `@define kp @@(vl)@`
   @VEC ! KDIM `@define kp @1@`
@endifdef
@VEC KDIM 
   @iexp vkp @(vl) @(kp) /
   @iexp kk @(vkp) @(vl) *
   @iif kk != ku
      @abort "KP (@(kp)) must be a multiple of ku*VLEN (@(ku)*@(vl))"
   @endiif
@VEC ! KDIM
   @define vkp @@(kp)@
@VEC !
@define KB @K@
@ifdef ! kp
   @VEC KDIM
      @define kp @@(vl)@
   @VEC ! KDIM
      @define kp @@(vku)@
   @VEC !
@endifdef
@iif vkp < 1
   @abort "K-peel (kp) must be >= 1!"
@endiif
@iexp kk @(ku) @(kp) /
@iexp kk @(kk) @(ku) *
@iif kp ! kk
   @abort "K-peel (@(kp)) must be a multiple of KU=@(ku)!"
@endiif
@VEC KDIM
@SKIP FOR KVEC, kb = CEIL(kb/vlen)*vlen
@iif kb ! 0
   @iexp kb @(vl) @(kb) @(vl) -1 + + / @(vl) *
   @undef KB
   @define KB @@(kb)@
   @iif @iexp @(vku) @(kb) %
      @abort "VKU=@(vku) must be multiple of @(kb)!"
   @endiif
@endiif
@VEC !
@iif kb > 0
@echo @define ATL_KBCONST @1@
@echo @define ATL_MM_KB @@(kb)@
@endiif
@iif kb = 0
@echo @ifdef ! ATL_MM_KB 
@echo    @define MMKB @0@
@echo @endifdef
@echo @ifdef  ATL_MM_KB 
@echo    @define MMKB @1@
@echo @endifdef
@echo @iif MMKB = 0
@echo    @ifdef KB
@echo       @iif KB > 0
@echo          @define ATL_KBCONST @1@
@echo          @define ATL_MM_KB @@(KB)@
@echo       @endiif
@echo       @iif KB { 0
@echo         @define ATL_KBCONST @0@
@echo         @define ATL_MM_KB @K@
@echo       @endiif
@echo    @endifdef
@echo    @ifdef ! KB
@echo      @define ATL_KBCONST @0@
@echo      @define ATL_MM_KB @K@
@echo    @endifdef
@echo @endiif 
@echo @iif MMKB = 1
@echo   @iif ATL_MM_KB > 0
@echo       @define ATL_KBCONST @1@
@echo   @endiif
@echo   @iif ATL_MM_KB { 0 
@echo      @undef ATL_MM_KB
@echo      @define ATL_MM_KB @K@
@echo      @define ATL_KBCONST @0@
@echo   @endiif
@echo @endiif
@endiif
@iif TRMML ! 0
@BEGINSKIP
*  This func is used to increment pB (and reload all vBs for specific case) at 
*  the peeled last K-iteration for TRMML. Normally, it's done before the load 
*  of pB[0]. So, it is called from different places from where load of pB[0] is
*  essentially generated.
@ENDSKIP
@BEGINPROC lKpBinc
   @define j @0@ 
   @define kk @0@ 
   @iif PBLHOIST ! 0
      @ifdef LAST_ITER
      @BEGINSKIP 
      *  TRMM=2: Left upper
      *  incBn is incremented by mu*nu at the end of each NLOOP. 
      *  so, it will load invalid memory since incBn is getting large. 
      *  Looks like: we will need mu*nu*nnus extra memory to overcome this. 
      *  for now, I'm adding a branch (which is not a great choice, but we have
      *  branch for KDONE at NLOOP anyway). 
      @ENDSKIP
      @iif TRMM = 2 
      if (j != nnus-1) 
      @endiif
         pB += incBn;
         @iif PBFLD ! 0
            @iexp j 0 0 +
            @iwhile j < @(vnu)
               @iexp kk @(vl) @(j) /
            @skip ATL_vld(vB@(kk), pB+@(j));
            vB@(kk) = pB[@(j)];
               @iexp j @(j) @(vl) +
            @endiwhile
         @endiif 
         @undef LAST_ITER 
      @endifdef
   @endiif
   @undef kk
   @undef j
@ENDPROC
@BEGINSKIP
*  this proc is used in TRMML to increment pB  (and reload VBs) when K (KK) 
*  is too small to execute kloop. We need to jump to KDONE at the end
@ENDSKIP
@SKIP ****************** to pB inc and reload before Kloop to goto kdone
@BEGINPROC toKdone
   @iif PBLHOIST ! 0
         @SKIP {
      @iif TRMM = 1
            @SKIP if (incBn)
            IF (incBn = 0) GOTO LB_TOK_BN;
      @endiif
      @BEGINSKIP 
         *  TRMM=2: Left upper
         *  incBn is incremented by mu*nu at the end of each NLOOP. 
         *  so, it will load invalid memory since incBn is getting large. 
         *  Looks like: we will need mu*nu*nnus extra memory to overcome this. 
         *  for now, I'm adding a branch (which is not a great choice, but we 
         *  have branch for KDONE at NLOOP anyway). 
      @ENDSKIP
      @iif TRMM = 2
            if (incBn && j != nnus-1)
      @endiif 
            @SKIP {
      @iif PBINC = 1
               pB += (incBn-@(incBk));
               @callproc ReloadlB
               /*pB += @(incBk);*/
      @endiif
      @iif PBINC = 0
               pB += incBn;
               @callproc ReloadlB
      @endiif 
            @SKIP }
            goto KDONE;
         @SKIP }
   @endiif
   @iif PBLHOIST = 0
         goto KDONE;
   @endiif
@ENDPROC
@endiif 
@VEC ! NO
@echo @ifdef ! BETA1
@echo    @ifdef ! BETA0
@echo        @define ibet @-1@
@echo    @endifdef
@echo @endifdef
@echo @ifdef BETA1
@echo     @define ibet @1@
@echo @endifdef
@echo @ifdef BETA0
@echo    @define ibet @0@
@echo @endifdef
@BEGINPROC vbeta p_ idx d_ t_
@echo  @iif ibet ! 0 
         @(t_) = @(p_)[@(idx)]; 
@echo    @iif ibet = 1
         @(d_) = @(d_) + @(t_);
@echo    @endiif
@echo    @iif ibet = -1
         @(d_) = @(d_) - @(t_);
@echo    @endiif
@echo  @endiif
         @(p_)[@(idx)] = @(d_); 
@ENDPROC
@VEC MDIM
   @iif bc = 0
      @abort "bc can't be 0 since we don't have any explicit splat for fko yet" 
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
      @define j @@
      @define kk @@
@BEGINSKIP
         1-D must be able to do 2 memops/MAC to get peak, and a 2x2 2-D block
         must do a load for every MAC, so there will never be any "holes" to
         do extra memory operations like prefetch or advanced load for these
         cases.  1-D handles this with special code; to create a hole for 2x2
         we therefore don't count the last B load as memory load.  We do:
            IF (vmu != 2 || nu != 2 || i_ == nu-1)
               mo++  /* mo is count of memory ops done with last MAC */
         but this the same as
            mo = mo + 1*(vmu != 2 || nu != 2 || i_ == nu-1)
         which was obvious to you from the line below, of course.
@ENDSKIP
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iexp j @(vl) @(i_) /
         @iexp i_ @(vl) @(j) * @(i_) -
   ATL_vsplat@(i_)(@(d), vB@(j));
@SKIP    if ((i_+1)%vl == 0, add another vector to stack of vBs to load (lb)
         @iexp kk @(vl) 1 @(i_) + %
         @iif kk = 0
@SKIP    Keep macro stack in old->new order by reversing if non-empty
@SKIP    so we can add newest to bottom.
            @whiledef lb
               @define lb2 @@(lb)@
            @endwhile
            @define lb @@(j)@
            @whiledef lb2
               @define lb @@(lb2)@
            @endwhile
         @endiif
         @undef j
         @undef kk
      @endindent
      @ENDPROC
   @endiif
   @iif bc ! 0
      @BEGINPROC ldB spc d i_
      @beginindent 1 @(spc)
         @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
         @iif ib < 0
            @iif i_ ! 0
   @skip ATL_vbcast(@(d), pB+@(i_));
   @(d) = pB[@(i_)];
            @endiif
            @iif i_ = 0
            @SKIP *************************************************************
               @iif TRMML ! 0
                  @callproc lKpBinc
               @endiif
            @SKIP *************************************************************
   @skip ATL_vbcast(@(d), pB);
   @(d) = pB[0];
            @endiif
         @endiif
         @iif ib > -1
            @iif ib ! 0
   @skip ATL_vbcast(@(d), pB+@(ib));
   @(d) = pB[@(ib)];
             @endiif
            @iif ib = 0
            @SKIP *************************************************************
               @iif TRMML ! 0
                  @callproc lKpBinc
               @endiif
            @SKIP *************************************************************
   @skip ATL_vbcast(@(d), pB);
   @(d) = pB[0];
             @endiif
            @iexp ib @(ib) 1 +
         @endiif
      @endindent
      @ENDPROC
   @endiif
@VEC KDIM
@BEGINSKIP
ARGS:
   nv : vvrsum # to use
   nr : actual number of registers remaining to be summed
   ir : base register number (0 <= ir < mu*nu)
ASSUMES: mu, nu, exreg
@ENDSKIP
   @BEGINPROC vvrsum nv nr ir
      @define k @0@
      @define kl @0@
      @define i @0@
      @define j @0@
      @declare "   ATL_vvrsum@(nv)(" y n ");"
         @iexp kl @(ir) @(nr) +
         @iexp k @(ir)
         @iwhile k < kl
            @iexp j @(mu) @(k) /
            @iexp i @(mu) @(k) %
               rC@(i)_@(j)
            @iexp k @(k) 1 +
         @endiwhile
         @iif nr < nv
            @iexp kl @(ir) @(nv) +
            @iwhile k < kl
               @(exreg)
            @iexp k @(k) 1 +
         @endiwhile
         @endiif
      @enddeclare
      @iexp j @(mu) @(ir) /
      @iexp i @(mu) @(ir) %
      @iexp kl @(j) @(mu) *
      @iexp kl @(kl) @(i) +
   @skip ATL_vbeta(pC+@(kl), rC@(i)_@(j));
   @ATL_vbeta(pC, @(kl), rC@(i)_@(j));
   call vbeta pC @(kl) rC@(i)_@(j) rA0
      @undef j
      @undef i
      @undef kl
      @undef k
   @ENDPROC
@VEC KDIM NO
   @BEGINPROC ldB spc d i_
   @beginindent 1 @(spc)
      @iexp i_ @(vl) @(i_) *
      @iexp mo 2 @(vmu) ! 2 @(nu) ! | @(i_) 1 @(nu) - = 1 * @(mo) +
      @iif ib < 0
         @iif i_ ! 0
   @skip ATL_vld(@(d), pB+@(i_));
   @(d) = pB[@(i_)];
         @endiif
         @iif i_ = 0
         @SKIP *************************************************************
            @iif TRMML ! 0
               @callproc lKpBinc
            @endiif
         @SKIP *************************************************************
   @skip ATL_vld(@(d), pB);
   @(d) = pB[0];
         @endiif
      @endiif
      @iif ib > -1 
         @iif ib ! 0
   @skip ATL_vld(@(d), pB+@(ib));
   @(d) = pB[@(ib)];
         @endiif
         @iif ib = 0
         @SKIP *************************************************************
            @iif TRMML ! 0
               @callproc lKpBinc
            @endiif
         @SKIP *************************************************************
   @skip ATL_vld(@(d), pB);
   @(d) = pB[0];
         @endiif
         @iexp ib @(ib) @(vl) +
      @endiif
   @endindent
   @ENDPROC
@VEC NO KDIM
   @define ldB @ATL_vld@
   @iexp bmul @(vl) 0 +
@VEC MDIM
   @define ldB @ATL_vbcast@
   @iexp bmul 1 0 +
@VEC NO
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   #ifdef BETA0
      pC[@(kk)] = rC@(i)_@(j);
   #elif defined(BETA1)
      pC[@(kk)] += rC@(i)_@(j);
   #else
      pC[@(kk)] = rC@(i)_@(j) - pC[@(kk)];
   #endif
            @iexp kk @(kk) 1 +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef j
   @undef i
   @undef kk
   @ENDPROC
@VEC MDIM
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
   @skip ATL_vbeta(pC+@(kk), rC@(i)_@(j));
   @callproc vbeta pC  @(kk)  rC@(i)_@(j) rC@(i)_@(j)m
            @iexp kk @(kk) @(vl) +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef kk
   @undef j
   @undef i
   @ENDPROC
@VEC KDIM
@BEGINSKIP ---------------------------------------
   @BEGINPROC storeC spc
      @define nr @dum@
      @define nf @dum@
      @define k @dum@
      @define ll @dum@
      @define vl2 @dum@

      @beginindent 1 @(spc)
         @iexp nf @(vl) @(mu) @(nu) * / @(vl) *
         @iexp nr @(nf) @(mu) @(nu) * -
         @iexp k 0
         @iwhile k < nf
            @callproc vvrsum @(vl) @(vl) @(k)
            @iexp k @(k) @(vl) +
         @endiwhile
         @iif nr = 1
            @callproc vvrsum 1 1 @(k)
         @endiif
         @iif nr > 1
            @iexp ll @(vl)
            @iwhile nr > 0
               @iexp vl2 2 @(ll) /
            @print nr=@(nr) ll=@(ll) vl2=@(vl2)
               @iif nr > vl2
                  @callproc vvrsum @(ll) @(nr) @(k)
                  @iexp nr 0
               @endiif
               @iif nr } vl2
                  @callproc vvrsum @(vl2) @(vl2) @(k)
                  @iexp nr @(vl2) @(nr) -
                  @iexp k @(k) @(vl2) +
               @endiif
               @iexp ll @(vl2)
            @endiwhile
         @endiif
      @endindent
      @undef k
      @undef nf
      @undef nr
      @undef ll
      @undef vl2
   @ENDPROC
@ENDSKIP 
   @skip *************************** new KDIM storeC for HIL *************
   @BEGINPROC storeC spc
   @define kk @dum@
   @define i @dum@
   @define j @dum@
   @beginindent 1 @(spc)
      @iexp kk 0 0 +
      @iexp j 0 0 +
      @iwhile j < @(nu)
         @iexp i 0 0 +
         @iwhile i < @(mu)
   @callproc vbeta pC  @(kk)  rC@(i)_@(j) rC@(i)_@(j)m
            @iexp kk @(kk) 1 +
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @endindent
   @undef kk
   @undef j
   @ENDPROC
@VEC KDIM
   @skip @iexp incAk @(mu) @(vl) * ---not by vlen for fko 
   @skip @iexp incBk @(nu) @(vl) *
   @iexp incAk @(mu) @(ku) *
   @iexp incBk @(nu) @(ku) *
@VEC MDIM NO
   @iexp incAk @(mu)
   @iexp incBk @(nu)
@VEC !
@iexp TWOD 1 0 +
@iif vmu = 1
   @iexp TWOD 0 0 +
@endiif
@iif vnu = 1
   @iexp TWOD 0 0 +
@endiif
@skip NOKLOOP = (kb == ku);
@iexp NOKLOOP @(kb) @(ku) =
@skip @iif NOKLOOP = 0
   @iexp ia -1 0 +
   @iexp ib -1 0 +
@skip @endiif
@skip @iif NOKLOOP ! 0
@skip    @iexp ia 0 0 +
@skip    @iexp ib 0 0 +
@skip @endiif
@ifdef lb
   @abort "lb cannot be defined!"
@endifdef
@ifdef lb2
   @abort "lb2 cannot be defined!"
@endifdef
@beginskip
#ifndef ATL_CSZT
   #include <stddef.h>
   #define ATL_CSZT const size_t
#endif
@endskip
@skip Helper func for DoIter[0].  
@skip IN: pfLS,npfA,npfB, npfC, ipb, ipa, mu, nu, IN_K; 
@skip IN/OUT: mo, ipf
@BEGINPROC DoPref
   @define kk @dum@
   @define jj @dum@
   @SKIP commented out, now handled in ldB
   @BEGINSKIP
   @SKIP if (vmu == 2 && vnu == 2 && mo = 1) mo = 0
   @iexp kk @(vmu) 2 = @(vnu) 2 = @(mo) 1 = & &
   @iif kk ! 0
      @iexp mo 0 0 +
   @endiif
   @ENDSKIP
   @iif mo = 0
      @iif ipf < npfC
         @iexp kk @(ipf) @(pfLS) *
               @skip @(pfC)(pC+@(kk));
               @(pfC), pC[@(kk)]);
         @iexp ipf @(ipf) 1 +
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo = 0 && ipf < npfA)
      @iexp kk @(mo) 0 = @(npfA) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfC) @(ipf) - @(pfLS) *
               @skip @(pfA)(pAn+@(kk));
               @(pfA), pAn[@(kk)]);
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfA
               pAn += incAN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
      @skip if (mo == 0 && ipf < npfB)
      @iexp kk @(mo) 0 = @(npfB) @(ipf) < &
      @iif kk ! 0
         @iexp kk @(npfA) @(ipf) - @(pfLS) *
               @skip @(pfB)(pBn+@(kk));
               @(pfB), pBn[@(kk)]);
         @iexp ipf @(ipf) 1 +
         @iif ipf = npfB
               pBn += incBN;
         @endiif
         @iexp mo @(mo) 1 +
      @endiif
@SKIP Handle prefetch of next k loop traversal, if it exists
      @iif mo = 0
         @ifdef pfBk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @skip @(pfBk)(pB+incBn);
               @(pfBk), pB[incBn]);
                  @undef pfBk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(nu) *
            @SKIP if (NOKLOOP != 0 && ipb%pfLS == 0 && ipb < incBn)
            @iexp kk @(pfLS) @(ipb) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipb) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipb) +
            @skip @(pfBk)(pB+@(jj));
            @(pfBk), pB[@(jj)]);
               @iexp ipb @(ipb) @(pfLS) +
               @iexp mo @(mo) 1 +
            @iexp kk @(jj) @(ipb) <
            @endiif
         @endifdef
      @endiif
      @iif mo = 0
         @ifdef pfAk
            @SKIP if (NOKLOOP == 0 && IN_K != 0)
            @iexp kk 0 @(NOKLOOP) = 0 @(IN_K) ! &
            @iif kk ! 0
               @skip @(pfAk)(pA+incAm);
               @(pfAk), pA[incAm]);
                  @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
            @iexp jj @(kb) @(mu) *
            @SKIP if (NOKLOOP != 0 && ipa%pfLS == 0 && ipa < incAm)
            @iexp kk @(pfLS) @(ipa) % 0 = @(NOKLOOP) 0 ! & @(jj) @(ipa) < &
            @iif kk ! 0
               @iexp jj @(jj) @(ipa) +
            @skip @(pfAk)(pA+@(jj));
            @(pfAk), pA[@(jj)]);
               @iexp ipa @(ipa) @(pfLS) +
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
      @iif IN_K ! 0
         @ifdef pfAk
            @iif mo = 0
            @skip @(pfAk)(pA+incAm);
            @(pfAk), pA[incAm]);
               @undef pfAk
               @iexp mo @(mo) 1 +
            @endiif
         @endifdef
      @endiif
   @endiif
   @undef jj
   @undef kk
@ENDPROC
@beginskip
Perform initial iteration use vmul.  1-D scheduled to make it obvious
the non-unit dimension can be directly loaded from memory, rather than
really using registers.  This allows total number of registers to be:
   MAX(MU,NU) + 1
ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl
@endskip
@BEGINPROC DoIter0_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         @SKIP ATL_vld(rC@(i)_0, pA+@(ia));
         rC@(i)_0 = pA[@(ia)];
            @iexp ia @(ia) @(vl) +
         @SKIP ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
         rC@(i)_0 = rC@(i)_0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         @SKIP ATL_vld(rA0, pA+@(ia));
         rA0 = pA[@(ia)];
         @iexp ia @(ia) @(vl) +
@skip         @iexp ia @(ia) @(incAk) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         @SKIP ATL_vmul(rC0_@(j), rC0_@(j), rA0);
         rC0_@(j) = rC0_@(j) * rA0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @ifdef lb
             @SKIP ATL_vld(vB@(lb), pB+@(ib));
             vB@(lb) = pB[@(ib)];
                @undef lb
                @iexp ib @(ib) @(vl) +
            @endifdef
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is set
   @iif DN = 0
      @define jb @0@
         @SKIP ATL_vld(rA0, pA);
         rA0 = pA[0];
      @iexp ia @(ia) @(vl) +
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         @SKIP ATL_vld(rA@(i), pA+@(ia));
         rA@(i) = pA[@(ia)];
         @iexp ia @(ia) @(vl) +
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
      @ifdef lb
         @SKIP ATL_vld(vB@(lb), pB+@(ib));  /* A01 */
         vB@(lb) = pB[@(ib)];  // A01 
         @undef lb
         @iexp ib @(ib) @(vl) +
      @endifdef
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 9 rB0 @(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         @SKIP ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
         rC@(i)_@(j) = rA@(i) * rB@(jb);
            @iexp mo 0 0 +
            @iif j = jl
            @SKIP ATL_vld(rA@(i), pA+@(ia));
            rA@(i) = pA[@(ia)];
               @iexp ia @(ia) @(vl) +
               @iexp mo @(mo) 1 +
            @endiif
            @iif mo = 0
               @ifdef lb
            @SKIP ATL_vld(vB@(lb), pB+@(ib));  /* A02 i=@(i) j=@(j) */
            vB@(lb) = pB[@(ib)];  // A02 i=@(i) j=@(j) 
                  @undef lb
                  @iexp mo @(mo) 1 +
                  @iexp ib @(ib) @(vl) +
               @endifdef
            @endiif
            @skip if (i == il && j != jl && !B1R)
            @iif @iexp @(i) @(il) = @(j) @(jl) ! & @(B1R) 0 = &
               @callproc ldB 9 rB@(j) @(j)
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP do all zerod rc 
@SKIP ASSUMES DEFINED: vmu, vnu, ipf, npf, IN_K
@BEGINPROC RC_ZEROD 
   @skip ************** pref inst ******************************************
   @iexp IN_K 0 0 +
   @iwhile ipf < npf
      @skip "we want to apply all pref here"
      @iexp mo 0 0 + 
      @CALLPROC DoPref
      @skip ipf increased inside DoPref
   @endiwhile
   @skip *******************************************************************
   @define i @0@
   @define j @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @mif typ = "DOUBLE
         rC@(i)_@(j) = 0.0;
            @endmif
            @mif typ = "FLOAT
         rC@(i)_@(j) = 0.0f;
            @endmif
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
   @undef i
   @undef j
@ENDPROC
@SKIP Do Normal Kdim kloop iter
@SKIP ASSUMES DEFINED: 
@BEGINPROC DoIter_kvec
   @define i @0@
   @define j @0@
   @define kk @0@
   @define idx @0@
   @define ic @0@
   @define DN @0@
@SKIP 1D with NU=1
   @iif nu = 1
      @iexp DN 1 0 +
      @SKIP need to load pB only once
      @iexp kk 0 0 +
      @iwhile kk < @(vl)
         rB0 = pB[@(kk)];
         @iexp ic 0 0 +
         @iwhile ic < @(mu)
            @iexp idx @(ic) @(vl) *
            @iexp idx @(idx) @(kk) +
            rA0 = pA[@(idx)];
            rC@(ic)_0 += rA0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp ic @(ic) 1 +
         @endiwhile
         @iexp kk @(kk) 1 +
      @endiwhile
   @endiif
@SKIP 1D with MU=1
   @iif DN = 0
      @iif mu = 1
         @iexp DN 1 0 +
         @iexp kk 0 0 +
         @iwhile kk < @(vl)
            rA0 = pA[@(kk)];
            @iexp j 0 0 +
            @iwhile j < @(nu)
               @iexp idx @(j) @(vl) *
               @iexp idx @(idx) @(kk) +
               rB0 = pB[@(idx)]; 
               rC0_@(j) += rA0 * rB0;
               @iexp mo 0 0 +
               @callproc DoPref
               @iexp j @(j) 1 +
            @endiwhile
            @iexp kk @(kk) 1 +
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case
   @iif DN = 0
      @iexp kk 0 0 +
      @iwhile kk < @(vl)
@beginskip
@skip ******************* without scheduling ****************************
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @iexp idx @(i) @(vl) *
            @iexp idx @(idx) @(kk) +
            rA@(i) = pA[@(idx)];
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 0 +
         @iwhile j < @(nu)
            @iexp idx @(j) @(vl) *
            @iexp idx @(idx) @(kk) +
            rB0 = pB[@(idx)]; 
            @iexp ic 0 0 +
            @iwhile ic < @(mu)
               rC@(ic)_@(j) += rA@(ic) * rB0;
               @iexp ic @(ic) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
@skip ********************************************************************
@endskip
         rB0 = pB[@(kk)];
         @iexp i 0 0 +
         @iwhile i < @(mu)
            @iexp idx @(i) @(vl) *
            @iexp idx @(idx) @(kk) +
            rA@(i) = pA[@(idx)];
            rC@(i)_0 += rA@(i) * rB0;
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j 0 1 +
         @iwhile j < @(nu)
            @iexp idx @(j) @(vl) *
            @iexp idx @(idx) @(kk) +
            rB0 = pB[@(idx)]; 
            @iexp ic 0 0 +
            @iexp mo 0 1 +
            @iwhile ic < @(mu)
               @callproc DoPref
               rC@(ic)_@(j) += rA@(ic) * rB0;
               @iexp mo 0 0 +
               @iexp ic @(ic) 1 +
            @endiwhile
            @iexp j @(j) 1 +
         @endiwhile
         @iexp kk @(kk) 1 +
      @endiwhile
   @endiif
         @iexp idx @(mu) @(vl) *
         pA += @(idx);
         @iexp idx @(nu) @(vl) *
         pB += @(idx);
   @undef i
   @undef j
   @undef kk
   @undef idx
   @undef ic
   @undef DN @0@
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter_k
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @callproc ldB 9 rB0 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @skip ATL_vld(rA0, pA+@(ia));
            rA0 = pA[@(ia)];
            @iexp ia @(ia) @(vl) +
            @skip ATL_vmac(rC@(i)_0, rA0, rB0);
            rC@(i)_0 += rA0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            @skip ATL_vld(rA0, pA+@(ia));
            rA0 = pA[@(ia)];
            @iexp ia @(ia) @(vl) +
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            @skip ATL_vmac(rC0_@(j), rA0, rB0);
            rC0_@(j) += rA0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
             @skip ATL_vld(vB@(kk), pB+@(ib)); /* 01 */
             vB@(kk) = pB[@(ib)]; 
               @iexp ib @(ib) @(vl) +
            @endiif
         @endiwhile
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R true
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(jl)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            @skip ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            rC@(i)_@(j) += rA@(i) * rB@(jb);
            @skip if ((i|j) == 0 && !B1R)
            @iif @iexp @(i) @(j) | 0 = @(B1R) 0 = &
               @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
               @skip ATL_vld(vB@(lb), pB+@(ib)); /* 02 */
               vB@(lb) = pB[@(ib)];
                     @undef lb
                     @iexp ib @(ib) @(vl) +
                     @iexp mo 1 0 +
                  @endifdef
            @endiif
            @iif j = jl
               @skip ATL_vld(rA@(i), pA+@(ia));
               rA@(i) = pA[@(ia)];
               @iexp ia @(ia) @(vl) +
               @iexp mo 1 0 +
            @endiif
            @skip if (j != jl && i == il && !B1R
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
               @skip ATL_vld(vB@(lb), pB+@(ib)); /* 03 */
               vB@(lb) = pB[@(ib)]; 
                  @undef lb
                  @iexp ib @(ib) @(vl) +
                  @SKIP if (vmu !=2 && vnu != 2) mo++
                  @iexp kk @(vmu) 2 ! @(vnu) 2 ! |
                  @iif kk ! 0
                     @iexp mo 1 0 +
                  @endiif
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@BEGINPROC DoIter0
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @skip @(ldB)(rB0, pB); --- replaced 
         rB0 = pB[0];
         pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
         @skip ATL_vld(rC@(i)_0, pA+@(kk));
         rC@(i)_0 = pA[@(kk)];
         @skip ATL_vmul(rC@(i)_0, rC@(i)_0, rB0);
         rC@(i)_0 = rC@(i)_0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         pA += @(incAk);
   @endiif
@SKIP 1-D with VMU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
         @skip ATL_vld(rA0, pA);
         rA0 = pA[0];
         pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 6 rC0_@(j) @(j)
         @skip ATL_vmul(rC0_@(j), rC0_@(j), rA0);
         rC0_@(j) = rC0_@(j) * rA0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
             @skip ATL_vld(vB@(kk), pB+@(jj));
             vB@(kk) = pB[@(jj)];
            @endiif
         @endiwhile
         pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded unless B1R is true
   @iif DN = 0
      @define jb @0@
         @skip ATL_vld(rA0, pA);
         rA0 = pA[0];
      @iexp i 0 1 +
      @iwhile i < @(vmu)
         @iexp kk @(i) @(vl) *
         @skip ATL_vld(rA@(i), pA+@(kk));
         rA@(i) = pA[@(kk)];
         @iexp i @(i) 1 +
      @endiwhile
      @iif B1R = 0
         @callproc ldB 6 rB@(jl) @(jl)
      @endiif
         pA += @(incAk);
      @ifdef lb
         @iexp jj @(vl) @(lb) *
         @skip ATL_vld(vB@(lb), pB+@(jj)); /* di0_00 */
         vB@(lb) = pB[@(jj)]; 
         @undef lb
      @endifdef
      @iif B1R = 0
         pB += @(incBk);
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif B1R ! 0
            @callproc ldB 6 rB0 @(j)
            @iif @iexp @(vnu) -1 + @(j) =
               pB += @(incBk); /* di0_02 */
            @endiif
         @endiif
         @iexp jb 0 @(B1R) = @(j) *
         @iexp i 0 0 +
         @iwhile i < @(vmu)
         @skip ATL_vmul(rC@(i)_@(j), rA@(i), rB@(jb));
         rC@(i)_@(j) = rA@(i) * rB@(jb);
            @iexp mo 0 0 +
            @iif j = jl
               @iexp kk @(i) @(vl) *
            @skip ATL_vld(rA@(i), pA+@(kk));
            rA@(i) = pA[@(kk)];
               @iexp mo @(mo) 1 +
                  @iif i = il
            pA += @(incAk);
                  @endiif
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
               @skip ATL_vld(vB@(lb), pB+@(kk)); /* di0_01: lb=@(lb) jl=@(jl) */
               vB@(lb) = pB[@(kk)]; 
                  @iexp kk @(kk) @(vl) +
                  @iif kk = incBk
               pB += @(incBk); /* di0_02 */
                  @endiif
                  @undef lb
                  @iexp mo @(mo) 1 +
               @endifdef
            @endiif
            @iif B1R = 0
               @iif i = il
                  @iif j ! jl
                     @iexp kk @(j) @(bmul) *
            @callproc ldB 9 rB@(j) @(j)
                  @endiif
               @endiif
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@SKIP Do normal iteration
@SKIP ASSUMES DEFINED: ldB, incBk, bmul, incAk, vmu, vnu, vl, jpf
@BEGINPROC DoIter
@SKIP define internal vars, so they can popped off to leave caller unchanged
   @define DN @0@
   @define i @0@
   @define j @0@
   @define kk @0@
@SKIP 1-D with NU=1
   @iif vnu = 1
      @iexp DN 1 0 +
         @SKIP *********TRMML: LAST_ITER: increment pB before Loading pB[0]**
         @iif TRMML ! 0
            @callproc lKpBinc
         @endiif
         @SKIP **************************************************************
            @skip @(ldB)(rB0, pB);
            rB0 = pB[0];
            pB += @(incBk);
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp kk @(i) @(vl) *
            @skip ATL_vld(rA0, pA+@(kk));
            rA0 = pA[@(kk)];
            @skip ATL_vmac(rC@(i)_0, rA0, rB0);
            rC@(i)_0 += rA0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
            pA += @(incAk);
   @endiif
@SKIP 1-D with MU=1
   @iif DN = 0
      @iif vmu = 1
         @iexp DN 1 0 +
            @skip ATL_vld(rA0, pA);
            rA0 = pA[0];
            pA += @(incAk);
         @iexp j 0 0 +
         @iwhile j < @(vnu)
            @callproc ldB 9 rB0 @(j)
            @skip ATL_vmac(rC0_@(j), rA0, rB0);
            rC0_@(j) += rA0 * rB0;
            @iexp mo 0 0 +
            @callproc DoPref
            @iexp j @(j) 1 +
            @skip if (bc==0 && j%vl==0)
            @iexp kk @(bc) 0 = @(vl) @(j) % 0 = &
            @iif kk ! 0
               @iexp kk @(vl) @(j) / -1 +
               @iexp jj @(kk) @(vl) *
         @SKIP *********TRMML: LAST_ITER: increment pB before Loading pB[0]**
         @iif TRMML ! 0
            @iif jj = 0
               @callproc lKpBinc
            @endiif 
         @endiif
         @SKIP **************************************************************
             ATL_vld(vB@(kk), pB+@(jj));
            @endiif
         @endiwhile
            pB += @(incBk);
      @endiif
   @endiif
@SKIP 2-D case assumes all but last rB already loaded
   @iif DN = 0
      @define jb @0@
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp jb 0 @(B1R) = @(j) *
         @iif B1R ! 0
            @callproc ldB 12 rB0 @(j)
            @iif jl = j
               pB += @(incBk);
            @endiif
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            @iexp mo 0 0 +
            @skip ATL_vmac(rC@(i)_@(j), rA@(i), rB@(jb));
            rC@(i)_@(j) += rA@(i) * rB@(jb);
            @skip if ((i|j|B1R) == 0)
            @iif @iexp @(i) @(j) | @(B1R) | 0 =
                  @iexp kk @(jl) @(bmul) *
               @callproc ldB 12 rB@(jl) @(jl)
                  @ifdef lb
                     @iexp kk @(lb) @(vl) *
                  @SKIP **TRMML: LAST_ITER:increment pB before Loading pB[0]**
                  @iif TRMML ! 0
                     @iif PBFLD = 0
                        @iif kk = 0 
                           @callproc lKpBinc
                        @endiif 
                     @endiif 
                  @endiif
               @skip ATL_vld(vB@(lb), pB+@(kk));
               vB@(lb) = pB[@(kk)];
                  @iif TRMML ! 0
                     @iif PBFLD ! 0
                        @callproc lKpBinc
                     @endiif 
                  @endiif
                  @SKIP ******************************************************
                     @undef lb
                     @iexp mo 1 0 +
                  @endifdef
               /* pB inc */
               pB += @(incBk);
            @endiif
            @iif j = jl
               @iexp kk @(i) @(vl) *
               @skip ATL_vld(rA@(i), pA+@(kk));
               rA@(i) = pA[@(kk)];
               @iexp mo 1 0 +
               @iif i = il
               pA += @(incAk);
               @endiif
            @endiif
            @skip if (j != jl && i == il && !B1R)
            @iif @iexp @(j) @(jl) ! @(i) @(il) = & @(B1R) 0 = &
               @iexp kk @(j) @(bmul) *
               @callproc ldB 12 rB@(j) @(j)
            @endiif
            @iif mo = 0
               @ifdef lb
                  @iexp kk @(lb) @(vl) *
                  @SKIP **TRMML: LAST_ITER:increment pB before Loading pB[0]**
                  @iif kk = 0 
                     @iif TRMML ! 0
                        @callproc lKpBinc
                     @endiif 
                  @endiif 
                  @SKIP ******************************************************
               @skip ATL_vld(vB@(lb), pB+@(kk));
               vB@(lb) = pB[@(kk)];
                  @undef lb
                  @iexp mo 1 0 +
               @endifdef
            @endiif
            @callproc DoPref
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @undef jb
   @endiif
@SKIP pop our defs so caller's macros of same name aren't changed
   @undef DN
   @undef i
   @undef j
   @undef kk
@ENDPROC
@BEGINPROC ReloadlB
   @define kk @0@
   @define i @0@ 
   @define j @0@ 
   @iif bc = 0
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iexp kk @(vl) @(j) /
               @skip ATL_vld(vB@(kk), pB+@(j));
               vB@(kk) = pB[@(j)];
         @iexp j @(j) @(vl) +
      @endiwhile
      @SKIP "IN TRMM, NOKLOOP is always 0"
      pB += @(incBk);
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @iexp j 0 0 +
      @iwhile j < @(jl)
         @callproc ldB 12 rB@(j) @(j)
         @ifdef lb
            @iif ib < 0
               @iexp kk @(vl) @(lb) *
               @skip ATL_vld(vB@(lb), pB+@(kk)); 
               vB@(lb) = pB[@(kk)];
            @endiif
            @iif ib > -1 
               @skip ATL_vld(vB@(lb), pB+@(ib));  
               vB@(lb) = pB[@(ib)];
               @iexp ib @(ib) @(vl) +
            @endiif
            @undef lb
         @endifdef
         @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @undef j
   @undef i
   @undef kk
@ENDPROC
@BEGINSKIP 
void ATL_USERMM
(
   ATL_CSZT nmus,
   ATL_CSZT nnus,
   ATL_CSZT K,
   const @(typ) *pA, /* @(mu)*KB*nmus-length access-major array of A */
   const @(typ) *pB, /* @(nu)*KB*nnus-length access-major array of B */
   @(typ) *pC,   /* @(mu)*@(nu)*nnus*nmus-length access-major array of C */
   const @(typ) *pAn, /* next block of A */
   const @(typ) *pBn, /* next block of B */
   const @(typ) *pCn  /* next block of C */
)
@ENDSKIP
ROUTINE ATL_USERMM;
   PARAMS :: nmus, nnus, K, pA, pB, pC, pAn, pBn, pCn;
   INT :: nmus, nnus, K;
   @(typ)_PTR :: pA, pB, pC, pAn, pBn, pCn;
/*
 * Performs a GEMM with M,N,K unrolling (& jam) of (@(mu),@(nu),@(ku)).
@VEC KDIM ` * Vectorization of VLEN=@(vl) along K dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC MDIM ` * Vectorization of VLEN=@(vl) along M dim, vec unroll=(@(vmu),@(vnu),@(vku)).`
@VEC NO   ` * Code is not vectorized (VLEN=@(vl)).`
@iif kb = 0
 * You may set compile-time constant K dim by defining ATL_MM_KB.
@endiif
 */
@SKIP {
ROUT_LOCALS 
   @declare "   @(typ) :: " y n ";"
      @iif bc = 0
         @iexp kk @(vl) @(vnu) /
         @iexp j 0 0 +
         @iwhile j < @(kk)
            vB@(j)
            @iexp j @(j) 1 +
         @endiwhile
      @endiif
      @iif B1R ! 0
         rB0
      @endiif
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @iif @iexp 0 @(TWOD) ! 0 @(B1R) = &
            rB@(j)
         @endiif
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rC@(i)_@(j)
            @iexp i @(i) 1 +
         @endiwhile
         @iexp j @(j) 1 +
      @endiwhile
      @iif TWOD = 0
         rA0 
         @iif B1R = 0
            rB0
         @endiif
      @endiif
      @iif TWOD ! 0
         @iexp i 0 0 +
         @iwhile i < @(vmu)
            rA@(i)
            @iexp i @(i) 1 +
         @endiwhile
      @endiif
      @SKIP if (mu*nu < vlen && mu != 1 && nu != 1
      @iif @iexp @(vl) @(mu) @(nu) * < @(mu) 1 ! & @(nu) 1 ! &
         rtmp
         @define exreg @rtmp@
      @endiif
   @enddeclare
   @iif @iexp @(vl) @(mu) @(nu) * > 
      @define exreg @rC0_0@
   @endiif
   @ifdef ! exreg
      @iif @iexp @(mu) 1 = @(nu) 1 = |
         @define exreg @rB0@
      @endiif
   @endifdef
@BEGINSKIP *********************************************************************
   @declare "   const @(typ) " y n ";"
    *pB0=pB *pA0=pA
   @enddeclare
@SKIP ---- need to declare first, inti later 
   @iif npfA > 0
   const int incAN = (ATL_MM_KB * @(mu)) / nnus;
   @endiif
   @iif npfB > 0
   const int incBN = (ATL_MM_KB * @(nu)) / nmus;
   @endiif
@skip   const @(typ) *pfA;
   int i, j, k;
   @iif SYRKU = 1
   const unsigned int MM=nmus*@(mu), NN=nnus*@(nu);
   @endiif
   @iif TRMML ! 0
   int I, KK; /* Used for K-loop bounds */
      @iexp koff @(mu)
      @iif mu < @(ku)
         @iexp koff @(ku)
      @endiif
   @endiif
   @iif TRMM = 1
   /* For Left-lower */
   int incAm = @(mu)*@(koff);
   int incBn = K < @(koff) ? 0 : @(nu)*(K - @(koff));
      @iif mu < @(ku)
      int off = 0;
      @endiif
   @endiif
   @iif TRMM = 2
   /* For Left-upper */
   int incAm = @(mu)*K;
   int incBn = 0;
      @iif mu < @(ku)
      int off = 0;
      @endiif
   @endiif
   @iif TRMMR ! 0
   int J, KK; /* Used for K-loop bounds */
   /* For Right-lower/upper */
   const int incAm = @(mu)*K;
   @skip to avoid compilation error
   const int incBn = @(nu)*K; /* just to use in pref*/
   @endiif
   @iif TRMM = 0
   #if ATL_KBCONST == 0
      int incAm = @(mu)*K, incBn = @(nu)*K;
   #else
      #define incAm (@(mu)*ATL_MM_KB)
      #define incBn (@(nu)*ATL_MM_KB)
   #endif
   @endiif
@ENDSKIP  **********************************************************************
   @(typ)_PTR :: pA0, pB0;
   INT :: i, j, k;
   INT :: incAm, incBn;
   @iif npfA > 0
   INT :: incAN;
   @endiif
   @iif npfB > 0
   INT :: incBN;
   @endiif
   @iif SYRKU = 1
   INT :: MM, NN, in;
   @endiif
   @iif TRMML ! 0
   INT :: I, KK;
      @iexp koff @(mu)
      @iif mu < @(ku)
         @iexp koff @(ku)
      @endiif
   @endiif
   @iif TRMMR ! 0
   INT :: J, KK, off; 
   @endiif
   @iif TRMM = 3
   INT :: Aoff; 
   @endiif
@skip ****poping of defs for i and j
   @whiledef i
   @endwhile
   @whiledef j
   @endwhile
@echo @iif ibet ! 0
@echo   @declare "   @(typ) :: " y n ";"
@echo      @iexp j 0 0 +
@echo      @iwhile j < @(vnu)
@echo         @iexp i 0 0 +
@echo         @iwhile i < @(vmu)
@echo             rC@(i)_@(j)m
@echo            @iexp i @(i) 1 +
@echo         @endiwhile
@echo         @iexp j @(j) 1 +
@echo      @endiwhile
@echo   @enddeclare
@echo @endiif
ROUT_MARKUP
   ALIGNED(32) :: *;
ROUT_BEGIN
   @iif npfA > 0
      incAN = @(ATL_MM_KB) * @(mu);
      incAN = incAN / nnus;
   @endiif
   @iif npfB > 0
      incBN = @(ATL_MM_KB) * @(nu);
      incBN = incBN / nmus;
   @endiif
   pB0=pB;
   pA0=pA;
@echo @iif ATL_KBCONST = 0
      incAm = K*@(mu); 
      incBn = K*@(nu);
@echo @endiif
@echo @iif ATL_KBCONST ! 0
      incAm = @(ATL_MM_KB)*@(mu);
      incBn = @(ATL_MM_KB)*@(nu);
@echo @endiif
@skip *************************************************   
   @SKIP if (npfA > 0 & npfB > 0)
   @iexp kk 0 @(npfA) > 0 @(npfB) > &
   @iif kk ! 0
   @skip pAn = (pAn != pA) ? pAn : pC;
   IF ( pAn != pA) GOTO LB_PA_EQ;
      pAn = pC;
LB_PA_EQ: 
   @skip pBn = (pBn != pB) ? pBn : pC;
   IF (pBn != pB) GOTO LB_PB_EQ;
      pBn = pC;
LB_PB_EQ: 
   @endiif
   @iif kk = 0
      @iif npfA > 0
      @skip   if (pAn == pA)
      @skip      pAn = (pBn != pB) ? pBn : pCn;
         IF (pAn != pA) GOTO LB_PA_ALL_DONE;
            IF (pBn == pB) GOTO LB_IF_CN;
               pAn = pBn;
               GOTO LB_PA_ALL_DONE;
            LB_IF_CN:
               pAn = pCn;
         LB_PA_ALL_DONE:
      @endiif
      @iif npfB > 0
      @skip   if (pBn == pB)
      @skip      pBn = (pAn != pA) ? pAn : pCn;
      IF ( pBn != pB ) GOTO LB_PB_ALL_DONE;
         IF ( pAn == pA ) GOTO LB_IF_PA_CN;
            pBn = pAn;
            GOTO LB_PB_ALL_DONE;
         LB_IF_PA_CN: 
            pBn = pCn;
      LB_PB_ALL_DONE:
      @endiif
   @endiif
@skip *************************************************  
@BEGINSKIP 
   @SKIP if (npfA > 0 & npfB > 0)
   @iexp kk 0 @(npfA) > 0 @(npfB) > &
   @iif kk ! 0
   pAn = (pAn != pA) ? pAn : pC;
   pBn = (pBn != pB) ? pBn : pC;
   @endiif
   @iif kk = 0
      @iif npfA > 0
         if (pAn == pA)
            pAn = (pBn != pB) ? pBn : pCn;
      @endiif
      @iif npfB > 0
         if (pBn == pB)
            pBn = (pAn != pA) ? pAn : pCn;
      @endiif
   @endiif
@ENDSKIP 
@iif SYRKU = 1
   MM = nmus*@(mu);
   NN = nnus*@(nu);
@endiif
   @iexp mo 0 0 +
   @iexp ipf 0 0 +
   @iexp ipa 0 0 +
   @iexp ipb 0 0 +
   @iexp jl @(vnu) -1 +
   @iexp il @(vmu) -1 +
   @iif vnu > 2
      @iexp jpf 0 1 +
   @endiif
   @iif vnu < 3
      @iexp jpf 0 -1 +
   @endiif
   @iexp jpf 0 -1 +
@iif @iexp @(DOMLOOP)
@BEGINSKIP -------------------------------
   @iif TRMML = 0
      @iif SYRKU = 1
   for (i=0; i < MM; i += @(mu))
      @endiif
      @iif SYRKU = 0
   for (i=0; i < nmus; i++)
      @endiif
   @endiif
   @iif TRMML ! 0
   for (i=0, I=0; i < nmus; i++, I+=@(mu))
   @endiif
   {
   @iif SYRKU = 1
      int in = i + @(mu);
      in = (NN < in) ? NN : in;
   @endiif
   @iif TRMM = 3
      int Aoff = 0;
   @endiif
   @iif TRMMR ! 0
      @iif nu < @(ku)
      int off = 0;
      @endiif
   @endiif
@ENDSKIP -------------------------------
   @iif TRMML = 0
      @iif SYRKU = 1
         i = 0;
      @endiif
      @iif SYRKU = 0
      i = nmus;
      @endiif
   @endiif
   @iif TRMML ! 0
         I = 0; 
         i = nmus;
   @endiif
      MLOOP:  
   @iif SYRKU = 1
         in = i + @(mu);
         IF (NN >= in) GOTO LB_IF_IN;
            in = NN;   
         LB_IF_IN: 
   @endiif
   @iif TRMM = 3
         Aoff = 0;
   @endiif
   @iif TRMMR ! 0
      @iif nu < @(ku)
         off = 0;
      @endiif
   @endiif
@endiif
@print NOK=@(NOKLOOP) ib=@(ib) ia=@(ia)
@BEGINSKIP
*******************************************************************************
   NOTE: For FKO, we generate scalar code since FKO itself vectorizes the code.
   MDIM: scalar can be generated just by setting vlen=1 and vmu=mu*vlen
   KDIM: Need completely generated different codes: with initializaton of rC=0 
   at the beginning
@ENDSKIP
@VEC MDIM 
   @iif bc = 0
      @iexp j 0 0 +
      @iwhile j < @(vnu)
         @SKIP ********* TRMML: to keep track PBLHOIST   
            @iif TRMML ! 0
               @iexp PBLHOIST @(PBLHOIST) 1 + 
            @endiif
         @SKIP ***********************************************************
         @iexp kk @(vl) @(j) /
      @skip ATL_vld(vB@(kk), pB+@(j));
      vB@(kk) = pB[@(j)];
         @iexp j @(j) @(vl) +
      @endiwhile
      @iif NOKLOOP ! 0
         @iexp ib @(ib) @(nu) +
      @endiif
      @iif NOKLOOP = 0
      @SKIP ********* TRMML: to keep track of inc of pB before NLOOP   
         @iif TRMML ! 0
            @iexp PBINC 1 0 + 
         @endiif
      @SKIP ********************************************************
      pB += @(incBk);
      @endiif
   @endiif
   @iif @iexp 1 @(vmu) > 0 @(B1R) = &
      @iexp j 0 0 +
      @iwhile j < @(jl)
         @SKIP ********* TRMML: to keep track PBLHOIST *************   
         @iif TRMML ! 0
            @iexp PBLHOIST @(PBLHOIST) 1 + 
         @endiif
         @SKIP *****************************************************
         @callproc ldB 3 rB@(j) @(j)
         @ifdef lb
            @iif ib < 0
               @iexp kk @(vl) @(lb) *
      @skip ATL_vld(vB@(lb), pB+@(kk)); 
      vB@(lb) = pB[@(kk)]; 
            @endiif
            @iif ib > -1 
      @skip ATL_vld(vB@(lb), pB+@(ib));  
      vB@(lb) = pB[@(ib)];
               @iexp ib @(ib) @(vl) +
            @endiif
            @undef lb
            @SKIP ****************TRMML ******************************
            @SKIP *** to keep track pB ld after pB increment  
            @iif TRMML ! 0
               @iif PBINC ! 0
                  @iexp PBFLD @(PBFLD) 1 + 
               @endiif
            @endiif
            @SKIP ****************************************************
         @endifdef
         @iexp j @(j) 1 +
      @endiwhile
   @endiif
   @iif @iexp @(DONLOOP)
      @BEGINSKIP ------------------------------------------------
      @iif TRI = 0
         @iif TRMMR = 0 /* For Left TRMM or GEMM */
      for (j=0; j < nnus; j++)
         @endiif
         @iif TRMMR ! 0 /* For Right TRMM */
      for (j=0, J=0; j < nnus; j++, J+=@(nu))
         @endiif
      @endiif
      @iif TRI = 1
         @iif SQSYRK = 1
      for (j=0; j <= i; j++)
         @endiif
         @iif SYRKU = 1
      for (j=0; j < in; j += @(nu))
         @endiif
      @endiif
      {         
      @ENDSKIP ------------------------------------------------
      @iif TRI = 0
         @iif TRMMR = 0
         j = nnus;
         @endiif
         @iif TRMMR ! 0
         J = 0;
         j = nnus;
         @endiif
      @endiif
      @iif TRI = 1
         @iif SQSYRK = 1
         j = nmus - i;
         @endiif
         @iif SYRKU = 1
         j = 0;
         @endiif
      @endiif
      NLOOP: 
   @endiif
   @skip ********************** NO KLOOP ************************************
   @iif NOKLOOP ! 0
      @iif TRMM ! 0
         @abort "Not considered fully unrolled Kloop for TRMM!"
      @endiif
@BEGINSKIP 
*     NOTE: For FKO, we want to unroll the KLOOP using compiler's flag ...
*     Because, FKO can unroll without having much adverse affect on register
@ENDSKIP
@BEGINSKIP 
      @iexp IN_K 0 0 +
         @CALLPROC DoIter0_k
      @VEC KDIM `@iexp incK @(vl) 0 +`
      @VEC ! KDIM `@iexp incK 1 0 +`
      @iexp k 0 @(incK) +
      @iwhile ipf < npf
            /* Peel K=@(k) iteration for prefetch  */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
      @iexp IN_K 1 0 +
      @iwhile k < kb
            /* K=@(k) iteration */
         @CALLPROC DoIter_k
         @iexp k @(k) @(incK) +
      @endiwhile
@ENDSKIP  
      @iexp IN_K 0 0 +
         @CALLPROC DoIter0
      @iexp incK 1 0 +
      @iexp k 0 @(incK) +
      @iwhile ipf < npf
            // Peel K=@(k) iteration for prefetch 
         @CALLPROC DoIter
         @iexp k @(k) @(incK) +
      @endiwhile
      @iexp IN_K 1 0 +
         @iexp kk @(k) 0 +
         @print k=@(k), kb=@(kb)
         @iif k < kb
         LOOP k = @(kk), @(kb), @(incK)
         LOOP_BODY
            @iexp IN_K 0 1 +
            @CALLPROC DoIter
         LOOP_END
         @endiif
   @endiif
   @skip **********************************************************************
   @iif NOKLOOP = 0
      @SKIP ********* TRMM: to manage loop bound of TRMM ********
      @iif TRMM = 1 /* Left-lower */
         @iif mu < @(ku)
         @SKIP --- KK = I-off+@(ku) ; 
         KK = I-off; 
         KK += @(ku) ; 
         @endiif
         @iif mu } @(ku)
         @SKIP ---- KK = K < (I+@(mu)) ? K : (I+@(mu));
         IF (K < (I+@(mu))) GOTO LB_I_MU; 
            KK = I + @(mu);
            GOTO LB_I_MU_MG;
         LB_I_MU: 
            KK = K;
         LB_I_MU_MG: 
         @endiif
      @endiif
      @iif TRMM = 4 /* Right-upper */
         @SKIP ---- KK = K < (J+@(nu)) ? K : (J+@(nu));
         @SKIP ---- KK = KK < @(ku) ? @(ku) : KK; /* special checking to be at least ku */
         IF (K < (J+@(nu))) GOTO LB_J_NU;
            KK = J + @(nu);
            GOTO LB_J_NU_MG;
         LB_J_NU: 
            KK = K;
         LB_J_NU_MG:
         IF (KK >= @(ku)) GOTO LB_KK_KU; 
            KK = @(ku);
         LB_KK_KU:
      @endiif
      @SKIP ************************************************
         /* Peel K=0 iteration to avoid zero of rCxx and extra add  */
      @iexp IN_K 0 0 +
      @iexp npeel 1 0 +
      @VEC KDIM `@iexp kmul @(vl)`
      @VEC ! KDIM `@iexp kmul 1`
      @CALLPROC DoIter0
      @iwhile ipf < npf
/*
 *       Peel K=@(npeel) iter to allow prefetch of C or next blocks of A&B
 */
         @iexp kk @(kmul) @(npeel) *
@BEGINSKIP
*        redesigned to make it simple to understand... may not have compact code
*        like before. 
@ENDSKIP 
         @iif TRMM = 0  
         @SKIP ---if (K == @(kk))
         @SKIP --   goto KDONE;
            IF (K == @(kk)) GOTO KDONE;
         @endiif
         @SKIP ***** TRMM=1 case ********************
         @iif TRMM = 1
            @iif @(kk) } @(ku)
         if (KK <= @(kk))
            @callproc toKdone
            @endiif
         @endiif
         @SKIP ****************************************
         @SKIP ***** TRMM=2 case ********************
         @iif TRMM = 2
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
            @callproc toKdone
         @endiif
         @SKIP **************************************   
         @iif TRMM = 3
            @iif nu < @(ku)
         if ((J-off+@(kk)) >= K)
            @endiif
            @iif nu } @(ku)
         if ((J+@(kk)) >= K)
            @endiif
            goto KDONE;
         @endiif
         @iif TRMM = 4
         if (KK <= @(kk))
            goto KDONE;
         @endiif
            @CALLPROC DoIter
         @iexp npeel @(npeel) 1 +
      @endiwhile
      @SKIP peel until npeel%vku == 0
      @iif @iexp @(vku) @(npeel) % 0 !
         @iexp nep @(vku) @(npeel) % @(vku) -
/*
 *       Peeled @(npeel) iters, peel another @(nep) to make mul of vku=@(vku)
 */
         @iexp ii 0
         @iwhile ii < nep
         /* ku mulpeel @(ii) of @(nep) */
         @iexp kk @(kmul) @(npeel) *
         @iif TRMM = 0
         @SKIP if (K == @(kk))
         @SKIP    goto KDONE;
         IF (K == @(kk)) GOTO KDONE;
         @endiif
         @SKIP **************** TRMML **************************
         @iif TRMM = 1  
         if (KK <= @(kk))
            @callproc toKdone 
         @endiif
      @SKIP *********************************************   
         @iif TRMM = 2
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
            @callproc toKdone 
         @endiif
      @SKIP *********************************************   
         @iif TRMM = 3
            @iif nu < @(ku)
         if ((J-off+@(kk)) >= K)
            @endiif
            @iif nu } @(ku)
         if ((J+@(kk)) >= K)
            @endiif
            goto KDONE;
         @endiif
         @iif TRMM = 4
            @iif @(kk) } @(ku)
         if (KK <= @(kk))
            goto KDONE;
            @endiif
         @endiif
      @SKIP ****************************************** 
            @CALLPROC DoIter
            @iexp npeel @(npeel) 1 +
            @iexp ii @(ii) 1 +
         @endiwhile
      @endiif
         @iexp kk @(kmul) @(npeel) *
      @iif TRMM = 1 /* Left-lower */
         @SKIP ****NOTE: extra checking needed if kloop not executes   
         @iif PBLHOIST ! 0
         if (KK == @(kk))
            @callproc toKdone
         KK -= @(ku); /* to keep epilogue for kloop */
         @endiif
         for (k=@(kk); k < KK; k += @(ku))
      @endiif
      @iif TRMM = 2 /* Left-upper */
         @SKIP ****NOTE: extra checking needed if kloop not executes   
         @iif PBLHOIST ! 0 
            @iif mu < @(ku)
         if ((I-off+@(kk)) >= K)
            @endiif
            @iif mu } @(ku)
         if ((I+@(kk)) >= K)
            @endiif
            @callproc toKdone 
         KK = K - @(ku); /* to keep epilogue for kloop */
            @iif mu < @(ku)
         for (k=I-off+@(kk); k < KK; k += @(ku))
            @endiif
            @iif mu } @(ku)
         for (k=I+@(kk); k < KK; k += @(ku))
            @endiif
         @endiif
         @iif PBLHOIST = 0
            @iif mu < @(ku)
         for (k=I-off+@(kk); k < K; k += @(ku))
            @endiif
            @iif mu } @(ku)
         for (k=I+@(kk); k < K; k += @(ku))
            @endiif
         @endiif
      @endiif
      @iif TRMM = 3 /* Right-lower */
            @iif nu < @(ku)
         for (k=J-off+@(kk); k < K; k += @(ku))
            @endiif
            @iif nu } @(ku)
         for (k=J+@(kk); k < K; k += @(ku))
            @endiif
      @endiif
      @iif TRMM = 4 /* Right-upper */
         for (k=@(kk); k < KK; k += @(ku))
      @endiif
@SKIP *************** not updated for TRMM yet 
         @iif TRMM = 0
         @SKIP for (k=@(kk); k < ATL_MM_KB; k += @(ku))
         LOOP k=0, @(ATL_MM_KB), @(ku)
         LOOP_BODY
         @endiif
         @skip {
            @iexp IN_K 0 1 +
            @iexp kk 0
            @iwhile kk < @(vku)
            @iif kk > 0

            @endiif
            @CALLPROC DoIter
               @iexp kk @(kk) 1 +
            @endiwhile
         @skip }
         LOOP_END
      @SKIP *******TRMML: special for TRMML: peeling last iter off ************
      @iif TRMML ! 0
         @iif PBLHOIST ! 0 
      @iexp IN_K 0 1 +
      @iexp kk 0
      @iwhile kk < @(vku)
         @iexp kk @(kk) 1 +
         @iif kk < @(vku)
         @CALLPROC DoIter 
         @endiif
         @iif kk = @(vku)
/*    last iteration : need to update pB accordingly */   
            @define LAST_ITER @1@
            @CALLPROC DoIter 
            @SKIP @undef LAST_ITER
         @endiif
      @endiwhile
KDONE:
         @endiif
            @iif PBLHOIST = 0
         @iif npeel > 1
KDONE:
         @endiif
            @endiif
      @endiif
      @SKIP ******* end of TRMML ***********************
      @iif TRMML = 0
         @iif npeel > 1
KDONE:
         @endiif
      @endiif
   @endiif
         @CALLPROC storeC 6
         @VEC KDIM   `@iexp kk @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *`
         @VEC ! KDIM `@iexp kk @(mu) @(nu) *`
   @iif @iexp @(DOMLOOP) @(DONLOOP) |
         pC += @(kk);
   @iif TRMM = 0
   @SKIP **** no fully unrolled KLOOP !!! 
@BEGINSKIP 
      @iif NOKLOOP ! 0
         pB += incBn;
      @endiif
      @iif ku ! kb
         pA = pA0;
      @endiif
@ENDSKIP
         pA = pA0;
   @endiif
      @iif TRMM ! 0
         @iif TRMML ! 0
            @iif PBLHOIST = 0
         pB += incBn;
            @endiif
         @SKIP /*pB += incBn;*/
         pA = pA0;
         @endiif
         @iif TRMM = 3
         @iif nu < @(ku)
         off += @(nu); 
         if (off >= @(ku)) { off -= @(ku); Aoff += @(mu)*@(ku); }
         @endiif
         @iif nu } @(ku)
         Aoff += @(mu)*@(nu);
         @endiif
         pA = pA0 + Aoff; /* for Right-lower, adjust starting point */
         @endiif
         @iif TRMM = 4
         pA = pA0; /* for Right-upper, go to original start */
         @endiif
      @endiif
   @endiif
@VEC KDIM
   @iif @iexp @(DONLOOP)
      @iif TRI = 0
         @SKIP j =  nnus;
         @iif TRMMR = 0
         j = nnus;
         @endiif
         @iif TRMMR ! 0
         J = 0;
         j = nnus;
         @endiif
      @endiif
      @iif TRI = 1
         @iif SQSYRK = 1
         j = i;
         @endiif
         @iif SYRKU = 1
         j = 0;
         @endiif
      @endiif
         NLOOP:
   @endiif
      @skip pref inside rc_zerod proc
      @CALLPROC RC_ZEROD
      @skip started kloop
   @iif NOKLOOP = 0
      LOOP k=0, @(ATL_MM_KB), @(ku)       
      LOOP_BODY
      @iexp IN_K 0 1 +
         @CALLPROC DoIter_kvec
      LOOP_END
   @endiif
   @iif NOKLOOP ! 0
      @iexp kk 0 @(vl) +
      LOOP k=0, @(ATL_MM_KB), @(kk)       
      LOOP_BODY
      @iexp IN_K 0 1 +
            @CALLPROC DoIter_kvec
      LOOP_END
   @endiif
         @CALLPROC storeC 6
         @iexp kk @(vl) @(mu) @(nu) * @(vl) + -1 + / @(vl) *
      @iif @iexp @(DOMLOOP) @(DONLOOP) |
         pC += @(kk);
         pA = pA0;
      @endiif
@VEC !
   @iif @iexp @(DONLOOP)
      @SKIP }  /* end of loop over N */
      @iif TRMM = 0
         @iif TRI = 0
            j = j - 1;
            IF (j > 0) GOTO NLOOP;
         @endiif
         @iif TRI = 1
            @iif SQSYRK = 1
            j = j - 1;
            IF (j >= 0) GOTO NLOOP;
            @endiif
            @iif SYRKU = 1
            @SKIP *** FIXME: dowhile style loop, need to check !!!
            j = j + @(nu);
            IF (j < in) GOTO NLOOP;
            @endiif
         @endiif
      @endiif
   @endiif
   @iif @iexp @(DOMLOOP)
      @iif TRMML = 0
      pB = pB0;
      pA0 += incAm;
      pA = pA0;
      @endiif
      @iif TRMML ! 0
         pA0 += incAm;
         pA = pA0;
         pB = pB0;
      @iif TRMM = 1
         @iif mu < @(ku)
         off += @(mu);
         if (off >= @(ku)) 
         {
            off -= @(ku);
            incAm += @(mu)*@(ku); incBn -= @(nu)*@(ku);
         }
         @endiif
         @iif mu } @(ku)
            incAm += @(mu)*@(mu);
            incBn -= @(nu)*@(mu);
         @endiif
         incBn = incBn < 0 ? 0 : incBn;
      @endiif
      @iif TRMM = 2
         @iif mu < @(ku)
         off += @(mu);
         if (off >= @(ku)) 
         {
            off -= @(ku);
            incAm -= @(mu)*@(ku); incBn += @(nu)*@(ku);
         }
         @endiif
         @iif mu } @(ku)
            incAm -= @(mu)*@(mu);
            incBn += @(mu)*@(nu);
         @endiif
         pB += incBn;
      @endiif
      @endiif
   @SKIP }  /* end of loop over M */
   @iif @iexp @(DOMLOOP)
      @iif TRI = 0
      i = i - 1;
      IF (i > 0) GOTO MLOOP;
      @endiif
      @iif TRI = 1 
         @iif SQSYRK = 1
      i = i - 1;
      IF (i > 0) GOTO MLOOP;
         @endiif
         @iif SYRKU = 1
      i = i + @(mu);
      IF (i < MM) GOTO MLOOP;
         @endiif
      @endiif
   @endiif
   @endiif
@SKIP }
ROUT_END
