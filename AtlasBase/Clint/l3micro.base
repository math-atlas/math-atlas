@ROUT ATL_ipsyr2k
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))

#ifdef Conj_
int Mjoin(PATL,ipher2k)
#else
int Mjoin(PATL,ipsyr2k)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
   const TYPE rbeta,
      #define IFLG 1
   #else
      #define IFLG 0
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   ablk2cmat_t blk2C_b0, blk2C_b1;
   ATL_SZT sz, szA, szB, nfnblks, nnblks, nkblks;
   unsigned int szC, MVS=0;
   TYPE *aC, *bC;  /* access- and block-major C */
   TYPE *aA, *aB;  /* access-major A & B */
   void (*syput)(ATL_CSZT N, const TYPE *D, const SCALAR beta0, TYPE *A, 
                 ATL_CSZT lda);
   void (*geputT)(ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
                  const SCALAR beta, TYPE *C, ATL_CSZT ldc);
   #ifdef TCPLX
      TYPE *aCr;
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero}, *ONE;
      #ifdef Conj_
         const TYPE beta[2]={rbeta, ATL_rzero};
      #endif
   #else
      #define ZERO ATL_rzero
      #define ONE ATL_rone
      #define aCr aC
   #endif
   ipinfo_t ip;
   #ifdef Conj_
      const enum ATLAS_TRANS TB = (TA == AtlasConjTrans) ? 
         AtlasNoTrans:AtlasConjTrans;
   #else
      const enum ATLAS_TRANS TB = (TA == AtlasTrans) ? 
         AtlasNoTrans:AtlasTrans;
   #endif
   if (!N)
      return(0);
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ONE(beta))
         return(0);
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return(0);
   }
   Mjoin(PATL,ipmenInfo)(&ip, TA, TB, N, N, K, lda, ldb, ldc, alpha, ZERO);
   blk2C_b0 = ip.blk2c;
   blk2C_b1 = ip.blk2c_b1;
   #ifdef TCPLX
      ONE = ip.ONE;
      #ifdef Conj_
         if (rbeta == ATL_rone)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b1):Mjoin(PATL,her2k_putL_b1));
            geputT = Mjoin(PATL,geput1H_b1);
         }
         else if (rbeta == ATL_rzero)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b0):Mjoin(PATL,her2k_putL_b0));
            geputT = Mjoin(PATL,geput1H_b0);
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_bXi0):Mjoin(PATL,her2k_putL_bXi0));
            geputT = (rbeta == ATL_rnone) ?  
               Mjoin(PATL,geput1H_bN) : Mjoin(PATL,geput1H_bX);
         }
      #else
         if (beta[1] == ATL_rzero) /* real beta */
         {
            const TYPE rb=(*beta);
            if (rb == ATL_rone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
               geputT = Mjoin(PATL,geput1T_b1);
            }
            else if (rb == ATL_rzero)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
               geputT = Mjoin(PATL,geput1T_b0);
            }
            else if (rb == ATL_rnone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_bn1):Mjoin(PATL,syr2k_putL_bn1));
               geputT = Mjoin(PATL,geput1T_bN);
            }
            else
            {
               syput = ((Uplo == AtlasUpper) ? 
                       Mjoin(PATL,syr2k_putU_bXi0):Mjoin(PATL,syr2k_putL_bXi0));
               geputT = Mjoin(PATL,geput1T_bX);
            }
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
            geputT = Mjoin(PATL,geput1T_bX);
         }
      #endif
   #else
      if (beta == ATL_rone)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
         geputT = Mjoin(PATL,geput1T_b1);
      }
      else if (beta == ATL_rzero)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
         geputT = Mjoin(PATL,geput1T_b0);
      }
      else
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
         geputT = (beta == ATL_rnone) ? 
            Mjoin(PATL,geput1T_bN) : Mjoin(PATL,geput1T_bX);
      }
   #endif
   nfnblks = ip.nfnblks;
   nnblks = nfnblks + ip.npnblks;
   nkblks = ip.nfkblks + 1;
/*
 * This algorithm requires allocating all of A & B + 2 blks for C 
 */
   szC = ip.szC;
   if (nnblks > 1)
   {
      szA = (nfnblks*ip.szA + ip.npnblks*ip.pszA)*nkblks;
      szB = (nfnblks*ip.szB + ip.npnblks*ip.pszB)*nkblks;
      MVS=3;
   }
   else if (nfnblks)
   {
     szA = ip.szA;
     szB = ip.szB;
   }
   else
   {
     szA = ip.pszA;
     szB = ip.pszB;
   }
   sz = ATL_MulBySize(szA+szB+szC+szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);

   bC = ATL_AlignPtr(vp);
   aC = bC + (szC SHIFT);
   aC = ATL_AlignPtr(aC);
   #ifdef TCPLX
     aCr = aC + szC;
     aA = aCr + szC;
   #else
      aA = aC + szC;
   #endif
   aA = ATL_AlignPtr(aA);
   aB = aA + (szA SHIFT);
   aB = ATL_AlignPtr(aB);
/*
 * Now, set sz[A,B] for incr workspace ptrs
 */
   if (nnblks > 1)
   {
      szA = ip.szA;
      szB = ip.szB;
      szA *= nkblks SHIFT;
      szB *= nkblks SHIFT;
   }
   else   /* just reusing same A/B space for 1 blk C! */
      szA = szB = 0;

   if (Uplo == AtlasLower)
   {
      ATL_iptr_t imsk = ~(0L);
      ATL_SZT j;
      ATL_CUINT NB = (nfnblks) ? ip.nb : ip.pnb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, wAj += szA, wBj += szB)
      {
         TYPE *wAi=wAj+szA, *wBi=wBj+szB;
         TYPE *pC = C;
         ATL_SZT incA, incB, i;
         ATL_UINT n;

         if (j < nfnblks)
         {
            n = NB;
            incA = ip.incAm & imsk;
            incB = ip.incBn & imsk;
         }
         else
         {
            n = ip.nF;
            incA = ip.pincAm & imsk;
            incB = ip.pincBn & imsk;
         }
/*
 *       First do diagonal block
 */
         ip.ldc = n;
         Mjoin(PATL,iploopsK)(&ip, j, j, A, B, bC, MVS, wAj, wBj, aCr, aC, 
                              ZERO, blk2C_b0);
         syput(n, bC, beta, pC, ldc);
         pC += n SHIFT;
         A += incA;
         B += incB;
         for (i=j+1; i < nnblks; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            if (i < nfnblks)
            {
               m = NB;
               incA = ip.incAm & imsk;
               incB = ip.incBn & imsk;
            }
            else
            {
               m = ip.mF;
               incA = ip.pincAm & imsk;
               incB = ip.incBn & imsk;
            }
            ip.ldc = n;
            Mjoin(PATL,iploopsK)(&ip, j, i, NULL, B, bC, 3, wAj, wBi, aCr, aC, 
                                 ZERO, blk2C_b0);
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            if (m == n)
            {
               Mjoin(PATL,iploopsK)(&ip, i, j, A, NULL, bC, 3, wAi, wBj, 
                                    aCr, aC, ONE, blk2C_b1);
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
            {
               ip.ldc = ldc;
               Mjoin(PATL,iploopsK)(&ip, i, j, A, NULL, pC, 3, wAi, wBj, 
                                    aCr, aC, ONE, blk2C_b1);
            }
            pC += m SHIFT;
            A += incA;
            B += incB;
         }
         A = NULL;
         B = NULL;
         imsk = 0L;
         C += NB*((ldc+1)SHIFT);
      }
   }
   else   /* C is symmetric matrix stored in Upper format */
   {
      ATL_CSZT incB = (nfnblks) ? ip.incBn : ip.pincBn;
      ATL_CSZT incA = (nfnblks) ? ip.incAm : ip.pincAm;
      ATL_SZT j;
      ATL_CUINT NB = (nfnblks) ? ip.nb : ip.pnb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += NB*(ldc SHIFT), wAj += szA, wBj += szB)
      {
         const TYPE *aa=A, *bb=B;
         TYPE *wAi=aA, *wBi=aB;
         TYPE *pC = C;
         ATL_SZT i, incA;
         ATL_UINT n;

         if (j < nfnblks)
         {
            n = NB;
            incA = ip.incAm;
         }
         else
         {
            n = ip.nF;
            incA = ip.pincAm;
         }
         for (i=0; i < j; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            ip.ldc = n;
            Mjoin(PATL,iploopsK)(&ip, j, i, aa, NULL, bC, 3, wAj, wBi, aCr, aC,
                                 ZERO, blk2C_b0);
            aa = NULL;
            if (i < nfnblks)
               m = NB;
            else
               m = ip.mF;
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);

            if (m == n)
            {
               Mjoin(PATL,iploopsK)(&ip, i, j, NULL, bb, bC, 3, wAi, wBj,
                                    aCr, aC, ONE, blk2C_b1);
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
            {
               ip.ldc = ldc;
               Mjoin(PATL,iploopsK)(&ip, i, j, NULL, bb, pC, 3, wAi, wBj,
                                    aCr, aC, ONE, blk2C_b1);
            }
            bb = NULL;
            pC += m SHIFT;
         }
/*
 *       Do diagonal block to copy new A block
 */
         ip.ldc = n;
         Mjoin(PATL,iploopsK)(&ip, j, j, aa, bb, bC, MVS, wAj, wBj, aCr, aC,
                              ZERO, blk2C_b0);
         syput(n, bC, beta, pC, ldc);
         B += incB;
         A += incA;
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_opsyr2k
@extract -b @(topd)/cw.inc lang=C -def cwdate 2017
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#ifdef Conj_
   #define syr2k_OP Mjoin(PATL,opher2k)
#else
   #define syr2k_OP Mjoin(PATL,opsyr2k)
#endif

int syr2k_OP
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
   const TYPE rbeta,
      #define IFLG 1
   #else
      #define IFLG 0
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   ablk2cmat_t blk2C_b0, blk2C_b1;
   ATL_SZT sz, szA, szB, nfnblks, nnblks;
   unsigned int szC;
   unsigned int mb, nb, KB;
   TYPE *aC, *bC;  /* access- and block-major C */
   TYPE *aA, *aB;  /* access-major A & B */
   void (*syput)(ATL_CSZT N, const TYPE *D, const SCALAR beta0, TYPE *A, 
                 ATL_CSZT lda);
   void (*geputT)(ATL_CSZT M, ATL_CSZT N, const TYPE *A, ATL_CSZT lda, 
                  const SCALAR beta, TYPE *C, ATL_CSZT ldc);
   #ifdef TCPLX
      TYPE *aCr;
      const TYPE ZERO[2] = {ATL_rzero, ATL_rzero}, *ONE;
      #ifdef Conj_
         const TYPE beta[2]={rbeta, ATL_rzero};
      #endif
   #else
      #define ZERO ATL_rzero
      #define ONE ATL_rone
      #define aCr aC
   #endif
   opinfo_t op;

   if (!N)
      return(0);
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      if (SCALAR_IS_ONE(beta))
         return(0);
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return(0);
   }
   if (K < 3)
   {
      #if !defined(TCPLX) || defined(Conj_)
         #ifdef Conj_
         if (K == 1 && rbeta == ATL_rone && TA == AtlasNoTrans)
         #else
         if (K == 1 && SCALAR_IS_ONE(beta))
         #endif
         {
            ATL_SZT incA, incB;
            if (TA == AtlasTrans || TA == AtlasConjTrans)
            {
               incA = lda;
               incB = ldb;
            }
            else
            {
               incA = 1;
               incB = 1;
            }
            #ifdef Conj_
               Mjoin(PATL,her2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #else
               Mjoin(PATL,syr2)(Uplo, N, alpha, A, incA, B, incB, C, ldc);
            #endif
            return(0);
         }
      #endif
      #ifdef Conj_
         Mjoin(PATL,refher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              rbeta, C, ldc);
      #else
         Mjoin(PATL,refsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              beta, C, ldc);
      #endif
      return(0);
   }
   blk2C_b0 = Mjoin(PATL,opsyr2kInfo)(&op, IFLG, TA, N, K, lda, ldb, ldc, 
                                      alpha, beta);
   if (!blk2C_b0)
      return(2);
   blk2C_b1 = op.blk2C;
   KB = op.KB;
   #ifdef TCPLX
      ONE = op.ONE;
      #ifdef Conj_
         if (rbeta == ATL_rone)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b1):Mjoin(PATL,her2k_putL_b1));
            geputT = Mjoin(PATL,geput1H_b1);
         }
         else if (rbeta == ATL_rzero)
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_b0):Mjoin(PATL,her2k_putL_b0));
            geputT = Mjoin(PATL,geput1H_b0);
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,her2k_putU_bXi0):Mjoin(PATL,her2k_putL_bXi0));
            geputT = (rbeta == ATL_rnone) ?  
               Mjoin(PATL,geput1H_bN) : Mjoin(PATL,geput1H_bX);
         }
      #else
         if (beta[1] == ATL_rzero) /* real beta */
         {
            const TYPE rb=(*beta);
            if (rb == ATL_rone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
               geputT = Mjoin(PATL,geput1T_b1);
            }
            else if (rb == ATL_rzero)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
               geputT = Mjoin(PATL,geput1T_b0);
            }
            else if (rb == ATL_rnone)
            {
               syput = ((Uplo == AtlasUpper) ? 
                        Mjoin(PATL,syr2k_putU_bn1):Mjoin(PATL,syr2k_putL_bn1));
               geputT = Mjoin(PATL,geput1T_bN);
            }
            else
            {
               syput = ((Uplo == AtlasUpper) ? 
                       Mjoin(PATL,syr2k_putU_bXi0):Mjoin(PATL,syr2k_putL_bXi0));
               geputT = Mjoin(PATL,geput1T_bX);
            }
         }
         else
         {
            syput = ((Uplo == AtlasUpper) ? 
                     Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
            geputT = Mjoin(PATL,geput1T_bX);
         }
      #endif
   #else
      if (beta == ATL_rone)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b1):Mjoin(PATL,syr2k_putL_b1));
         geputT = Mjoin(PATL,geput1T_b1);
      }
      else if (beta == ATL_rzero)
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_b0):Mjoin(PATL,syr2k_putL_b0));
         geputT = Mjoin(PATL,geput1T_b0);
      }
      else
      {
         syput = ((Uplo == AtlasUpper) ? 
                  Mjoin(PATL,syr2k_putU_bX):Mjoin(PATL,syr2k_putL_bX));
         geputT = (beta == ATL_rnone) ? 
            Mjoin(PATL,geput1T_bN) : Mjoin(PATL,geput1T_bX);
      }
   #endif
   nfnblks = op.nfnblks;
   nnblks = nfnblks + op.npnblks;
   if (nfnblks) 
      mb = nb = op.nb;
   else
   {
      mb = op.pmb;
      nb = op.pnb;
   }
/*
 * This algorithm requires allocating all of A & B + 2 blks for C 
 */
   szC = op.szC;
   szA = nfnblks*op.szA + op.npnblks*op.pszA;
   szB = nfnblks*op.szB + op.npnblks*op.pszB;
   sz = ATL_MulBySize(szA+szB+szC+szC) + 4*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);

   bC = ATL_AlignPtr(vp);
   aC = bC + (szC SHIFT);
   aC = ATL_AlignPtr(aC);
   #ifdef TCPLX
     aCr = aC + szC;
     aA = aCr + szC;
   #else
      aA = aC + szC;
   #endif
   aA = ATL_AlignPtr(aA);
   aB = aA + (szA SHIFT);
   aB = ATL_AlignPtr(aB);
   szB = (nfnblks) ? (op.szB SHIFT) : 0;  /* inc between B blks */
   szA = (nfnblks) ? (op.szA SHIFT) : 0;

   if (Uplo == AtlasLower)
   {
      ATL_SZT j;
      ATL_CUINT NB = op.nb;
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += nb*((ldc+1)SHIFT), wAj += szA, wBj += szB)
      {
         TYPE *wAi=wAj+szA, *wBi=wBj+szB;
         TYPE *pC = C;
         ATL_SZT i;
         ATL_UINT nb, n;

         if (j < nfnblks)
            nb = n = NB;
         else
         {
            nb = op.pnb;
            n = op.nF;
         }
/*
 *       First do diagonal block
 */
         Mjoin(PATL,opblk)(&op, j, j, A, B, NULL, wAj, wAj, 
                           wBj, wBj+szB, aCr, aC);
         #ifdef TCPLX
            blk2C_b0(n, n, ONE, aCr, aC, ZERO, bC, n);
         #else
            blk2C_b0(n, n, ONE, aC, ZERO, bC, n);
         #endif
         syput(n, bC, beta, pC, ldc);
         pC += n SHIFT;
         for (i=j+1; i < nnblks; i++, wAi += szA, wBi += szB)
         {
            ATL_CSZT in = (i < nnblks-1) ? i+1 : 0;
            ATL_UINT mb, m;
            if (i < nfnblks)
               mb = m = NB;
            else
            {
               mb = op.pmb;
               m = op.mF;
            }
            Mjoin(PATL,opblk)(&op, j, i, NULL, B, NULL, wAj, wAi, 
                              wBi, wBj, aCr, aC);
            #ifdef TCPLX
               blk2C_b0(n, m, ONE, aCr, aC, ZERO, bC, n);
            #else
               blk2C_b0(n, m, ONE, aC, ZERO, bC, n);
            #endif
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            Mjoin(PATL,opblk)(&op, i, j, A, NULL, NULL, wAi, wAj+szA, 
                              wBj, wBi+szB, aCr, aC);
            if (m == n)
            {
               #ifdef TCPLX
                  blk2C_b1(n, n, ONE, aCr, aC, ONE, bC, n);
               #else
                  blk2C_b1(n, n, ONE, aC, ONE, bC, n);
               #endif
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
               #ifdef TCPLX
                  blk2C_b1(m, n, ONE, aCr, aC, ONE, pC, ldc);
               #else
                  blk2C_b1(m, n, ONE, aC, ONE, pC, ldc);
               #endif
            pC += m SHIFT;
         }
         A = NULL;
         B = NULL;
      }
   }
   else
   {
      ATL_SZT j;
      ATL_CUINT NB = Mmin(mb,nb);
      TYPE *wAj=aA, *wBj=aB;

      for (j=0; j < nnblks; j++, C += nb*(ldc SHIFT), wAj += szA, wBj += szB)
      {
         const TYPE *aa=A, *bb=B;
         TYPE *wAi=aA, *wBi=aB;
         TYPE *pC = C;
         ATL_SZT i;
         ATL_UINT n;

         if (j < nfnblks)
            nb = n = NB;
         else
         {
            nb = op.pnb;
            n = op.nF;
         }
         for (i=0; i < j; i++, wAi += szA, wBi += szB)
         {
            ATL_UINT m;
            if (i < nfnblks)
               mb = m = NB;
            else
            {
               mb = op.pmb;
               m = op.mF;
            }
            Mjoin(PATL,opblk)(&op, j, i, aa, NULL, NULL, wAj, wAi,
                              wBi, wBj, aCr, aC);
            aa = NULL;
            #ifdef TCPLX
               blk2C_b0(n, m, ONE, aCr, aC, ZERO, bC, n);
            #else
               blk2C_b0(n, m, ONE, aC, ZERO, bC, n);
            #endif
            if (m == n)
            {
               Mjoin(PATL,sqtrans)(n, bC, n);
               #ifdef Conj_  /* need hermitian transpose for HER2K! */
                  Mjoin(PATLU,scal)(n*n, ATL_rnone, bC+1, 2);
               #endif
            }
            else
               geputT(m, n, bC, n, beta, pC, ldc);
            Mjoin(PATL,opblk)(&op, i, j, NULL, bb, NULL, wAi, wAj+szA,
                              wBj, wBi+szB, aCr, aC);
            bb = NULL;
            if (m == n)
            {
               #ifdef TCPLX
                  blk2C_b1(n, n, ONE, aCr, aC, ONE, bC, n);
               #else
                  blk2C_b1(n, n, ONE, aC, ONE, bC, n);
               #endif
               Mjoin(PATL,geadd)(n, n, ONE, bC, n, beta, pC, ldc);
            }
            else
               #ifdef TCPLX
                  blk2C_b1(m, n, ONE, aCr, aC, ONE, pC, ldc);
               #else
                  blk2C_b1(m, n, ONE, aC, ONE, pC, ldc);
               #endif
            pC += m SHIFT;
         }
/*
 *       Do diagonal block to copy new A block
 */
         Mjoin(PATL,opblk)(&op, j, j, aa, bb, NULL, wAj, wAj,
                           wBj, wBj+szB, aCr, aC);
         #ifdef TCPLX
            blk2C_b0(n, n, ONE, aCr, aC, ZERO, bC, n);
         #else
            blk2C_b0(n, n, ONE, aC, ZERO, bC, n);
         #endif
         syput(n, bC, beta, pC, ldc);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_syr2k
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level3.h"
#if 0
   #define USEREF 1
   #include "atlas_reflevel3.h"
#endif
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#ifdef Conj_
   #define SYR2K Mjoin(PATL,her2k)
   #define IFLG 4
#else
   #define SYR2K Mjoin(PATL,syr2k)
   #define IFLG 0
#endif
#ifdef Conj_
int Mjoin(PATL,opher2k_wrap)
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   return(Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                              *beta, C, ldc));
}
#else
typedef int (*syr2k_t)(const enum ATLAS_UPLO, const enum ATLAS_TRANS, 
                       ATL_CSZT, ATL_CSZT, const SCALAR, 
                       const TYPE*, ATL_CSZT, const TYPE*, ATL_CSZT, 
                       const SCALAR, TYPE*, ATL_CSZT);
void Mjoin(PATL,syr2k_rec)
(
   ATL_CUINT bv, /* 0:Upper?, 1:Transpose?, 2:HER2K? */
   ATL_CSZT  N,
   ATL_CSZT K,  /* if NoTrans, ncols of A&B, else nrows A&B */
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc,
   void *syr2kOP
)
{
   const enum ATLAS_UPLO UL=(bv&1) ? AtlasUpper:AtlasLower;
   #ifdef TCPLX
      const TYPE ONE[2] = {ATL_rone, ATL_rzero};
      enum ATLAS_TRANS TA;
      if (bv&4)
         TA = (bv&2) ? AtlasConjTrans : AtlasNoTrans;
      else
         TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TA = (bv&2) ? AtlasTrans : AtlasNoTrans;
      #define ONE ATL_rone
   #endif
   if (N == 1)  /* can use dot product! */
   {
      ATL_SZT incA, incB;
      if (bv&2) /* K is rows */
      {
         incA = 1;
         incB = 1;
      }
      else
      {
         incA = lda;
         incB = ldb;
      }
      #ifdef TCPLX
         if (bv&4) /* dotc */
         {
            TYPE dot[2];
            register TYPE rd;
            const register TYPE ra=(*alpha), ia=alpha[1], rb=(*beta);
            if (incA == 1 && incB == 1 && ia == ATL_rzero)
            {
               rd = Mjoin(PATLU,dot)(K+K, A, incA, B, incB);
               rd *= ra;
            }
            else
            {
               register TYPE id;
               Mjoin(PATL,dotc_sub)(K, A, incA, B, incB, dot);
               rd = *dot;
               id = dot[1];
               if (bv&2)
                  rd = rd*ra - id*ia;
               else
                  rd = rd*ra + id*ia;
            }
            rd += rd;
            if (rb == ATL_rzero)
               *C = rd;
            else
               *C = *C * rb + rd;
            C[1] = ATL_rzero;
         }
         else /* dotu */
         {
            TYPE dot[2];
            register TYPE rc, ic, rd, id;
            const register TYPE ra=(*alpha),ia=alpha[1], rb=(*beta),ib=beta[1];
            Mjoin(PATL,dotu_sub)(K, A, incA, B, incB, dot);
            rd = *dot;
            id = dot[1];
            rc = rd*ra - id*ia;  /* multiply by alpha */
            ic = rd*ia + id*ra;
            rc += rc;            /* double it */
            ic += ic;
            if (rb != ATL_rzero || ib != ATL_rzero)  /* apply beta to C */
            {                                        /* and add into answer */
               rd = *C;
               id = C[1];
               rc += rb*rd - ib*id;
               ic += rb*id + ib*rd;
            }
            *C = rc;
            C[1] = ic;
         }
      #else
         TYPE dot;
         dot = Mjoin(PATL,dot)(K, A, incA, B, incB);
         dot *= alpha;
         dot += dot;
         if (beta == ATL_rzero)
            *C = dot;
         else
            *C = *C * beta + dot;
      #endif
       return;
   }
/*
 * If K small enough, need the outer-product version of syrk
 */
   if (K <= ATL_VWopgen_MAX_KB)
   {
      syr2k_t opsyr2k = syr2kOP;
      if (!opsyr2k(UL, TA, N, K, alpha, A, lda, B, ldb, beta, C, ldc))
         return;
   }
/*
 * Try the inner product version for any case outer-product fails on
 */
   {
      #ifdef TCPLX
      if (bv&4)
      {
         if (!Mjoin(PATL,ipher2k)(UL, TA, N, K, alpha, A, lda, B, ldb, 
                                  *beta, C, ldc));
            return;
      }
      else
      #endif
      {
         if (!Mjoin(PATL,ipsyr2k)(UL, TA, N, K, alpha, A, lda, B, ldb, 
                                  beta, C, ldc));
            return;
      }
   }
/*
 *    Splitting K or N reduces mem req by same amount, so split largest.
 *    When we split along N, we wind up with two syr2k calls, and two calls 
 *    to GEMM.
 */
      if (N >= K)
      {
         ATL_SZT NL=N>>1, NR=N-NL;
         const TYPE *an, *bn;
         enum ATLAS_TRANS TA, TB;
         if (bv&2) /* A & B are KxN */
         {
            an = A + (NL SHIFT)*lda;
            bn = B + (NL SHIFT)*ldb;
            #ifdef TCPLX
               TA = (bv&4) ? AtlasConjTrans:AtlasTrans;
            #else
               TA = AtlasTrans;
            #endif
               TB = AtlasNoTrans;
         }
         else      /* A & B are NxK */
         {
            TA = AtlasNoTrans;
            #ifdef TCPLX
               TB = (bv&4) ? AtlasConjTrans:AtlasTrans;
            #else
               TB = AtlasTrans;
            #endif
            an = A + (NL SHIFT);
            bn = B + (NL SHIFT);
         }
         Mjoin(PATL,syr2k_rec)(bv, NL, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc, syr2kOP);
         Mjoin(PATL,syr2k_rec)(bv, NR, K, alpha, an, lda, bn, ldb, 
                               beta, C+((ldc+1)SHIFT)*NL, ldc, syr2kOP);
         if (bv&1) /* Upper */
         {
            C += ldc*(NL SHIFT);
            Mjoin(PATL,ammm)(TA, TB, NL, NR, K, alpha, A, lda, bn, ldb, 
                             beta, C, ldc);
            Mjoin(PATL,ammm)(TA, TB, NL, NR, K, alpha, B, ldb, an, lda, 
                             ONE, C, ldc);
         }
         else
         {
            C += (NL SHIFT);
            Mjoin(PATL,ammm)(TA, TB, NR, NL, K, alpha, an, lda, B, ldb, 
                             beta, C, ldc);
            Mjoin(PATL,ammm)(TA, TB, NR, NL, K, alpha, bn, ldb, A, lda, 
                             ONE, C, ldc);
         }
         return;
      }
/*
 * If we reach here, split K, resulting in 2 syr2k, 2nd with BETA=ONE
 */
   {
      ATL_SZT KL=(K>>1), KR = K - KL;
      Mjoin(PATL,syr2k_rec)(bv, N, KL, alpha, A, lda, B, ldb, 
                            beta, C, ldc, syr2kOP);
      #ifdef TCPLX
         KL += KL;
      #endif
      if (bv&2)  /* K controls rows of A&B */
      {
         A += KL;
         B += KL;
      }
      else       /* K controls cols of A&B */
      {
         A += KL * lda;
         B += KL * ldb;
      }
      Mjoin(PATL,syr2k_rec)(bv, N, KR, alpha, A, lda, B, ldb, ONE, C, ldc, 
                            syr2kOP);
   }
}
   #ifndef TCPLX
      #undef ONE
   #endif
#endif
void SYR2K
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   #ifdef Conj_
      const TYPE rbeta,
   #else
      const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp;
   #ifdef Conj_
      const TYPE beta[2] = {rbeta, ATL_rzero};
   #endif
   ATL_UINT bv;

   #ifdef USEREF
      #ifdef Conj_
         Mjoin(PATL,refher2k)(Uplo, TA, N, K, alpha, A,lda, B,ldb,rbeta,C,ldc);
      #else
         Mjoin(PATL,refsyr2k)(Uplo, TA, N, K, alpha, A,lda, B,ldb, beta,C,ldc);
      #endif
      return;
   #endif
   if (!N)
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)
   {
      #ifdef Conj_
         if (rbeta == ATL_rone)
            return;
      #else
         if (SCALAR_IS_ONE(beta))
            return;
      #endif
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)<<1);
      #endif
      return;
   }
/*
 * Outer-product syr2k handles degenerate K, along with any 1-block K
 */
   if (K < 3) /* ATL_VWopgen_MAX_KB) */
   #ifdef Conj_
      if (!Mjoin(PATL,opher2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               rbeta, C, ldc))
         return;
      vp = Mjoin(PATL,opher2k_wrap);
      bv = 4;
      if (TA == AtlasConjTrans)
         bv |= 2;
   #else
      if (!Mjoin(PATL,opsyr2k)(Uplo, TA, N, K, alpha, A, lda, B, ldb, 
                               beta, C, ldc))
         return;
      vp = Mjoin(PATL,opsyr2k);
      bv = 0;
      #ifdef TCPLX
         if (TA == AtlasTrans) 
      #else
         if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
            bv |= 2;
   #endif
   bv |= (Uplo == AtlasUpper);
   Mjoin(PATL,syr2k_rec)(bv, N, K, alpha, A, lda, B, ldb, beta, C, ldc, vp);
}
@ROUT ATL_sqsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk)
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrkBlk Mjoin(PATL,sqherkBlk)
   #define syrk_K  Mjoin(PATL,sqherk_KLoop)
   #define syrk  Mjoin(PATL,sqherk)
#else
   #define syrkBlk Mjoin(PATL,sqsyrkBlk)
   #define syrk_K  Mjoin(PATL,sqsyrk_KLoop)
   #define syrk  Mjoin(PATL,sqsyrk)
#endif
/*#define MEM_DEBUG 1*/

void syrkBlk
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   size_t k,      /* which K block of A is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c && non-NULL, which C to write to */
   TYPE *rS,      /* real portion of wS (unused for real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real portion of wC (unused for real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* reflection space for Upper if non-NULL */
)
{
   ATL_CUINT kb = (k != ip->nfkblks) ? ip->kb : ip->kb0;
   ATL_UINT nb, kbS, nnu;
   size_t nfblks = ip->nfnblks;
   #ifdef TCPLX
      TYPE *rA, *rB;
   #endif
   if (d == nfblks + ip->npnblks - 1)
   {
      nb = ip->nF;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + ip->szA;
            rB = wB + ip->szB;
         }
         else
         {
            rA = wA + ip->pszA;
            rB = wB + ip->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = ip->nb;
      #ifdef TCPLX
         rA = wA + ip->szA;
         rB = wB + ip->szB;
      #endif
   }
   else
   {
      nb = ip->pnb;
      #ifdef TCPLX
         rA = wA + ip->pszA;
         rB = wB + ip->pszB;
      #endif
   }
   nnu = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   if (A)  /* want to copy input array */
   {
      A = IdxA_ip(ip, A, d, k);
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, rA, wA);
         #else
            ip->a2blk(kb, nb, ip->alpA, A, ip->lda, wA);
         #endif
         if (ip->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, rB, wB);
         #else
            ip->b2blk(kb, nb, ip->alpB, A, ip->ldb, wB);
         #endif
         if (ip->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, ip->ONE, A, ip->lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, ip->lda, wS);
         #endif
      }
   }
   if (wC && wS)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            if (flag&4)
            {
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            else
            {
               Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
               Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            }
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         if (flag&4)
            Mjoin(PATL,amsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
         else
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=ip->ldc;
      #ifdef TCPLX
         const TYPE *alp = ip->alpC;
      #else
         TYPE alp = ip->alpC;
      #endif
      if (ip->alpA != ip->alpB)
         alp = (ip->alpA != ip->alpC) ? ip->alpA : ip->alpB;
      if (C)
      {
         C = IdxC_ip(ip, C, d, d);
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
   #if 0
   if ((flag&1) && C && wU)  /* need to reflect from Lower to Upper */
   {
      size_t ldc2=(ip->ldc)SHIFT;
      #ifdef Conj_
         for (k=0; k < nb; k++, C += ldc2, wU += 2)
         {
            Mjoin(PATL,axpbyConj)(k+1, ip->ONE, wU, nb, beta, C, 1);
            C[((k+1)<<1)-1] = ATL_rzero;
         }
      #else
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += ldc2)
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, ip->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
      #endif
   }
   #endif
}

/*
 * This helper function computes one block of C by looping over the K dim.
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 */
void syrk_K  /* inner-product based syrk/herk loop over K loop */
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real portion of wS (unused in real routines) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *rC,      /* real portion of wC (unused in real routines) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   const size_t nfkblks = ip->nfkblks;
   size_t k;
   ATL_UINT szA, szB;
   if (d < ip->nfnblks)
      szA = szB = ip->szA;
   else
   {
      szA = ip->pszA;
      szB = ip->pszB;
   }
   #ifdef TCPLX
      szA += szA;
      szB += szB;
   #endif
/*
 * For first K block, use beta=0 kernel to init wC
 */
   if (nfkblks)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, NULL, beta, NULL, rS, wS,
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
   else /* this is first & last block! */
   {
      syrkBlk(ip, flag|4, d, 0, A, sy2blk, blk2c, beta, C, rS, wS,
              wA, wA, wB, wB, rC, wC, wU);
      return;
   }
/*
 * Handle all blocks except first (handled above) & last (handled below)
 */
   for (k=1; k < nfkblks; k++)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag, d, k, A, sy2blk, NULL, beta, NULL, rS, wS,
              wA, wAn, wB, wBn, rC, wC, wU);
      wA = wAn;
      wB = wBn;
   }
/*
 * Last block actually writes to C
 */
   syrkBlk(ip, flag, d, k, A, sy2blk, blk2c, beta, C, rS, wS,
           wA, wA, wB, wB, rC, wC, wU);
}

int syrk
(
   ipinfo_t *ip,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   void *vp=NULL;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int ierr;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   /*Mjoin(PATL,ipmenInfo)(&ip, TA, TB, N,N,K, lda, lda, ldc, alpha, beta);*/
   #if 0
   printf("D=(%u,%u), B=(%u,%u,%u), b=(%u,%u,%u), nB=(%u,%u,%u)\n",
          (unsigned int)N,(unsigned int)K, ip.mb, ip.nb, ip.kb,
          ip->pmb, ip->pnb, ip->kb0, ip->nfmblks, ip->nfnblks, ip->nfkblks);
   #endif
/*
 * Will eventually need syrk timed for all square blocks to select best case.
 * For now, just pretend syrk time doesn't matter
 */
/*
 * Need space for only one column-panel of At
 */
   szB = ip->nfnblks ? ip->szA : ip->pszA;
   szB *= (ip->nfkblks+1);
/*
 * A needs entire matrix minus one row/col panel
 */
   szA = szB * (ip->nfnblks + ip->npnblks - 1);
   nb = (ip->nfnblks) ? ip->nb : ip->pnb;
   nbS = (nb+ATL_SYRKK_NU-1)/ATL_SYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SYRKK_NU;
   szC *= ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
          * ATL_SYRKK_VLEN;
   extra = ip->exsz;
   extra = Mmax(extra, (ATL_SYRKK_NU+ATL_SYRKK_NU)*ATL_SYRKK_NU);
   szS = ((ip->kb + ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   szS *= nbS;
   sz = Mmax(ip->szC,szC);
   sz = ATL_MulBySize(sz + szS + szA+szB + extra) + 5*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szB SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   if (!szA)
      wA = NULL;
   wCs = wC;
   #ifdef TCPLX
      rC = wC + ip->szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rCs = rC = wC;
      rS = wS;
   #endif
/*
 * ============================================================================
 * First, we compute diagonals of C, and in the process we will copy A/A^T
 * for use in computing non-diaginal blocks using inner-product amm.
 * ============================================================================
 */
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_syrkT) : Mjoin(PATL,a2blk_syrkN);

   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
   }
   nnblks = ip->nfnblks + ip->npnblks;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
/*
 * Upper doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   if (Uplo == AtlasUpper)
   {
      flg |= 1;
      syrk_K(ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL,
             rCs, wC, wCs);
      if (N > nb)
      {
         const size_t incC = nb*((ldc+1)SHIFT);
         size_t i;
/*
 *       Compute all C blks within this rowpan of C, copy rest of At
 */
         blk2c = ip->blk2c;
         Mjoin(PATL,iploopsNK)(ip, 0, 1, NULL, A, C, 11, wB, wA, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         for (i=1; i < nnblks-1; i++)
         {
            syrk_K(ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, wB, NULL,
                   rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsNK)(ip, i, i+1, NULL, NULL, C+i*(nb SHIFT), 11,
                                  wB, wA, rC, wC, beta, blk2c);
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(ip, flg, i, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, NULL,
                rCs, wC, wCs);
      }
   }
/*
 * Lower doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   else
   {
      const size_t incC = (ldc SHIFT) * nb;
      size_t j;
      TYPE *c;
/*
 *    Compute first diag block, copying At to wB for use by all of this colpan
 *    of C's gemm computation
 */
      syrk_K(ip, flg, 0, A, sy2blk, blk2sy, beta, C, rS, wS, NULL, wB,
             rCs, wC, wCs);
      if (N > nb)
      {
/*
 *       Compute all C blks within this colpan of C, copying rest of A
 */
         blk2c = ip->blk2c;
         Mjoin(PATL,iploopsMK)(ip, 1, 0, A, NULL, C, 7, wA, wB, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         c = C + incC;
         for (j=1; j < nnblks-1; j++)
         {
            syrk_K(ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS,
                   NULL, wB, rCs, wC, wCs);
            wA += szB SHIFT;
            Mjoin(PATL,iploopsMK)(ip, j+1, j, NULL, NULL, c, 7, wA, wB, rC, wC,
                                  beta, blk2c);
            c += incC;
         }
/*
 *       Last colpan is only 1 diag blk, so don't copy A or B for gemm
 */
         syrk_K(ip, flg, j, A, sy2blk, blk2sy, beta, C, rS, wS,
                NULL, NULL, rCs, wC, wCs);
      }
   }
   free(vp);
   return(0);
}
@ROUT ATL_umsyrk ATL_ursyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@ROUT ATL_ursyrk `#include Mstr(Mjoin(ATLAS_PRE,amm_ursyrk.h))` 
@ROUT ATL_umsyrk `#include Mstr(Mjoin(ATLAS_PRE,amm_umsyrk.h))` 
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk)
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
@ROUT ATL_umsyrk `   #define syrkBlk Mjoin(PATL,umherkBlk)`
@ROUT ATL_ursyrk `   #define syrkBlk Mjoin(PATL,urherkBlk)`
@ROUT ATL_umsyrk `   #define syrk_K  Mjoin(PATL,umherk_KLoop)`
@ROUT ATL_ursyrk `   #define syrk_K  Mjoin(PATL,urherk_KLoop)`
@ROUT ATL_umsyrk `   #define syrk  Mjoin(PATL,umherk)`
@ROUT ATL_ursyrk `   #define syrk  Mjoin(PATL,urherk)`
#else
@ROUT ATL_umsyrk `   #define syrkBlk Mjoin(PATL,umsyrkBlk)`
@ROUT ATL_ursyrk `   #define syrkBlk Mjoin(PATL,ursyrkBlk)`
@ROUT ATL_umsyrk `   #define syrk_K  Mjoin(PATL,umsyrk_KLoop)`
@ROUT ATL_ursyrk `   #define syrk_K  Mjoin(PATL,ursyrk_KLoop)`
@ROUT ATL_umsyrk `   #define syrk  Mjoin(PATL,umsyrk)`
@ROUT ATL_ursyrk `   #define syrk  Mjoin(PATL,ursyrk)`
#endif
@SKIP /*#define MEM_DEBUG 1*/

void syrkBlk
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans*/
   size_t d,      /* which global diagonal blk of C is being computed */
   size_t k,      /* which K block of A is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   const TYPE *B, /* if non-NULL, base A ptr to copy */
@ROUT ATL_umsyrk
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
@ROUT ATL_ursyrk
   ablk2tcmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
@ROUT ATL_umsyrk ATL_ursyrk
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c && non-NULL, which C to write to */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real portion of wC (unused for real routines) */
   TYPE *wC      /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   ATL_CUINT kb = (k != ip->nfkblks) ? ip->kb : ip->kb0;
   ATL_UINT mb, nb, kbS, nnu, nmu;
   size_t nfblks = ip->nfnblks;
   #ifdef TCPLX
      TYPE *rA, *rB;
   #endif
   if (d == nfblks + ip->npnblks - 1)
   {
      nb = ip->nF;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + ip->szA;
            rB = wB + ip->szB;
         }
         else
         {
            rA = wA + ip->pszA;
            rB = wB + ip->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = ip->nb;
      #ifdef TCPLX
         rA = wA + ip->szA;
         rB = wB + ip->szB;
      #endif
   }
   else
   {
      nb = ip->pnb;
      #ifdef TCPLX
         rA = wA + ip->pszA;
         rB = wB + ip->pszB;
      #endif
   }
/*
 * calc nmu and nnu. one must be multiple of other
 */
   if (ip->mu > ip->nu)
   {
      nmu = (nb+ip->mu-1)/ip->mu;
      nnu = nmu * (ip->mu/ip->nu); /* NU must be multiple of MU */
   }
   else
   {
      nnu = (nb+ip->nu-1)/ip->nu;
      nmu = nnu * (ip->nu/ip->mu); /* NU must be multiple of MU */
   }
   kbS = ((kb+ip->ku-1)/ip->ku)*ip->ku; /* same as KB0 */
/*
 * copy A
 */
   if (A)  /* want to copy input array */
   {
      A = IdxA_ip(ip, A, d, k);
      #ifdef TCPLX
         ip->a2blk(kb, nb, ip->alpA, A, ip->lda, rA, wA);
      #else
         ip->a2blk(kb, nb, ip->alpA, A, ip->lda, wA);
      #endif
   }
   if (B)
   {
      B = IdxB_ip(ip, B, k, d);
      #ifdef TCPLX
         ip->b2blk(kb, nb, ip->alpB, B, ip->ldb, rB, wB);
      #else
         ip->b2blk(kb, nb, ip->alpB, B, ip->ldb, wB);
      #endif
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         if (flag&4)
         {
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         }
         else
         {
            Mjoin(PATL,amsyrkK_bn)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
            Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         }
         Mjoin(PATL,amsyrkK_bn)(nmu, nnu, kbS, rA, rB, rC, wA, rB, wC);
         Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, wA, rB, wC, wA, wB, wC);
      #else
         if (flag&4)
            Mjoin(PATL,amsyrkK_b0)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
         else
            Mjoin(PATL,amsyrkK_b1)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=ip->ldc;
      #ifdef TCPLX
         const TYPE *alp = ip->alpC;
      #else
         TYPE alp = ip->alpC;
      #endif
      if (ip->alpA != ip->alpB)
         alp = (ip->alpA != ip->alpC) ? ip->alpA : ip->alpB;
      if (C)
      {
@ROUT ATL_ursyrk
         ATL_UINT shVL;
         for (shVL=0; !(ip->vlen&(1<<shVL)); shVL++) ;
@ROUT ATL_umsyrk ATL_ursyrk
         C = IdxC_ip(ip, C, d, d);
         #ifdef TCPLX
@ROUT ATL_ursyrk
            blk2c(nb, ip->mu, ip->nu, shVL, alp, rC, wC, beta, C, ldc);
@ROUT ATL_umsyrk             
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
@ROUT ATL_umsyrk ATL_ursyrk
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
@ROUT ATL_ursyrk
            blk2c(nb, ip->mu, ip->nu, shVL, alp, wC, beta, C, ldc);
@ROUT ATL_umsyrk             
            blk2c(nb, nb, alp, wC, beta, C, ldc);
@ROUT ATL_umsyrk ATL_ursyrk
         #endif
      }
   }
}

void syrk_K  /* inner-product based syrk/herk loop over K loop */
(
   ipinfo_t *ip,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans*/
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   const TYPE *B, /* if non-NULL, base B ptr to copy */
@ROUT ATL_ursyrk
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
@ROUT ATL_umsyrk             
   ablk2tcmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
@ROUT ATL_umsyrk ATL_ursyrk
   const SCALAR beta, /* only needed if blk2c non-NULL */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *wA,      /* if non-NULL, ip-based A workspace */
   TYPE *wB,      /* if non-NULL ip-based At workspace */
   TYPE *rC,      /* real portion of wC (unused in real routines) */
   TYPE *wC       /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   const size_t nfkblks = ip->nfkblks;
   size_t k;
   ATL_UINT szA, szB;
   if (d < ip->nfnblks)
   {
      /*szA = szB = ip->szA;*/
      szA = ip->szA;
      szB = ip->szB;
   }
   else
   {
      szA = ip->pszA;
      szB = ip->pszB;
   }
   #ifdef TCPLX
      szA += szA;
      szB += szB;
   #endif
/*
 * For first K block, use beta=0 kernel to init wC
 */
   if (nfkblks)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag|4, d, 0, A, B, NULL, beta, NULL, wA,wAn, wB,wBn,
                 rC, wC);
      wA = wAn;
      wB = wBn;
   }
   else /* this is first & last block! */
   {
      syrkBlk(ip, flag|4, d, 0, A, B, blk2c, beta, C, wA, wA, wB, wB,
                rC, wC);
      return;
   }
/*
 * Handle all blocks except first (handled above) & last (handled below)
 */
   for (k=1; k < nfkblks; k++)
   {
      TYPE *wAn=(wA)? wA+szA:NULL, *wBn=(wB) ? wB+szB : NULL;
      syrkBlk(ip, flag, d, k, A, B, NULL, beta, NULL, wA, wAn, wB, wBn,
                rC, wC);
      wA = wAn;
      wB = wBn;
   }
/*
 * Last block actually writes to C
 */
   syrkBlk(ip, flag, d, k, A, B, blk2c, beta, C, wA,wA, wB,wB, rC,wC);
}

int syrk
(
   ipinfo_t *ip,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   void *vp=NULL;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int k, ierr;
@ROUT ATL_ursyrk
   ablk2cmat_t blk2c;
   ablk2tcmat_t blk2sy;
@ROUT ATL_umsyrk             
   ablk2cmat_t blk2sy, blk2c;
@ROUT ATL_umsyrk ATL_ursyrk
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
@BEGINSKIP
/*
 * for debugging the memory overflow, we want to allocate workspaces 
 * individually. not doing it for the performance otherwise. 
 */
#ifdef MEM_DEBUG
   void *vA=NULL, *vB=NULL, *vC=NULL;
#endif
@ENDSKIP
   /*Mjoin(PATL,ipmenUMInfo)(&ip, TA, TB, N,N,K, lda, lda, ldc, alpha, beta);*/
   nb = (ip->nfnblks) ? ip->nb : ip->pnb;
   nnblks = ip->nfnblks + ip->npnblks;
/*
 * Main idea:
 * 1. with syrk+gemm of full blks, syrk can always reuse the workspace of gemm
 *    no need to allocate extra space for syrk
 * 2. syrk only: need to allocate only considering the syrk
 */
/*
 * Need space for only one column-panel of At
 */
   szB = ip->nfnblks ? ip->szA : ip->pszA;
   szB *= (ip->nfkblks+1);
/*
 * space calc for single syrk block
 */
   if (nnblks == 1)    /* single blk in n-dimension: syrk only*/
   {
      int smnu=(ip->mu > ip->nu)?ip->mu:ip->nu; /* max of mu, nu*/
      nbS = (nb+smnu-1)/smnu;
      szC = ((nbS+1)*nbS)>>1;
      nbS *= smnu;
/*
 *    considering mu and nu as one is multiple of other, the size of subblock
 *    is smnu*smnu (rounded with ku).
 */
      szC *= ((smnu*smnu+ip->ku-1)/ip->ku)*ip->ku;
      szS =  ((ip->kb+ip->ku-1)/ip->ku)*ip->ku;
      szA = nbS * szS * (ip->nfkblks + 1);
      extra = (smnu+smnu)*smnu;  /* may not need */
   }
   else
   {
/*
 *    A needs entire matrix minus one row/col panel
 */
      szA = szB * (ip->nfnblks + ip->npnblks - 1);
      szC = ip->szC;
      extra = ip->exsz;
   }
@BEGINSKIP 
#ifdef MEM_DEBUG
/*
 * DEBUG: to debug, I allocate memory individually.... so that I can use
 * valgrind to find out of memory access error
 */
   sz = ATL_MulBySize(szA) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vA = malloc(sz);
   if (!vA)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vA);

   sz = ATL_MulBySize(szB) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vB = malloc(sz);
   if (!vB)
      return(1);  /* keep recurring, can't malloc space! */
   wB = ATL_AlignPtr(vB);

   sz = ATL_MulBySize(szC + extra) + 2*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vC = malloc(sz);
   if (!vC)
      return(1);  /* keep recurring, can't malloc space! */
   wC = ATL_AlignPtr(vC);
#else
@ENDSKIP
/*
 * use it for timing to reduce mulitple malloc.
 */
   sz = ATL_MulBySize(szC + szA+szB + extra) + 5*ATL_Cachelen;
   if (sz < ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);  /* keep recurring, can't malloc space! */
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wC = wB + (szB SHIFT);
   wC = ATL_AlignPtr(wC);
@SKIP #endif
   #ifdef TCPLX
      rC = wC + szC;
   #else
      rC = wC;
   #endif
/*
 * ============================================================================
 * First, we compute diagonals of C, and in the process we will copy A/A^T
 * for use in computing non-diaginal blocks using inner-product amm.
 * ============================================================================
 */
   flg = (TA == AtlasNoTrans) ? 2 : 0;
/*
 * NOTE: alpha may be already applied on A-copy. So, use ip->alpC instead of
 * alpha to select appropriate copy routines
 */
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(ip->alpC))
            blk2sy = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(ip->alpC) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
   }
/*
 * syrk-upper
 */
   if (Uplo == AtlasUpper)
   {
      flg |= 1;
/*
 *    1st syrk: copies both formats, no reuse
 */
      syrk_K(ip, flg, 0, A, A, blk2sy, beta, C, wB, wA, rC, wC);
      if (N > nb)
      {
         const size_t incC = nb*((ldc+1)SHIFT);
         size_t i;
/*
 *       Compute all C blks within this rowpan of C, copies B (At), reuse A
 */
         blk2c = ip->blk2c;
         Mjoin(PATL,iploopsNK)(ip, 0, 1, NULL, A, C, 11, wB, wA, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         for (i=1; i < nnblks-1; i++)
         {
/*
 *          syrk copies A and reuses B copy
 */
            syrk_K(ip, flg, i, A, NULL, blk2sy, beta, C, wB, wA,
                          rC, wC);
            wA += szB SHIFT;
/*
 *          gemm can reuse both the copies
 */
            Mjoin(PATL,iploopsNK)(ip, i, i+1, NULL, NULL, C+i*(nb SHIFT), 11,
                                  wB, wA, rC, wC, beta, blk2c);
         }
/*
 *       Last colpan is only 1 diag blk
 */
         syrk_K(ip, flg, i, A, NULL, blk2sy, beta, C, wB, wA,
                       rC, wC);
      }
   }
/*
 * Lower doesn't need to copy first row panel of A or last col panel of At
 * to GEMM storage.  If C only block, should call syrk_IP instead!
 */
   else
   {
      const size_t incC = (ldc SHIFT) * nb;
      size_t j;
      TYPE *c;
/*
 *    Compute first diag block, copies both
 */
      syrk_K(ip, flg, 0, A, A, blk2sy, beta, C, wA, wB, rC, wC);
      if (N > nb)
      {
/*
 *       Compute all C blks within this colpan of C, copying rest of A, reuse B
 */
         blk2c = ip->blk2c;
         Mjoin(PATL,iploopsMK)(ip, 1, 0, A, NULL, C, 7, wA, wB, rC, wC,
                               beta, blk2c);
/*
 *       Loop over all col-pans of C, excepting first & last;
 *       A already fully copied, B will be copied by syrk_Kloop call.
 */
         c = C + incC;
         for (j=1; j < nnblks-1; j++)
         {
/*
 *          syrk reuse A and copies B
 */
            syrk_K(ip, flg, j, NULL, A, blk2sy, beta, C, wA, wB,
                          rC, wC);
            wA += szB SHIFT;
/*
 *          gemm reuses both the copies
 */
            Mjoin(PATL,iploopsMK)(ip, j+1, j, NULL, NULL, c, 7, wA, wB, rC, wC,
                                  beta, blk2c);
            c += incC;
         }
/*
 *       Last colpan is only 1 diag blk, still reuses A
 */
         syrk_K(ip, flg, j, NULL, A, blk2sy, beta, C, wA, wB,
                       rC, wC);
      }
   }
#ifdef MEM_DEBUG
   free(vA);
   free(vB);
   free(vC);
#else
   free(vp);
#endif
   return(0);
}
@ROUT ATL_syrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_ursyrk.h))
#ifndef Conj_
   #define ATL_DECL_ 1
#endif
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h))
#ifndef Conj_
   #undef ATL_DECL_
#endif
#if 0
   #define USEREF 1
   #include "atlas_reflevel3.h"
#endif
/*
 * Service routine, particularly for parallel.  Takes its blocking from ip
 * (assuming that is what is being used below diagonal blocks
 * flag bits, meaning if set (opposite if unset):
 * 0/1: C is upper
 * 1/2: TA == AtlasNoTrans
 * 2/4: use beta=0 syrk kernel (else use beta=1)
 *
 * If (Uplo==Upper && sy2blk) 
 *    (1) flag&1 == 1; (2) wU non-NULL; (3) sy2blk is beta=0.
 * ==> wU can be aliased wt wS if you don't need correct wS on output
 */
#ifdef Conj_
   #define syrk_amm  Mjoin(PATL,herk_amm)
   #define opsyrk  Mjoin(PATL,opherk)
   #define ipsyrk  Mjoin(PATL,ipherk)
   #define SYRK Mjoin(PATL,herk)
   #define herk_FLG 1
   #define ursyrk  Mjoin(PATL,urherk)
   #define sqsyrk  Mjoin(PATL,sqherk)
#else
   #define syrk_amm  Mjoin(PATL,syrk_amm)
   #define opsyrk  Mjoin(PATL,opsyrk)
   #define ipsyrk  Mjoin(PATL,ipsyrk)
   #define SYRK Mjoin(PATL,syrk)
   #define herk_FLG 0
   #define ursyrk  Mjoin(PATL,ursyrk)
   #define sqsyrk  Mjoin(PATL,sqsyrk)
#endif

int syrk_amm
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_iptr_t  N,
   ATL_iptr_t K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_iptr_t ldc
)
{
   size_t sz, szA, szB, szC, szS, nnblks, extra;
   TYPE *wA, *wB, *wC, *wS, *wCs, *rC, *rCs, *rS;
   double timG;
   int nb, nbS, flg, idx;
   int i, k, ierr;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   ipinfo_t ip, ipmen;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   #ifdef USEREF
   {
      #ifdef Conj_
         Mjoin(PATL,refherk)(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         Mjoin(PATL,refsyrk)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }
   #endif
   if (N == 0)     /* no output */
      return(0);   /* so return with no-op */
@BEGINSKIP
/*
 * Does the operation not involve A at all?
 */
   #ifdef Conj_
      if (ralpha == ATL_rzero || !K)
      {
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         return(0);
      }
   #else
      if (SCALAR_IS_ZERO(alpha) || !K)
      {
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         return(0);
      }
   #endif
   if (N == 1) /* really a dot product */
   {
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
      #endif
      #ifdef Conj_
         TYPE d0;
         ATL_zdotc_sub(K, A, incA, A, incA, dot);
         C[1] = ATL_rzero;
         d0 = *dot * ralpha;
         if (rbeta == ATL_rzero)
            C[0] = d0;
         else 
            C[0] = C[0] * rbeta + d0;
      #elif defined(TCPLX)
         const TYPE ra=(*alpha), ia=alpha[1], rb=(*beta), ib=beta[1];
         TYPE rd, id, rt;
         ATL_zdotu_sub(K, A, incA, A, incA, dot);
         rt = rd = dot[0];
         id = dot[1];
         rd = rd*ra - id*ia;
         id = rt*ia + id*ra;
         if (ib == ATL_rzero) /* beta is a real number only */
         {
            if (rb == ATL_rzero) /* beta is 0 */
            {
               C[0] = rd;
               C[1] = id;
            }
            else
            {
               C[0] = C[0] * rb + rd;
               C[1] = C[1] * rb + id;
            }
         }
         else
         {
            const register rc=(*C), ic=C[1];
            C[0] = rc*rb - ic*ib + rd;
            C[1] = rc*ib + ic*rb + id;
         }
      #else /* real */
         TYPE dot, c;
         c = SCALAR_IS_ZERO(beta) ? ATL_rzero : *C * beta;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         if (!SCALAR_IS_ONE(alpha))
            dot *= alpha;
         *C = c + dot;
      #endif
   }
@skip   else if (K < 3) /* really a rank-1 or rank-2 update */
   else if (K == 1) /* really rank-1 update, for now just use two-pass */
   {                /* thru C for BETA!=1, optimize later with axpby */
      const ATL_iptr_t incA = (TA == AtlasNoTrans) ? 1 : lda;
      #ifdef Conj_
         if (rbeta != ATL_rone)
            Mjoin(PATL,hescal)(Uplo, N, N, rbeta, C, ldc);
         Mjoin(PATL,her)(Uplo, N, ralpha, A, incA, C, ldc);
      #else
         if (!SCALAR_IS_ONE(beta))
            Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
         Mjoin(PATL,syr)(Uplo, N, alpha, A, incA, C, ldc);
      #endif
   }
@ENDSKIP
   if (K < 3 || SCALAR_IS_ZERO(alpha))      /* degenerate case handled by*/
   {                                        /* ipsyrk */
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }

/*
 * Inner-product version calls nothing by SYRK kernels, and is called in
 * LAPACK's default left-looking Cholesky.  _IP handles L1/L2BLAS cases too.
 */
   timG = Mjoin(PATL,ipsyrkInfo)(&ip,herk_FLG, TA, N, K, lda, ldc, alpha, beta);
   #if 1
   if (timG < 0.0)
   {
      #ifdef Conj_
         ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      return(0);
   }
   #endif
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
/*
 * Outer product version will call outer-product-optimized amm, and since
 * N is too large to call ipsyrk, we expect amm perf to dominate this case.
 * Outer product SYRK is used in right-looking Cholesky.
 */
   #if 1
   if (K <= ATL_VWopgen_BEST_KB)
   {
      int ierr;
   #ifdef Conj_
      ierr = opsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
   #else
      ierr = opsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
      if (ierr)
      {
         if (ierr == 1)  /* if we failed to malloc */
            return(1);   /* tell recursion to continue */
         if (nb >= N)    /* if we can do it with ipsyrk or opsyrk */
         {               /* use ipsyrk if opsyrk fails */
            #ifdef Conj_
               ipsyrk(Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
            #else
               ipsyrk(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
            #endif
            return(0);
         }
      }
      else
         return(0);
   }
   #endif
/*
 * Will eventually need syrk timed for all square blocks to select best case.
 * For now, just pretend syrk time doesn't matter
 */
/*
 * We will decide between sqsyrk and umsyrk based on the pref data from 
 * amm_syrkPerf.h.  
 */
#if 0
   #if 1  /* apply umsyrk*/ 
      Mjoin(PATL,ipmenUMInfo)(&ipmen, TA,TB, N,N,K, lda,lda,ldc, alpha,beta); 
      #ifdef Conj_
         ierr = umsyrk(&ipmen, Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ierr = umsyrk(&ipmen, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
   #else /* sqsyrk */
      Mjoin(PATL,ipmenInfo)(&ipmen, TA,TB, N,N,K, lda,lda,ldc, alpha,beta); 
      #ifdef Conj_
         ierr = sqsyrk(&ipmen, Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ierr = sqsyrk(&ipmen, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
   #endif
#else
/*
 * applying ursyrk code
 * FIXME: need extra checking for kvec:
 *        ipmen.vlen == ATL_URSYRK_VLEN 
 *          && ATL_AMM_KMAJOR(ATL_AMM_GetFLAG(ipmen.idxK) == ATL_URSYRK_KVEC 
 */
      Mjoin(PATL,ipmenInfo)(&ipmen, TA,TB, N,N,K, lda,lda,ldc, alpha,beta);
      if (ipmen.mu == ATL_URSYRK_MU && ipmen.nu == ATL_URSYRK_NU 
            && ipmen.ku == ATL_URSYRK_KU)
      #ifdef Conj_
         ierr = ursyrk(&ipmen, Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ierr = ursyrk(&ipmen, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif
      else
      #ifdef Conj_
         ierr = sqsyrk(&ipmen, Uplo, TA, N, K, ralpha, A, lda, rbeta, C, ldc);
      #else
         ierr = sqsyrk(&ipmen, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
      #endif


#endif
   return(ierr);
}

static void syrk_rec
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_iptr_t lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #if defined(Conj_) || defined(TREAL)
      #define ONE ATL_rone
   #else
      TYPE ONE[2] = {ATL_rone, ATL_rzero};
   #endif
/*
 * If we cannot solve problem at this size, recursively cut dims until we can
 */
   if (syrk_amm(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc))
   {
      if (N > K)
      {
         ATL_iptr_t nL=N>>1, nR=N-nL;
         const TYPE *Ar = A+((TA==AtlasNoTrans)?(nL SHIFT):lda*(nL SHIFT));
         TYPE *Ct = C + (ldc+1)*(nL SHIFT);
         const enum ATLAS_TRANS TB =
         #ifdef Conj_
               (TA == AtlasNoTrans) ? AtlasConjTrans:AtlasNoTrans;
            const TYPE galp[2]={alpha,ATL_rzero}, gbet[2]={beta,ATL_rzero};
         #else
               (TA == AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
            #define galp alpha
            #define gbet beta
         #endif
         syrk_rec(Uplo, TA, nL, K, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, nR, K, alpha, Ar, lda, beta, Ct, ldc);
         if (Uplo == AtlasUpper)
            Mjoin(PATL,gemm)(TA, TB, nL, nR, K, galp, A, lda, Ar, lda, 
                             gbet, Ct-(nL SHIFT), ldc);
         else
            Mjoin(PATL,gemm)(TA, TB, nR, nL, K, galp, Ar, lda, A, lda, 
                             gbet, C+(nL SHIFT), ldc);
         #ifndef Conj_
            #undef galp
            #undef gbet
         #endif
      }
      else
      {
         ATL_iptr_t kL=K>>1, kR=K-kL, incA=((TA == AtlasNoTrans)?lda:1)SHIFT;
         syrk_rec(Uplo, TA, N, kL, alpha, A, lda, beta, C, ldc);
         syrk_rec(Uplo, TA, N, kR, alpha, A+incA*kL, lda, ONE, C, ldc);
      }
   }
}
#if defined(Conj_) || defined(TREAL)
   #undef ONE
#endif

void SYRK
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE alpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE beta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
#if 0
   #ifdef Conj_
      Mjoin(PATL,herk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #else
      Mjoin(PATL,syrk_APR)(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   #endif
   return;
#endif
   syrk_rec(Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);

}
@ROUT ATL_opsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2016
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_ursyrk.h))
#ifdef Conj_
   #define sqsyrkBlk Mjoin(PATL,sqherkBlk_OP)
   #define ursyrkBlk Mjoin(PATL,urherkBlk_OP)
   #define opsqsyrk Mjoin(PATL,opsqherk)
   #define opursyrk Mjoin(PATL,opurherk)
   #define opsyrk Mjoin(PATL,opherk)
#else
   #define sqsyrkBlk Mjoin(PATL,sqsyrkBlk_OP)
   #define ursyrkBlk Mjoin(PATL,ursyrkBlk_OP)
   #define opsqsyrk Mjoin(PATL,opsqsyrk)
   #define opursyrk Mjoin(PATL,opursyrk)
   #define opsyrk Mjoin(PATL,opsyrk)
#endif
/*
 * Indexes both A and C from base ptrs according to d (diagonal blk)
 */
void sqsyrkBlk
(
   opinfo_t *op,
   int flag,      /* bitvec: 0: set means C is upper, 1: set TA==AtlasNoTrans */
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy */
   cm2am_t sy2blk,/* copy A to syrk storage */
   ablk2cmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *rS,      /* real ptr (unused for real types) */
   TYPE *wS,      /* space to store syrk A; */
   TYPE *wA,      /* if non-NULL, op-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL op-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real ptr (unused for real routs) */
   TYPE *wC,      /* if non-NULL: ptr to syrk-storage C wrkspc */
   TYPE *wU       /* NBxNB wrkspc needed for Upper C storage & blk2c != NULL */
)
{
   ATL_CSZT lda = op->lda, nfblks = op->nfnblks;
   ATL_CUINT KB = op->KB, kb = op->kb;
   ATL_UINT nb, kbS, nnu;
   #ifdef TCPLX
      ATL_UINT szC, szA;
      TYPE *rA, *rB;
   #endif
   const SCALAR beta=op->beta;
   if (d == nfblks + op->npnblks - 1)  /* last block is SYRK only */
   {
      nb = op->nF;
      nb = (nb) ? nb : op->nb;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + op->szA;
            rB = wB + op->szB;
         }
         else
         {
            rA = wA + op->pszA;
            rB = wB + op->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = op->nb;
      #ifdef TCPLX
         rA = wA + op->szA;
         rB = wB + op->szB;
      #endif
   }
   else
   {
      nb = op->pnb;
      #ifdef TCPLX
         rA = wA + op->pszA;
         rB = wB + op->pszB;
      #endif
   }
   nnu = (nb+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
   kbS = ((kb+ATL_SQSYRKK_KU-1)/ATL_SQSYRKK_KU)*ATL_SQSYRKK_KU;
   if (A)  /* want to copy input array */
   {
/*
 *    Move A ptr to d'th block
 */
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         A += n*op->incAm;
         n = d - n;  /* # of partial blocks remaining in d */
         A += n*op->pincAm;
      }
      if (wA)  /* want to copy A to gemm storage too! */
      {
         #ifdef TCPLX
            op->a2blk(kb, nb, op->alpA, A, lda, rA, wA);
         #else
            op->a2blk(kb, nb, op->alpA, A, lda, wA);
         #endif
         if (op->a2blk == sy2blk)
         {
            wS = wA;
            #ifdef TCPLX
               rS = rA;
            #endif
         }
      }
      if (wB)  /* want to copy At to gemm storage too! */
      {
         #ifdef TCPLX
            op->b2blk(kb, nb, op->alpB, A, lda, rB, wB);
         #else
            op->b2blk(kb, nb, op->alpB, A, lda, wB);
         #endif
         if (op->b2blk == sy2blk)
         {
            wS = wB;
            #ifdef TCPLX
               rS = rB;
            #endif
         }
      }
      if (wS != wA && wS != wB)
      {
         #ifdef TCPLX
            sy2blk(kb, nb, op->ONE, A, lda, rS, wS);
         #else
            sy2blk(kb, nb, ATL_rone, A, lda, wS);
         #endif
      }
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
      #ifdef TCPLX
         #ifdef Conj_
            TYPE *crA=(flag&2)?rS:wS, *ciA=(flag&2)?wS:rS;
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, crA, ciA, wC);
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, crA, ciA, wC, rS, rS, rC);
            Mjoin(PATL,sqsyrkK_b1)(nnu, nnu, kbS, rS, rS, rC, ciA, crA, wC);
            Mjoin(PATL,sqsyrkK_bn)(nnu, nnu, kbS, ciA, crA, wC, wS, wS, rC);
         #else
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, rC, rS, wS, wC);
            Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, rS, wS, wC, rS, rS, rC);
            Mjoin(PATL,sqsyrkK_bn)(nnu, nnu, kbS, rS, rS, rC, wS, rS, wC);
            Mjoin(PATL,sqsyrkK_b1)(nnu, nnu, kbS, wS, rS, wC, wS, wS, rC);
         #endif
      #else
         Mjoin(PATL,sqsyrkK_b0)(nnu, nnu, kbS, wS, wS, wC, wS, wS, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=op->ldc;
      int k;
      #ifdef TCPLX
         const TYPE *alp = (op->alpA == op->ONE) ? op->alpB : op->alpA;
      #else
         TYPE alp = (op->alpA == ATL_rone) ? op->alpB : op->alpA;
      #endif
      C += d*op->nb*((ldc+1)SHIFT);
      if (flag&1)  /* Upper matrix */
      {
         @BEGINSKIP
         #ifdef TCPLX
            const TYPE zero[2] = {ATL_rzero, ATL_rzero};
            blk2c(nb, nb, alp, rC, wC, zero, wU, nb);
            #ifdef Conj_  /* must zero imag part of diagonal for HERK */
            {
               ATL_CINT ldc2=ldc+ldc;
               for (k=0; k < nb; k++, C += ldc2, wU += 2)
               {
                  Mjoin(PATL,axpbyConj)(k+1, op->ONE, wU, nb, beta, C, 1);
                  C[((k+1)<<1)-1] = ATL_rzero;
               }
            }
            #endif
         #else
            blk2c(nb, nb, alp, wC, ATL_rzero, wU, nb);
         #endif
/*
 *       Copy matrix back to original C while applying beta
 */
         #ifndef Conj_
         if (SCALAR_IS_ZERO(beta))
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
               Mjoin(PATL,copy)(k+1, wU, nb, C, 1);
         else
            for (k=0; k < nb; k++, wU += (1 SHIFT), C += (ldc SHIFT))
            #ifdef TCPLX
               Mjoin(PATL,axpby)(k+1, op->ONE, wU, nb, beta, C, 1);
            #else
               Mjoin(PATL,axpby)(k+1, ATL_rone, wU, nb, beta, C, 1);
            #endif
         #endif
         @ENDSKIP
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
      else
      {
         #ifdef TCPLX
            blk2c(nb, nb, alp, rC, wC, beta, C, ldc);
            #ifdef Conj_  /* must zero complex part of diagonal! */
               Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
            #endif
         #else
            blk2c(nb, nb, alp, wC, beta, C, ldc);
         #endif
      }
   }
}
int opsqsyrk
(
   opinfo_t *op,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szC, szU, szS, nnblks, szAblk;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wU, *rC, *rCs, *rS;
   int nb, nbS, flg, idx, extra;
   cm2am_t sy2blk;
   ablk2cmat_t blk2sy, blk2c;

   nnblks = op->nfnblks + op->npnblks;
   sy2blk = IS_COLMAJ(TA) ? Mjoin(PATL,a2blk_sqsyrkT) : Mjoin(PATL,a2blk_sqsyrkN);

   if (Uplo == AtlasLower)
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb1);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1b1):Mjoin(PATL,sqSyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbN);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1bN):Mjoin(PATL,sqSyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1b0):Mjoin(PATL,sqSyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbX);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,sqSyrkIntoC_a1bX):Mjoin(PATL,sqSyrkIntoC_aXbX);
      }
   }
   else  /* C is Upper */
   {
      szU = 0;
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb1_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1b1_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbN_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1bN_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1b0_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2sy = Mjoin(PATL,sqSyrkIntoC_aNbX_L2UT);
         else
            blk2sy = SCALAR_IS_ONE(alpha) ?
                        Mjoin(PATL,sqSyrkIntoC_a1bX_L2UT)
                        :Mjoin(PATL,sqSyrkIntoC_aXbX_L2UT);
      }
@BEGINSKIP
      szU = N*N;
      if (SCALAR_IS_NONE(alpha))
         blk2sy = Mjoin(PATL,sqSyrkIntoC_aNb0);
      else
         blk2sy = SCALAR_IS_ONE(alpha) ?
                  Mjoin(PATL,sqSyrkIntoC_a1b0):Mjoin(PATL,sqSyrkIntoC_aXb0);
@ENDSKIP
   }
   extra = (ATL_SQSYRKK_NU+ATL_SQSYRKK_NU)*ATL_SQSYRKK_NU;
   flg = (TA == AtlasNoTrans) ? 2 : 0;
   if (TA == AtlasUpper)
   {
      flg |= 1;
      extra -= Mmin(extra, szU);
   }
   if (nnblks == 1)  /* we've got a 1 block of SYRK only! */
   {
      nbS = (N+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
      szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
      nbS *= ATL_SQSYRKK_NU;
      szC *= ((ATL_SQSYRKK_NU*ATL_SQSYRKK_NU+ATL_SQSYRKK_VLEN-1)/ATL_SQSYRKK_VLEN)
             * ATL_SQSYRKK_VLEN;
      #if ATL_SQSYRKK_KVEC > 1
         szS = ((K+ATL_SQSYRKK_KVEC-1)/ATL_SQSYRKK_KVEC)*ATL_SQSYRKK_KVEC;
         szS *= nbS;
      #else
         szS = nbS * K;
      #endif
      szU = Mmax(op->szC, szU);  /* Majedul: don't need anymore */
      sz = ATL_MulBySize(szU + szC + szS + extra) + 3*ATL_Cachelen;
      vp = malloc(sz);
      if (!vp)
         return(1);
      wS = ATL_AlignPtr(vp);
      wC = wS + (szS SHIFT);
      wC = ATL_AlignPtr(wC);
      wU = wC + (szC SHIFT);
      wU = ATL_AlignPtr(wU);
      #ifdef TCPLX
         rC = wC + szC;
         rS = wS + szS;
      #else
         rC = wC;
         rS = wS;
      #endif
      flg |= (Uplo == AtlasUpper) ? 1 : 0;
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS,
              NULL, NULL, NULL, NULL, rC, wC, wU);
      free(vp);
      return(0);
   }
/*
 * If we reach here, we have at rank-K SYRK update requiring both SYRK & GEMM
 * Since nnblks > 1, nfnblks > 1 as well.
 */
   nbS = (op->nb+ATL_SQSYRKK_NU-1)/ATL_SQSYRKK_NU;
   szC = ((nbS+1)*nbS)>>1;  /* only need lower tri blks, not full nnu*nnu */
   nbS *= ATL_SQSYRKK_NU;
   szC *= ((ATL_SQSYRKK_NU*ATL_SQSYRKK_NU+ATL_SQSYRKK_VLEN-1)/ATL_SQSYRKK_VLEN)
          * ATL_SQSYRKK_VLEN;
   #if ATL_SQSYRKK_KVEC > 1
      szS = ((K+ATL_SQSYRKK_KVEC-1)/ATL_SQSYRKK_KVEC)*ATL_SQSYRKK_KVEC;
      szS *= nbS;
   #else
      szS = nbS * K;
   #endif
   szU = Mmax(op->szC, szU);  /* Majedul: no need anymore */
   szAblk = op->szA;
   szA = szAblk * (nnblks-1);
   /*
    * FIXED: wC is used both for syrk and gemm. 
    * We need to allocate Mmax(szC, op->szC) for wC
    */
   sz = Mmax(szC, op->szC);
   sz = ATL_MulBySize(szA+szAblk + szS + sz + szU + extra) + 5*ATL_Cachelen;
   vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wS = wB + (szAblk SHIFT);
   wS = ATL_AlignPtr(wS);
   wC = wS + (szS SHIFT);
   wC = ATL_AlignPtr(wC);
   wU = wC + (szC SHIFT);
   wU = ATL_AlignPtr(wU);
   #ifdef TCPLX
      rC = wC + op->szC;
      rCs = wC + szC;
      rS = wS + szS;
   #else
      rC = wC;
      rCs = wC;
      rS = wS + szS;
   #endif
   if (Uplo == AtlasLower)
   {
      size_t j;
/*
 *    Do first diagonal block, don't copy A blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB,
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, cop->ing entire A at same time
 */
      Mjoin(PATL,oploopsM)(op, 1, 0, A, NULL, C, 1, wA, wB, rC, wC);
/*
 *    For remaining column panels of C, sqsyrkBlk copies B, reusues wA
 */
      for (j=1; j < nnblks-1; j++)
      {
         sqsyrkBlk(op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, wB, wB,
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsM)(op, j+1, j, NULL, NULL, C, 1, wA, wB, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      sqsyrkBlk(op, flg, j, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   else
   {
      size_t i;
/*
 *    Do first diagonal block, don't copy A^T blk to GEMM storage since it is
 *    used only for this diagonal (SYRK)
 */
      flg |= 1;
      sqsyrkBlk(op, flg, 0, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL,
              rCs, wC, wU);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A^T at same time
 */
      Mjoin(PATL,oploopsN)(op, 0, 1, NULL, A, C, 2, wB, wA, rC, wC);
/*
 *    For remaining column panels of C, sqsyrkBlk copies A, reuses A^T
 */
      for (i=1; i < nnblks-1; i++)
      {
         sqsyrkBlk(op, flg, i, A, sy2blk, blk2sy, C, rS, wS, wB, wB, NULL, NULL,
                 rCs, wC, wU);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsN)(op, i, i+1, NULL, NULL, C, 2, wB, wA, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      sqsyrkBlk(op, flg, i, A, sy2blk, blk2sy, C, rS, wS, NULL, NULL, NULL, NULL,
              rCs, wC, wU);
   }
   free(vp);
   return(0);
}
void ursyrkBlk
(
   opinfo_t *op,
   size_t d,      /* which global diagonal blk of C is being computed */
   const TYPE *A, /* if non-NULL, base A ptr to copy in wA */
   const TYPE *B, /* if non-NULL, base A ptr to copy in wB */
   ablk2tcmat_t blk2c, /* if non-NULL sy storage to C storage copy func */
   TYPE *C,       /* if blk2c non-NULL, which C to write to, else ignored */
   TYPE *wA,      /* if non-NULL, op-based A workspace */
   TYPE *wAn,     /* next A wrkspc to be prefetched */
   TYPE *wB,      /* if non-NULL op-based At workspace */
   TYPE *wBn,     /* next B wrkspc to be prefetched */
   TYPE *rC,      /* real ptr (unused for real routs) */
   TYPE *wC      /* if non-NULL: ptr to syrk-storage C wrkspc */
)
{
   ATL_CSZT lda = op->lda, nfblks = op->nfnblks;
   ATL_CSZT ldb = op->ldb;
   ATL_CUINT KB = op->KB, kb = op->kb;
   ATL_UINT nb, kbS, nnu, nmu;
#ifdef TCPLX
   ATL_UINT szC, szA;
   TYPE *rA, *rB;
   TYPE *iA=wA, *iB=wB; /* may not need ... wA, wB can be used !!!*/
#endif
   const SCALAR beta=op->beta;
   TYPE *wS;
   /*assert(op->mb==op->nb);*/
   if (d == nfblks + op->npnblks - 1) /* last syrk only block*/
   {
      nb = op->nF;
      nb = (nb) ? nb : op->nb;
      #ifdef TCPLX
         if (d < nfblks)
         {
            rA = wA + op->szA;
            rB = wB + op->szB;
         }
         else
         {
            rA = wA + op->pszA;
            rB = wB + op->pszB;
         }
      #endif
   }
   else if (d < nfblks)
   {
      nb = op->nb;
      #ifdef TCPLX
         rA = wA + op->szA;
         rB = wB + op->szB;
      #endif
   }
   else
   {
      nb = op->pnb;
      #ifdef TCPLX
         rA = wA + op->pszA;
         rB = wB + op->pszB;
      #endif
   }
/*
 * calc nmu and nnu. one must be multiple of other
 */
   if (op->mu > op->nu)
   {
      nmu = (nb+op->mu-1)/op->mu;
      nnu = nmu * (op->mu/op->nu); /* NU must be multiple of MU */
   }
   else
   {
      nnu = (nb+op->nu-1)/op->nu;
      nmu = nnu * (op->nu/op->mu); /* NU must be multiple of MU */
   }
/*
 * we can use KB since we are using same kernel as gemm
 */
   kbS = op->KB;

   if (A)  /* want to copy input array in wA */
   {
/*
 *    Move A ptr to d'th block
 */
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         A += n*op->incAm;
         n = d - n;  /* # of partial blocks remaining in d */
         A += n*op->pincAm;
      }
      #ifdef TCPLX
         op->a2blk(kb, nb, op->alpA, A, lda, rA, wA);
      #else
         op->a2blk(kb, nb, op->alpA, A, lda, wA);
      #endif
   }
   if (B) /* want to copy input array in wB */
   {
      if (d)
      {
         size_t n = Mmin(d, nfblks);
         B += n*op->incBn;
         n = d - n;  /* # of partial blocks remaining in d */
         B += n*op->pincBn;
      }

      #ifdef TCPLX
         op->b2blk(kb, nb, op->alpB, B, ldb, rB, wB);
      #else
         op->b2blk(kb, nb, op->alpB, B, ldb, wB);
      #endif
   }
   if (wC)  /* want to compute SYRK on this block into wC */
   {
/*
 *    NOTE: no need to specially handle herk/conj, since we are using gemm's
 *    copy routines and similar kernels
 */
      #ifdef TCPLX
         Mjoin(PATL,ursyrkK_b0)(nmu, nnu, kbS, wA, wB, rC, rA, wB, wC);
         Mjoin(PATL,ursyrkK_b0)(nmu, nnu, kbS, rA, wB, wC, rA, rB, rC);
         Mjoin(PATL,ursyrkK_bn)(nmu, nnu, kbS, rA, rB, rC, wA, rB, wC);
         Mjoin(PATL,ursyrkK_b1)(nmu, nnu, kbS, wA, rB, wC, wA, wB, wC);
      #else
         Mjoin(PATL,ursyrkK_b0)(nmu, nnu, kbS, wA, wB, wC, wA, wB, wC);
      #endif
   }
   if (blk2c)
   {
      const size_t ldc=op->ldc;
      int k;
      #ifdef TCPLX
         const TYPE *alp = (op->alpA == op->ONE) ? op->alpB : op->alpA;
      #else
         TYPE alp = (op->alpA == ATL_rone) ? op->alpB : op->alpA;
      #endif
      ATL_UINT shVL;
      
      for (shVL=0; !(op->vlen&(1<<shVL)); shVL++) ;
      C += d*op->nb*((ldc+1)SHIFT);
      #ifdef TCPLX
         blk2c(nb, op->mu, op->nu, shVL, alp, rC, wC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(nb, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(nb, op->mu, op->nu, shVL, alp, wC, beta, C, ldc);
      #endif
   }
}

int opursyrk
(
   opinfo_t *op,
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   size_t sz, szA, szC, szU, szS, nnblks, szAblk;
   void *vp;
   TYPE *wA, *wB, *wC, *wS, *wU, *rC, *rCs, *rS;
   int nb, nbS, flg, idx, extra;
   cm2am_t sy2blk;
   ablk2cmat_t blk2c;
   ablk2tcmat_t blk2sy;
   int smnu;

   nnblks = op->nfnblks + op->npnblks;
   smnu = Mmax(op->mu, op->nu);           /* max unrolling */
/*
 * select c-copy 
 */
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1b1);
      else if (SCALAR_IS_NONE(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1bN);
      else if (SCALAR_IS_ZERO(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1b0);
      else
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1bX);
   }
   else  /* C is Upper */
   {
      if (SCALAR_IS_ONE(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1b1_L2UT);
      else if (SCALAR_IS_NONE(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1bN_L2UT);
      else if (SCALAR_IS_ZERO(beta))
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1b0_L2UT);
      else
         blk2sy = Mjoin(PATL,urSyrkIntoC_a1bX_L2UT);
   }
   flg = (TA == AtlasNoTrans) ? 2 : 0;
   if (TA == AtlasUpper)
      flg |= 1;
   if (nnblks == 1)  /* we've got a 1 block of SYRK only! */
   {
      extra = (smnu+smnu)*smnu;
      nbS = (N+smnu-1)/smnu;
      szC = ((nbS+1)*nbS)>>1;
      nbS *= smnu;
      szC *= ((smnu*smnu+op->ku-1)/op->ku)*op->ku;
      szS = nbS * op->KB;         /* KB is already rounded with ku */
      szA = szAblk = szS;
      sz = ATL_MulBySize(szA+szAblk+szC+extra) + 3*ATL_Cachelen;
      vp = malloc(sz);
      if (!vp)
         return(1);
      wA = ATL_AlignPtr(vp);
      wB = wA + (szA SHIFT);
      wB = ATL_AlignPtr(wB);
      wC = wB + (szAblk SHIFT);
      wC = ATL_AlignPtr(wC);
      #ifdef TCPLX
         rC = wC + szC;
      #else
         rC = wC;
      #endif
      flg |= (Uplo == AtlasUpper) ? 1 : 0;
      ursyrkBlk(op, 0, A, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
      free(vp);
      return(0);
   }
/*
 * If we reach here, we have at rank-K SYRK update requiring both SYRK & GEMM
 * Since nnblks > 1, nfnblks > 1 as well.
 */
/*
 * syrk needs less space than gemm, so we can reuse same wC space
 */
   szC = op->szC;
   szAblk = op->szA;
   szA = szAblk * (nnblks-1);
   extra = op->exsz;           /* why needed?? */
   sz = ATL_MulBySize(szA + szAblk + szC + extra) + 3*ATL_Cachelen;

   vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wC = wB + (szAblk SHIFT);
   wC = ATL_AlignPtr(wC);
   #ifdef TCPLX
      rC = wC + op->szC;
   #else
      rC = wC;
   #endif
   if (Uplo == AtlasLower)
   {
      size_t j;
/*
 *    SYRK uses same copy routines as GEMM. copy of B can be reused in GEMM
 *    of the column panels
 */
      ursyrkBlk(op, 0, A, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A at same time
 */
      Mjoin(PATL,oploopsM)(op, 1, 0, A, NULL, C, 1, wA, wB, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies B, re-uses wA
 */
      for (j=1; j < nnblks-1; j++)
      {
/*
 *       ****** big idea:
 *       1. Resue A from previous wA calculated in oploopsM last time.
 *          After the first call of oploopsM the whole wA is populated
 *       2. compute wB which can be reused in subsequent oploopsM
 */
         ursyrkBlk(op, j, NULL, A, blk2sy, C, wA,wA, wB,wB, rC, wC);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsM)(op, j+1, j, NULL, NULL, C, 1, wA, wB, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      ursyrkBlk(op, j, NULL, A, blk2sy, C, wA, wA, wB, wB, rC, wC);
   }
   else
   {
      size_t i;
/*
 *    GEMM will reuse A*T, Syrk can reuse B later... wB is wA
 */
      ursyrkBlk(op, 0, A, A, blk2sy, C, wB, wB, wA, wA, rC, wC);
/*
 *    Do rank-K update on ge blks beneath diag, copying entire A^T at same time
 */
      Mjoin(PATL,oploopsN)(op, 0, 1, NULL, A, C, 2, wB, wA, rC, wC);
/*
 *    For remaining column panels of C, syrkBlk copies A, reuses A^T
 */
      for (i=1; i < nnblks-1; i++)
      {
         ursyrkBlk(op, i, A, NULL, blk2sy, C, wB,wB, wA,wA, rC, wC);
         wA += (szAblk SHIFT);
         Mjoin(PATL,oploopsN)(op, i, i+1, NULL, NULL, C, 2, wB, wA, rC, wC);
      }
/*
 *    Last col panel is only one diagonal
 */
      ursyrkBlk(op, i, A, NULL, blk2sy, C, wB, wB, wA, wA, rC, wC);
   }
   free(vp);
   return(0);
}

int opsyrk
(
   const enum ATLAS_UPLO  Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT  N,
   ATL_CSZT K,
   #ifdef Conj_
   const TYPE ralpha,
   #else
   const SCALAR alpha,
   #endif
   const TYPE *A,
   ATL_CSZT lda,
   #ifdef Conj_
   const TYPE rbeta,
   #else
   const SCALAR beta,
   #endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   int i, ismul;
   int ierr;
   #ifdef Conj_
      TYPE alpha[2]={ralpha, ATL_rzero}, beta[2]={rbeta, ATL_rzero};
      const enum ATLAS_TRANS TB=(TA==AtlasNoTrans)?AtlasConjTrans:AtlasNoTrans;
   #else
      const enum ATLAS_TRANS TB = (TA==AtlasNoTrans) ? AtlasTrans:AtlasNoTrans;
   #endif
   opinfo_t op;
/*
 * find opsyrkinfo
 */
   #ifdef Conj_
      if (Mjoin(PATL,opsyrkInfo)(&op, 1, TA, N, K, lda, ldc, alpha, beta))
   #else
      if (Mjoin(PATL,opsyrkInfo)(&op, 0, TA, N, K, lda, ldc, alpha, beta))
   #endif
         return(2);
   #if 0
   fprintf(stderr, "D=(%u,%u), B=(%u,%u,%u), pB=(%u,%u,%u)\n",
           (unsigned int)N, (unsigned int)K, op.mb, op.nb, op.KB,
           op.pmb, op.pnb, op.kb);
   #endif
/*
 * mu,nu,ku, must match with amm_umsyrk.h to apply ursyrk until we manage 
 * to have opgenview for UR
 */
   ismul = 1;
   if (op.mu != ATL_URSYRKK_MU || op.nu != ATL_URSYRKK_NU 
         || op.ku !=ATL_URSYRKK_KU )
      ismul = 0;
/*
 * try to use ursyrk first if possible 
 */
   if (ismul)
      ierr = opursyrk(&op, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   else
      ierr = opsqsyrk(&op, Uplo, TA, N, K, alpha, A, lda, beta, C, ldc);
   return(ierr);
}
@ROUT ATL_ipsyrk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2015 
#define ATL_GLOBIDX 1
#include "atlas_misc.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
@skip #include Mstr(Mjoin(ATLAS_PRE,amm_sum.h))
#include Mstr(Mjoin(ATLAS_PRE,syrk_view.h)) /* blocking & perf info */
@SKIP #include Mstr(Mjoin(ATLAS_PRE,amm_syrk.h))  /* syrk kernel info */
#include Mstr(Mjoin(ATLAS_PRE,amm_sqsyrk.h))
#include Mstr(Mjoin(ATLAS_PRE,amm_ursyrk.h))

static INLINE void ATL_syr1
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * First, see if we can simply call the Level-2 BLAS
 */
   #ifdef Conj_
      TYPE *c=C+1;
   #endif
   #ifndef TCPLX
      if (beta == 1.0)
      {
         Mjoin(PATL,syr)(Uplo, N, alpha, A, TA==AtlasNoTrans?1:lda, C, ldc);
         return;
      }
   #endif
   {
      size_t k;
      TYPE *X=(TYPE*)A;
      void *vp=NULL;
      #ifdef Conj_
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
/*
 *    Copy A if it's a row so it is contiguous for all N axpby calls
 */
      #ifdef Conj_
      if (TA == AtlasConjTrans)
      #else
      if (TA == AtlasTrans || TA == AtlasConjTrans)
      #endif
      {
         vp = malloc(ATL_MulBySize(N)+ATL_Cachelen);
         ATL_assert(vp);
         X = ATL_AlignPtr(vp);
         #ifdef Conj_
            Mjoin(PATL,copyConj)(N, A, lda, X, 1);
         #else
            Mjoin(PATL,copy)(N, A, lda, X, 1);
         #endif
      }
      #ifdef Conj_
         if (rbeta == 1.0)
         {
            Mjoin(PATL,her)(Uplo, N, ralpha, X, 1, C, ldc);
            if (vp)
               free(vp);
            return;
         }
      #endif  /* NO syr for complex, so cplx SYR has to use axpy-based code */
      #ifdef TCPLX
         if (Uplo == AtlasUpper)
         {
            size_t ldc2 = ldc+ldc;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldc2)
            {
               size_t k2=k+k;
               #ifndef Conj_
                  const register TYPE rx=X[k2], ix=X[k2+1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha*X[k2];
                  scal[1] = -ralpha*X[k2+1];
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(k+1, scal, X, 1, beta, C, 1);
            }
         }
         else   /* Uplo == AtlasLower */
         {
            size_t ldcp1 = (ldc+1)SHIFT;
            #ifndef Conj_
               const register TYPE ra=(*alpha), ia=alpha[1];
            #endif
            for (k=0; k < N; k++, C += ldcp1, X += 2)
            {
               #ifndef Conj_
                  const register TYPE rx=*X, ix=X[1];
               #endif
               TYPE scal[2];
               #ifdef Conj_
                  scal[0] = ralpha* *X;
                  scal[1] = ralpha * (-X[1]);
               #else
                  scal[0] = ra*rx - ia*ix;
                  scal[1] = ra*ix + ia*rx;
               #endif
               Mjoin(PATL,axpby)(N-k, scal, X, 1, beta, C, 1);
            }
         }
      #else  /* real with beta != 1.0 */
         if (Uplo == AtlasUpper)
         {
            for (k=0; k < N; k++, C += ldc)
               Mjoin(PATL,axpby)(k+1, X[k]*alpha,  X, 1, beta, C, 1);
         }
         else   /* Uplo == AtlasLower */
         {
            for (k=0; k < N; k++, C += (ldc+1), X++)
               Mjoin(PATL,axpby)(N-k, (*X)*alpha,  X, 1, beta, C, 1);
         }
      #endif
      if (vp)
         free(vp);
      @beginskip
         {
            size_t n=N;
            TYPE zero[2] = {ATL_rzero, ATL_rzero;
            else
               vp = NULL;
            if (Uplo == Upper)
            {
               if (SCALAR_IS_ONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                     Mjoin(PATL,axpby)(M, X+k+k,  X, 1, beta, C, 1);
               }
               else if (SCALAR_IS_NONE(alpha))
               {
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     const TYPE scal[2] = {-X[k+k], -X[k+k+1]};
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
               else  /* alpha should be multiplied */
               {
                  const register TYPE ralp=*alpha, ialp=alpha[1];
                  for (k=0; k < N; k++, B += incB, C += ldc2)
                  {
                     TYPE scal[2];
                     const register TYPE rx=X[k+k], ix=X[k+k+1];
                     scal[0] = rx*ralp - ix*ialp;
                     scal[1] = rx*ialp + ix*ralp;
                     Mjoin(PATL,axpby)(M, scal,  X, 1, beta, C, 1);
                  }
               }
            }
            else  /* Uplo == Lower */
            {
            }
         }
         @endskip
   }
   #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
      Mjoin(PATLU,zero)(N, c, (ldc+1)SHIFT);
   #endif
}

#include "atlas_cache.h"
#include "atlas_reflevel3.h"
/*
 * This routine assumes 1st col of A is x, 2nd y, and NoTrans case
 */
static void ATL_syr2_axpy
(
   const enum ATLAS_UPLO Uplo,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *x,
   const TYPE *y,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef Conj_
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
   if (Uplo == AtlasLower)
   {
      ATL_CSZT ldcp1 = (ldc+1)SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldcp1)
      {
         ATL_CSZT n = N-j;
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(n, alpx, x+(j SHIFT), 1, beta, C, 1);
         Mjoin(PATL,axpy)(n, alpy, y+(j SHIFT), 1, C, 1);
         #ifdef Conj_
            C[1] = ATL_rzero;
         #endif
      }
   }
   else /* Uplo == AtlasUpper */
   {
      ATL_CSZT ldc2 = ldc SHIFT;
      ATL_SZT j;
      for (j=0; j < N; j++, C += ldc2)
      {
         #ifdef Conj_
            const TYPE alpx[2] = {ralpha*x[j+j], -ralpha*x[j+j+1]};
            const TYPE alpy[2] = {ralpha*y[j+j], -ralpha*y[j+j+1]};
         #elif defined(TCPLX)
            const TYPE ralp=alpha[0], ialp=alpha[1];
            TYPE alpx[2], alpy[2], rx=x[j+j], ix=x[j+j+1];
            if (ialp == ATL_rzero)
            {
               alpx[0] = ralp*rx;
               alpx[1] = ralp*ix;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx;
               alpy[1] = ralp*ix;
            }
            else
            {
               alpx[0] = ralp*rx - ialp*ix;
               alpx[1] = ralp*ix + ialp*rx;
               rx=y[j+j], ix=y[j+j+1];
               alpy[0] = ralp*rx - ialp*ix;
               alpy[1] = ralp*ix + ialp*rx;
            }
         #else
            const TYPE alpx = alpha * x[j], alpy = alpha * y[j];
         #endif
         Mjoin(PATL,axpby)(j+1, alpx, x, 1, beta, C, 1);
         Mjoin(PATL,axpy)(j+1, alpy, y, 1, C, 1);
         #ifdef Conj_
            C[j+j+1] = ATL_rzero;
         #endif
      }
   }
}

#ifdef Conj_
   #define ATL_ger2 Mjoin(PATL,ger2c)
#elif defined(TCPLX)
   #define ATL_ger2 Mjoin(PATL,ger2u)
#else
   #define ATL_ger2 Mjoin(PATL,ger2)
#endif
static void ATL_syr2
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
{
   void *vp=NULL;
   TYPE *x, *y;
   #ifdef TCPLX
      ATL_CSZT lda2 = lda+lda, ldc2 = ldc+ldc;
   #else
      #define lda2 lda
      #define ldc2 ldc
   #endif
   #ifdef Conj_
      const TYPE alpha[2]={ralpha, ATL_rzero};
      const TYPE beta[2] ={rbeta,  ATL_rzero};
   #endif
/*
 * If A cols are strided, copy them to contiguous & aligned storage
 */
   if (TA != AtlasNoTrans)
   {
      vp = malloc(ATL_MulBySize(N+N) + ATL_Cachelen+ATL_Cachelen);
      ATL_assert(vp);
      x = ATL_AlignPtr(vp);
      y = x + (N SHIFT);
      y = ATL_AlignPtr(y);
      #ifdef Conj_
         Mjoin(PATL,copyConj)(N, A, lda, x, 1);
         Mjoin(PATL,copyConj)(N, A+(1 SHIFT), lda, y, 1);
      #else
         Mjoin(PATL,copy)(N, A, lda, x, 1);
         Mjoin(PATL,copy)(N, A+(1 SHIFT), lda, y, 1);
      #endif
   }
   else
   {
      x = (TYPE *) A;
      y = (TYPE *) (A + lda2);
   }
/*
 * If BETA != 1, then we must pass through C twice, so use daxpy-based code
 */
   #ifdef Conj_
   if (rbeta != ATL_rone)
   #else
   if (!SCALAR_IS_ONE(beta))
   #endif
   {
      #ifdef Conj_
         ATL_syr2_axpy(Uplo, N, ralpha, x, y, rbeta, C, ldc);
      #else
         ATL_syr2_axpy(Uplo, N, alpha, x, y, beta, C, ldc);
      #endif
   }
   else /* beta=1 can use ger2 based code, make only 1 pass thru C */
   {
      #ifdef Conj_
         const TYPE alpha[2] = {ralpha, ATL_rzero};
      #endif
      #if L1C_ELTS >= 16384
         unsigned int Np = (N > 128) ? 120 : N;
      #elif L1C_ELTS >= 8192
         unsigned int Np = (N > 90) ? 80 : N;
      #elif L1C_ELTS >= 4096
         unsigned int Np = (N > 64) ? 60 : N;
      #elif L1C_ELTS >= 2048
         unsigned int Np = (N > 48) ? 40 : N;
      #else
         unsigned int Np = (N > 40) ? 24 : N;
      #endif
      if (Uplo == AtlasLower)
      {
         ATL_CSZT incC=((ldc+1)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C, ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C, ldc);
            #endif
            ATL_ger2(N-j-nb, nb, alpha, x+nb2, 1, x, 1, alpha, y+nb2, 1, y, 1, 
                     C+nb2, ldc);
         }
      }
      else
      {
         const TYPE *x0 = x, *y0 = y;
         ATL_CSZT incC=((ldc)SHIFT)*Np, incX=(Np SHIFT);
         ATL_SZT j;
         for (j=0; j < N; j += Np, C += incC, x += incX, y += incX)
         {
            const unsigned nb = Mmin(N-j, Np), nb2=nb SHIFT;
            if (j)
               ATL_ger2(j, nb, alpha, x0, 1, x, 1, alpha, y0, 1, y, 1,
                        C, ldc);
            #ifdef Conj_
               ATL_syr2_axpy(Uplo, nb, ralpha, x, y, rbeta, C+(j SHIFT), ldc);
            #else
               ATL_syr2_axpy(Uplo, nb, alpha, x, y, beta, C+(j SHIFT), ldc);
            #endif
         }
      }
   }
   if (vp)
      free(vp);
}

@ROUT ATL_ipsyrk N2Idx
static INLINE int N2Idx(const unsigned int N)
/*
 * Uses Recursive halving to find smallest NB >= N in VWsyrk.
 */
{
   unsigned int idxB=ATL_VWsyrk_NCASES-1, idxS=0, idxM;
   unsigned int nbB, nbS=ATL_VWsyrk_MIN_NB, nbM;
   if (N <= ATL_VWsyrk_MIN_NB)
      return(0);
   nbB = ATL_GetVWsyrkMB(idxB);
   if (N >= nbB)
      return(ATL_VWsyrk_NCASES-1);
   KEEP_ON:
      idxM = ((idxB-idxS)>>1)+idxS;
      if (idxM == idxS)
         return((nbS >= N) ? idxS:idxB);
      nbM = ATL_GetVWsyrkMB(idxM);
      if (nbM > N)
      {
         idxB = idxM;
         nbB = nbM;
      }
      else if (nbM < N)
      {
         idxS = idxM;
         nbS = nbM;
      }
      else /* if (nbM == N) */
         return(idxM);
   goto KEEP_ON;
}
@ROUT ATL_ipsyrk

#ifdef Conj_
void Mjoin(PATL,ipherk)
#else
void Mjoin(PATL,ipsyrk)
#endif
(
   const enum ATLAS_UPLO Uplo,
   const enum ATLAS_TRANS TA,
   ATL_CSZT N,
   ATL_CSZT K,
#ifdef Conj_
   const TYPE ralpha,
#else
   const SCALAR alpha,
#endif
   const TYPE *A,
   ATL_CSZT lda,
#ifdef Conj_
   const TYPE rbeta,
#else
   const SCALAR beta,
#endif
   TYPE *C,
   ATL_CSZT ldc
)
/* 
 * C NxN, A NxK
 * SYRK:
 *    C = alpha * A * A^T + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^T * A + beta*C, if TA == AtlasTrans
 * HERK:
 *    C = alpha * A * A^H + beta*C, if TA == AtlasNoTrans
 *    C = alpha * A^H * A + beta*C, if TA == AtlasTrans
 */
{
   cm2am_t a2blk;
   ablk2cmat_t blk2c;
   void *vp;
   #ifdef TCPLX
      TYPE *rA, *iA, *rC, *iC, *c;
      TYPE one[2] = {ATL_rone, ATL_rzero};
      #ifdef Conj_
         TYPE *crA, *ciA;
         const TYPE alpha[2] = {ralpha, ATL_rzero};
         const TYPE beta[2] = {rbeta, ATL_rzero};
      #endif
   #else
      TYPE *pA, *pC, *c;
      #define one ATL_rone
   #endif
   size_t szA, szC, szE, incAk, nkb, k;
   ATL_CUINT nnu = (N+ATL_SYRKK_NU-1)/ATL_SYRKK_NU, NN=nnu*ATL_SYRKK_NU;
   ATL_UINT kb, kbS, kb0, KB0, idx;
/*
 * Handle degenerate cases
 */
   if (!N)                            /* no output! */
      return;
   if (SCALAR_IS_ZERO(alpha) || !K)  /* really scale of C */
   {
      if (SCALAR_IS_ONE(beta))       /* no-op */
         return;
      if (SCALAR_IS_ZERO(beta))      /* explicit zero */
      {
         if (Uplo == AtlasLower)
            Mjoin(PATL,trsetL)(N, N, beta, beta, C, ldc);
         else
            Mjoin(PATL,trsetU)(N, N, beta, beta, C, ldc);
         return;
      }
      Mjoin(PATL,trscal)(Uplo, N, N, beta, C, ldc);
      #ifdef Conj_  /* must zero complex part of diagonal for HERK! */
         Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
      #endif
      return;
   }
   if (K == 1)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr1(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr1(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (K == 2)  /* Level-2/1 BLAS */
   {
      #ifdef Conj_
         ATL_syr2(Uplo, TA, N, ralpha, A, lda, rbeta, C, ldc);
      #else
         ATL_syr2(Uplo, TA, N, alpha, A, lda, beta, C, ldc);
      #endif
      return;
   }
   if (N == 1)  /* dot product */
   {
      const size_t incA = (TA==AtlasNoTrans) ? lda : 1;
      #ifdef TCPLX
         TYPE dot[2];
         #ifdef Conj_
            Mjoin(PATL,dotc_sub)(K, A, incA, A, incA, dot);
            *dot   *= ralpha;
            if (rbeta != ATL_rzero)
               *dot   += rbeta * *C;
            *C = *dot;
            C[1] = ATL_rzero;
         #else
            const register TYPE ra=(*alpha), ia=alpha[1];
            register TYPE rd, id, rr;
            Mjoin(PATL,dotu_sub)(K, A, incA, A, incA, dot);
            rr = rd = dot[0];
            id = dot[1];
            rd = rr*ra - id*ia;
            id = rr*ia + id*ra;
            if (!SCALAR_IS_ZERO(beta))
            {
               const register TYPE rb=(*beta), ib=beta[1];
               const register TYPE rc=(*C), ic=C[1];
               rd += rb*rc - ib*ic;
               id += rb*ic + ib*rc;
            }
            C[0] = rd;
            C[1] = id;
         #endif
      #else
         TYPE dot;
         dot = Mjoin(PATL,dot)(K, A, incA, A, incA);
         dot *= alpha;
         if (beta != ATL_rzero)
            dot += beta * *C;
         *C = dot;
      #endif
      return;
   }
/*
 * Find NB closest to our present N, and set initial KB to its tuned version
 */
   idx = N2Idx(NN);
   kb = ATL_GetVWsyrkKB(idx);
   szC = ((ATL_SYRKK_NU*ATL_SYRKK_NU+ATL_SYRKK_VLEN-1)/ATL_SYRKK_VLEN)
         * ATL_SYRKK_VLEN;
   szC *= ((nnu+1)*nnu)>>1;  /* only need lower tri blks, not full nnu*nnu */
/*
 * Our SYRK C copy is always to Lower, so if output is Upper, will need
 * workspace to put the Lower part, before reflecting it to Upper.
 * Need max of this extra space, or preload distance.
 */
@skip   szE = (Uplo == AtlasLower) ? 0 : N*N;
@skip   szE = Mmax(szE, ATL_SYRKK_NU*ATL_SYRKK_NU*2);
   szE = (ATL_SYRKK_NU*ATL_SYRKK_NU)<<1;
   if (K > kb)
   {
      nkb = K / kb;
      kb0 = K - nkb*kb;
      if (!kb0)
      {
         kb0 = kb;
         nkb--;
      }
      KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
      kbS = ((kb+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   else
   {
      nkb = 0;
      kb0 = K;
      kbS = kb = KB0 = ((kb0+ATL_SYRKK_KU-1)/ATL_SYRKK_KU)*ATL_SYRKK_KU;
   }
   if (IS_COLMAJ(TA))
   {
      incAk = lda*(kb SHIFT);
      a2blk = Mjoin(PATL,a2blk_syrkT);
   }
   else
   {
      incAk = kb SHIFT;
      a2blk = Mjoin(PATL,a2blk_syrkN);
   }
@skip   szA = nnu*ATL_SYRKK_NU;
@skip   k = (Uplo == AtlasUpper) ? Mmax(kb,N) : kb;
@skip   szA *= k;
   szA = nnu*ATL_SYRKK_NU * kbS;
   vp = malloc(ATL_MulBySize(szA + szC + szE) 
               + 2*ATL_Cachelen);
   ATL_assert(vp);
   #ifdef TCPLX
      iA = ATL_AlignPtr(vp);
      rA = iA + szA;
      iC = rA + szA;
      iC = ATL_AlignPtr(iC);
      rC = iC + szC;
      #ifdef Conj_
         crA = (TA == AtlasNoTrans) ? rA : iA;
         ciA = (TA == AtlasNoTrans) ? iA : rA;
      #endif
      c = rC + szC;
   #else
      pA = ATL_AlignPtr(vp);
      pC = pA + (szA SHIFT);
      pC = ATL_AlignPtr(pC);
      c = pC + szC;
   #endif
#if 0
   ipinfo_t ip;
   int i, flg;
   Mjoin(PATL,ipgenInfo)(&ip, 0, TA, TA, N, N, K, lda, lda, ldc, alpha, beta);
   flg = (Uplo == AtlasLower) ? 0 : 1;
   if (TA == AtlasNoTrans)
      flg |= 2;
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
   }
   else
   {
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ?
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
   }
   Mjoin(PATL,syrkBlk)(&ip, flg|4, 0, 0, A, a2blk, K<=ip.kb?blk2c:NULL, beta, C,
                       pA, NULL, NULL, NULL, NULL, pC, pA);
/*   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1); */
   nkb = K / ip.kb;
   if (nkb * ip.kb == K)
      nkb--;
   for (k=0; k < nkb; k++)
      Mjoin(PATL,syrkBlk)(&ip, flg, 0, k+1, A, a2blk, k == nkb-1 ? blk2c:NULL, 
                          beta, C, pA, NULL, NULL, NULL, NULL, pC, pA);
#else

   #ifdef TCPLX
      a2blk(kb0, N, one, A, lda, rA, iA);
      #ifdef Conj_
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, crA, ciA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, crA, ciA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, rA, rA, rC, ciA, crA, iC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, ciA, crA, iC, iA, iA, rC);
      #else
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, iA, iA, rC, rA, iA, iC);
         Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, rA, iA, iC, rA, rA, rC);
         Mjoin(PATL,amsyrkK_bn)(nnu, nnu, KB0, rA, rA, rC, iA, rA, iC);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, KB0, iA, rA, iC, iA, iA, rC);
      #endif
   #else
      a2blk(kb0, N, ATL_rone, A, lda, pA);
      Mjoin(PATL,amsyrkK_b0)(nnu, nnu, KB0, pA, pA, pC, pA, pA, pC);
   #endif
   A += (kb0 SHIFT) * (IS_COLMAJ(TA) ? lda : 1);
   for (k=0; k < nkb; k++, A += incAk)
   {
      #ifdef TCPLX
         a2blk(kb, N, one, A, lda, rA, iA);
         #ifdef Conj_
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, iA, rC, crA, ciA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, crA, ciA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, rA, rC, ciA, crA, iC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, ciA, crA, iC, iA, iA, rC);
         #else
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, iA, iA, rC, rA, iA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, rA, iA, iC, rA, rA, rC);
            Mjoin(PATL,amsyrkK_bn)(nnu, nnu, kb, rA, rA, rC, iA, rA, iC);
            Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, iA, rA, iC, iA, iA, rC);
         #endif
      #else
         a2blk(kb, N, ATL_rone, A, lda, pA);
         Mjoin(PATL,amsyrkK_b1)(nnu, nnu, kb, pA, pA, pC, pA, pA, pC);
      #endif
   }
   if (Uplo == AtlasLower)
   {
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b1):Mjoin(PATL,SyrkIntoC_aXb1);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bN):Mjoin(PATL,SyrkIntoC_aXbN);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX);
         else
            blk2c = SCALAR_IS_ONE(alpha) ? 
                    Mjoin(PATL,SyrkIntoC_a1bX):Mjoin(PATL,SyrkIntoC_aXbX);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
   else /* Upper */
   {
      @BEGINSKIP
      if (SCALAR_IS_NONE(alpha))
         blk2c = Mjoin(PATL,SyrkIntoC_aNb0);
      else
         blk2c = SCALAR_IS_ONE(alpha) ? 
                 Mjoin(PATL,SyrkIntoC_a1b0):Mjoin(PATL,SyrkIntoC_aXb0);
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, c, N);
         #ifdef Conj_  /* must zero imag part of diagonal for HERK */
         {
            ATL_CINT ldc2=ldc+ldc;
            for (k=0; k < N; k++, c += 2, C += ldc2)
            {
               Mjoin(PATL,axpbyConj)(k+1, one, c, N, beta, C, 1);
               C[((k+1)<<1)-1] = ATL_rzero;
            }
         }
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, c, N);
      #endif
      #ifndef Conj_
      if (SCALAR_IS_ZERO(beta))
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,copy)(k+1, c, N, C, 1);
      else
         for (k=0; k < N; k++, c += (1 SHIFT), C += (ldc SHIFT))
            Mjoin(PATL,axpby)(k+1, one, c, N, beta, C, 1);
      #endif
      @ENDSKIP
      if (SCALAR_IS_ONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb1_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b1_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb1_L2UT);
      }
      else if (SCALAR_IS_NONE(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbN_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bN_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbN_L2UT);
      }
      else if (SCALAR_IS_ZERO(beta))
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNb0_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1b0_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXb0_L2UT);
      }
      else
      {
         if (SCALAR_IS_NONE(alpha))
            blk2c = Mjoin(PATL,SyrkIntoC_aNbX_L2UT);
         else
            blk2c = SCALAR_IS_ONE(alpha) ?
                     Mjoin(PATL,SyrkIntoC_a1bX_L2UT)
                     :Mjoin(PATL,SyrkIntoC_aXbX_L2UT);
      }
      #ifdef TCPLX
         blk2c(N, N, alpha, rC, iC, beta, C, ldc);
         #ifdef Conj_  /* must zero complex part of diagonal! */
            Mjoin(PATLU,zero)(N, C+1, (ldc+1)SHIFT);
         #endif
      #else
         blk2c(N, N, alpha, pC, beta, C, ldc);
      #endif
   }
#endif
   free(vp);
}
#undef one
@ROUT ATL_symmR
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
/*
 * On the Right, symmetrix matrix is GEMM's B, with K=N
 */
#ifdef Conj_
int Mjoin(PATL,ophemmR)
#else
int Mjoin(PATL,opsymmR)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aS, *aB, *aC, *bS;
   #ifdef TCPLX
      TYPE *rS, *rC;
   #endif
   opinfo_t oi;
   int Mjoin(PATL,opsymmInfo)
      (opinfo_t *op, ATL_UINT bv,
       ATL_CSZT M, ATL_CSZT N, ATL_CSZT lda, ATL_CSZT ldb, ATL_CSZT ldc,
       const SCALAR alpha, const SCALAR beta);

   if (!M || !N)
      return(0);
   if (N == 1) /* symmetric matrix is dense scalar! */
   {
      #ifdef TCPLX
         const register TYPE ra=(*alpha), ia=alpha[1], rA = *A;
         #ifdef Conj_
            const TYPE X[2] = {ra*rA, ia*rA};
         #else
            const register TYPE  iA=A[1];
            TYPE X[2];
            *X = ra*rA - ia*iA;
            X[1] = ra*iA + ia*rA;
         #endif
         Mjoin(PATL,axpby)(M, X, B, 1, beta, C, 1);
      #else
         Mjoin(PATL,axpby)(M, alpha*(*A), B, 1, beta, C, 1);
      #endif
      return(0);
   }
   #ifdef Conj_
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?6:4, M, N, lda, ldb,
                              ldc, alpha, beta))
   #else
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?2:0, M, N, lda, ldb,
                              ldc, alpha, beta))
   #endif
      return(1);

   szW = oi.szB;
   szW = Mmax(szW, oi.szA);
   sz = oi.szB + szW + oi.szC;
   sz = ATL_MulBySize(sz) + 3*ATL_Cachelen + oi.exsz;
   vp = malloc(sz);
   ATL_assert(vp);
   aS = ATL_AlignPtr(vp);
   #ifdef TCPLX
      rS = aS + oi.szB;
      aB = rS + oi.szB;
      aB = ATL_AlignPtr(aB);
      aC = aB + (szW<<1);
      aC = ATL_AlignPtr(aC);
      rC = aC + oi.szC;
   #else
      aB = aS + oi.szB;
      aB = ATL_AlignPtr(aB);
      aC = aB + szW;
      aC = ATL_AlignPtr(aC);
   #endif
   if (Uplo == AtlasUpper)
   @whiledef up L U
      @mif up = "L
   else /* Uplo == AtlasLower */
      @endmif
   {
      #ifdef TCPLX
         #ifdef Conj_
            #define SYCPY Mjoin(PATL,hecpy@(up)NB)
         #else
            #define SYCPY Mjoin(PATL,sycpy@(up)NB)
         #endif
         if (alpha[1] == ATL_rzero)
         {
            const register TYPE ral=(*alpha);
            if (ral == ATL_rone)
               Mjoin(SYCPY,_a1)(N, alpha, A, lda, aB, N);
            else if (ral == ATL_rnone)
               Mjoin(SYCPY,_an)(N, alpha, A, lda, aB, N);
            else
               Mjoin(SYCPY,_ar)(N, alpha, A, lda, aB, N);
         }
         else
         #ifdef Conj_
            Mjoin(SYCPY,_a1)(N, oi.ONE, A, lda, aB, N);
         #else
            Mjoin(SYCPY,_aX)(N, alpha, A, lda, aB, N);
         #endif
         #undef SYCPY
      #else
         if (alpha == ATL_rone)
            Mjoin(PATL,sycpy@(up)NB_a1)(N, alpha, A, lda, aB, N);
         else if (alpha == ATL_rnone)
            Mjoin(PATL,sycpy@(up)NB_an)(N, alpha, A, lda, aB, N);
         else
            Mjoin(PATL,sycpy@(up)NB_aX)(N, alpha, A, lda, aB, N);
      #endif
      #if 0
         Mjoin(PATL,geprint)("aG", N, N, A, lda);
         Mjoin(PATL,geprint)("aS", N, N, aB, N);
      #endif
   }
   @endwhile
   #ifdef TCPLX
      oi.b2blk(N, N, oi.ONE, aB, N, rS, aS);
      Mjoin(PATL,oploopsM)(&oi, 0, 0, B, NULL, C, 0, aB, aS, rC, aC);
   #else
      oi.b2blk(N, N, ATL_rone, aB, N, aS);
      Mjoin(PATL,oploopsM)(&oi, 0, 0, B, NULL, C, 0, aB, aS, aC, aC);
   #endif
   free(vp);
   return(0);
}

#ifndef Conj_
   #ifndef TCPLX
      #define ONE ATL_rone
      #define TA AtlasTrans
   #endif
void Mjoin(PATL,symmR_rec)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * If the symmetric matrix is smaller than our rank-K GEMM support, use
 * outer product gemm to solve this problem.
 */
   if (N <= ATL_VWopgen_LAST_KB)
   {
      const enum ATLAS_UPLO Uplo = (flg&1) ? AtlasUpper:AtlasLower;
      #ifdef TCPLX
         if (flg&2) /* really a HEMM */
         {
            if (!Mjoin(PATL,ophemmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
         }
         else
            if (!Mjoin(PATL,opsymmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
      #else
         if (!Mjoin(PATL,opsymmR)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                  beta, C, ldc))
            return;
      #endif
   }
/*
 * To avoid recurring and redundantly copying matrices as we average various
 * size GEMM's performance, attempt to halt recursion on symmetric dims by
 * allocating enough space to copy entire symmetric matrix to dense, and then
 * call GEMM only one time.  Do not do this if the general matrix consists
 * only of a single K-panel: in this case better to recur down and use opsymm.
 * Reason is copy of A a big deal, and copying up front brings it through cache
 * twice, wheareas recursion will provide automatic blocking, and avoid this
 * for small problems where it matters.
 */
   else if (M > ATL_VIEW_BEST_MB)
   {
      if (!Mjoin(PATL,ipsymmR)(flg, M, N, alpha,A,lda,B,ldb,beta,C,ldc))
         return;
   }
/*
 * Otherwise, recur on symmetric matrix until we can stop one of above using:
 * C0 = B0 * A00  + beta*C0  (symm)
 * C0 = B1 * A10 + C0        (gemm)
 * C1 = B0 * A10^T + beta*C1 (gemm)
 * C1 = B1 * A11 + C1        (symm)
 */
   {
      #ifdef TCPLX
         const TYPE ONE[2] = {ATL_rone, ATL_rzero};
         const enum ATLAS_TRANS TA = (flg&2) ? AtlasConjTrans : AtlasTrans;
      #endif
      const int NL=(N>>1), NR = N-NL;
      const TYPE *B1 = B + ldb*(NL SHIFT);
      TYPE *C1 = C + ldc*(NL SHIFT);

      ATL_assert(NL);  /* debugging, remove later */
      Mjoin(PATL,symmR_rec)(flg, M, NL, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
      if (flg&1)  /* Upper matrix */
      {
         const TYPE *A01 = A + NL*(lda SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, TA, M, NL, NR, alpha, 
                          B1, ldb, A01, lda, ONE, C, ldc);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, NR, NL, alpha, 
                          B, ldb, A01, lda, beta, C1, ldc);
      }
      else         /* Lower matrix */
      {
         const TYPE *A10 = A + (NL SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, NL, NR, alpha, 
                          B1, ldb, A10, lda, ONE, C, ldc);
         Mjoin(PATL,ammm)(AtlasNoTrans, TA, M, NR, NL, alpha, 
                          B, ldb, A10, lda, beta, C1, ldc);
      }
      Mjoin(PATL,symmR_rec)(flg, M, NR, alpha, A+(NL SHIFT)*(lda+1), lda, 
                            B1, ldb, ONE, C1, ldc);
   }
}
   #ifdef TCPLX
   #else
      #undef TA
   #endif
#else
   void Mjoin(PATL,symmL_rec)
      (ATL_CUINT, ATL_CSZT, ATL_CSZT, const SCALAR, const TYPE*, ATL_CSZT, 
       const TYPE*, ATL_CSZT, const SCALAR, TYPE*, ATL_CSZT);
#endif
@ROUT ATL_heRL2ipBlk ATL_heRU2ipBlk ATL_syRL2ipBlk ATL_syRU2ipBlk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#define ATL_GLOBIDX 1
#include "atlas_amm.h"
#undef ATL_GLOBIDX
/*
 * D is kb*mb workspace
 * This guy will copy a block from col-major symmetric storage (A) to
 * access-major (in W).
 * The coordinates (KBLK,JBLK) are logical, and therefore indicate which
 * W block is being filled in.  Logical entry (K,J) is start of block,
 * with K=kb*KBLK, J=nb*JBLK.
 * If (K,J) is in the upper triangle, we need to copy an kbxmb block from it,
 * otherwise we copy a transposed block from the accessed triangle to create
 * the reflected block.  The actual block is kbxnb, so the transposed block
 * will be nbxkb.
 *
 * This version has to double copy blocks containing the diagonal so that it
 * can work if nb and kb are not multiples.  It is possible to avoid this
 * double copy if they are multiples, but since large SYMM rarely used, and
 * this is low order cost, we don't currently bother
 */
@ROUT ATL_heRL2ipBlk ATL_heRU2ipBlk 
   @define sy @he@
@ROUT ATL_syRL2ipBlk ATL_syRU2ipBlk
   @define sy @sy@
@ROUT ATL_syRU2ipBlk ATL_heRU2ipBlk 
   @define up @U@
   @define uplo @upper@
@ROUT ATL_syRL2ipBlk ATL_heRL2ipBlk 
   @define up @L@
   @define uplo @lower@
@ROUT ATL_heRL2ipBlk ATL_heRU2ipBlk ATL_syRL2ipBlk ATL_syRU2ipBlk
void Mjoin(PATL,@(sy)R@(up)2ipBlk) /* left, @(uplo) hermitian copy to amm */
(
   ipinfo_t *ip,  /* gemm info to copy to */
   ATL_CUINT bv,  /* bitvec: 0:W is full mat, 1:W is Kpanel, else block only */
   cm2am_t cpN,   /* copy to use in Lower triangle */
   cm2am_t cpT,   /* copy to use in upper triangle (transpose of lower) */
   ATL_iptr_t KBLK, ATL_iptr_t JBLK,  /* ip block coordinates to copy */
   const TYPE *B, /* Right, @(uplo) Hermitian/symmetric matrix to copy */
   TYPE *W,       /* output array for amm B */
   TYPE *D        /* kb*nb workspace for handling diagonal blocks */
)
@ROUT ATL_heRL2ipBlk
{
   unsigned int nb, kb;
   const ATL_iptr_t nfnblks = ip->nfnblks, ldb=ip->ldb;
   ATL_iptr_t J, K=KBLK*ip->kb, szB;
   TYPE *rw, *iw=W;

   if (bv & 1)
      iw = IdxBw_ip(ip, W, KBLK, JBLK);
   else if (bv&2)
      iw = IdxBw_ip(ip, W, KBLK, 0);
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (JBLK < nfnblks)
   {
      nb = ip->nb;
      szB = ip->szB;
      J = JBLK*nb;
   }
   else
   {
      nb = (JBLK < nfnblks+ip->npnblks-1) ? ip->pnb : ip->nF;
      szB = ip->pszB;
      J = nfnblks*ip->nb + (JBLK-nfnblks)*ip->pnb;
   }
   rw = iw + szB;
   if (K >= J) /* block is in lower part, nb may extend to upper */
   {
      if (K > J+nb) /* block is all lower */
         cpN(kb, nb, ip->alpB, B+((K+ldb*J)SHIFT), ldb, rw, iw);
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t j, k;
         TYPE *d = D;
         ATL_CUINT kb2=kb+kb;
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (j=0; j < nb; j++, d += kb2)
         {
            const ATL_iptr_t JJ=J+j;
            for (k=0; k < kb; k++)
            {
               const ATL_iptr_t KK=K+k;
               const ATL_iptr_t ii=k+k;

               if (KK > JJ)       /* In Lower, not diagonal */
               {                  /* imaginary just copied */
                  const ATL_iptr_t IA = (KK+ldb*JJ)SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = B[IA+1];
               }
               else if (JJ > KK)  /* In Upper, not diagonal */
               {                  /* conjugate imaginary */
                  const ATL_iptr_t IA = (JJ+ldb*KK)SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = -B[IA+1];
               }
               else               /* On diagonal */
               {                  /* imag is zeroed */
                  const ATL_iptr_t IA = (KK*(ldb+1))SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = ATL_rzero;
               }
            }
         }
         cpN(kb, nb, ip->alpB, D, kb, rw, iw);
      }
   }
/*
 * The block is actually at (J,K), and block to be copied is nbxkb, so danger
 * is that this block crosses the diagonal (J+kb > K).
 * Therefore, D is nbxkb in this case.
 */
   else if (J+kb < K) /* logical block is wholly contained in upper portion */
      cpT(kb, nb, ip->alpB, B+((J+ldb*K)<<1), ldb, rw, iw);
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t j, k;
      TYPE *d = D;
      ATL_CUINT nb2=nb+nb;
/*
 *    Copy block to D, getting upper elts through reflection
 */
      for (j=0; j < kb; j++, d += nb2)
      {
         for (k=0; k < nb; k++)
         {
            const ATL_iptr_t KK=K+j, JJ=J+k;
            ATL_CUINT ii=k+k;

            if (KK > JJ)      /* In Lower, not diagonal */
            {                 /* Conj imag; copy will Conj again */
               const ATL_iptr_t IA = (KK+ldb*JJ)SHIFT;
               d[ii] = B[IA];
               d[ii+1] = -B[IA+1];
            }
            else if (JJ > KK) /* In Upper, not diagonal */
            {                 /* Leav imag alone, copy will conjugate */
               const ATL_iptr_t IA = (JJ+ldb*KK)SHIFT;
               d[ii] = B[IA];
               d[ii+1] = B[IA+1];
            }
            else              /* On diagonal */
            {                 /* Zero imaginary to make Hermitian */
               const ATL_iptr_t IA = (KK*(ldb+1))SHIFT;
               d[ii] = B[IA];
               d[ii+1] = ATL_rzero;
            }
         }
      }
      cpT(kb, nb, ip->alpB, D, nb, rw, iw);
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_syRL2ipBlk
{
   unsigned int nb, kb;
   const ATL_iptr_t nfnblks = ip->nfnblks, ldb=ip->ldb;
   ATL_iptr_t J, K=KBLK*ip->kb, szB;
   #ifdef TCPLX
      TYPE *rw, *iw=W;

      if (bv&1)
         iw = IdxBw_ip(ip, W, KBLK, JBLK);
      else if (bv&2)
         iw = IdxBw_ip(ip, W, KBLK, 0);
   #else
      TYPE *w=W;

      if (bv&1)
         w = IdxBw_ip(ip, W, KBLK, JBLK);
      else if (bv&2)
         w = IdxBw_ip(ip, W, KBLK, 0);
   #endif
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (JBLK < nfnblks)
   {
      nb = ip->nb;
      szB = ip->szB;
      J = JBLK*nb;
   }
   else
   {
      nb = (JBLK < nfnblks+ip->npnblks-1) ? ip->pnb : ip->nF;
      szB = ip->pszB;
      J = nfnblks*ip->nb + (JBLK-nfnblks)*ip->pnb;
   }
   #ifdef TCPLX
      rw = iw + szB;
   #endif
   if (K >= J) /* block is in lower part, nb may extend to upper */
   {
      if (K >= J+nb) /* block is all lower */
      #ifdef TCPLX
         cpN(kb, nb, ip->alpB, B+((K+ldb*J)SHIFT), ldb, rw, iw);
      #else
         cpN(kb, nb, ip->alpB, B+K+ldb*J, ldb, w);
      #endif
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t j, k;
         TYPE *d = D;
         #ifdef TCPLX
            ATL_CUINT kb2=kb+kb;
         #else
            #define kb2 kb
         #endif
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (j=0; j < nb; j++, d += kb2)
         {
            const ATL_iptr_t JJ=J+j;
            for (k=0; k < kb; k++)
            {
               const ATL_iptr_t KK=K+k;
               const ATL_iptr_t IA = ((KK >= JJ) ? KK+ldb*JJ:JJ+ldb*KK)SHIFT;
               #ifdef TCPLX
                  const ATL_iptr_t ii=k+k;
                  d[ii] = B[IA];
                  d[ii+1] = B[IA+1];
               #else
                  d[k] = B[IA];
               #endif
            }
         }
         #ifdef TCPLX
            cpN(kb, nb, ip->alpB, D, kb, rw, iw);
         #else
            cpN(kb, nb, ip->alpB, D, kb, w);
         #endif
      }
   }
/*
 * The block is actually at (J,K), and block to be copied is nbxkb, so danger
 * is that this block crosses the diagonal (J+kb > K).
 * Therefore, D is nbxkb in this case.
 */
   else if (J+kb <= K) /* logical block is wholly contained in upper portion */
   #ifdef TCPLX
      cpT(kb, nb, ip->alpB, B+((J+ldb*K)<<1), ldb, rw, iw);
   #else
      cpT(kb, nb, ip->alpB, B+J+ldb*K, ldb, w);
   #endif
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t j, k;
      TYPE *d = D;
      #ifdef TCPLX
         ATL_CUINT nb2=nb+nb;
      #else
         #define nb2 nb
      #endif
/*
 *    Copy block to D, getting upper elts through reflection
 */
      for (j=0; j < kb; j++, d += nb2)
      {
         for (k=0; k < nb; k++)
         {
            const ATL_iptr_t KK=K+j, JJ=J+k;
            const ATL_iptr_t IA = ((KK >= JJ) ? KK+ldb*JJ:JJ+ldb*KK)SHIFT;
            #ifdef TCPLX
               ATL_CUINT ii=k+k;
               d[ii] = B[IA];
               d[ii+1] = B[IA+1];
            #else
               d[k] = B[IA];
            #endif
         }
      }
      #ifdef TCPLX
         cpT(kb, nb, ip->alpB, D, nb, rw, iw);
      #else
         cpT(kb, nb, ip->alpB, D, nb, w);
      #endif
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_heRU2ipBlk
{
   unsigned int nb, kb;
   const ATL_iptr_t nfnblks = ip->nfnblks, ldb=ip->ldb;
   ATL_iptr_t J, K=KBLK*ip->kb, szB;
   TYPE *rw, *iw=W;

   if (bv&1)
      iw = IdxBw_ip(ip, W, KBLK, JBLK);
   else if (bv&2)
      iw = IdxBw_ip(ip, W, KBLK, 0);
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (JBLK < nfnblks)
   {
      nb = ip->nb;
      szB = ip->szB;
      J = JBLK*nb;
   }
   else
   {
      nb = (JBLK < nfnblks+ip->npnblks-1) ? ip->pnb : ip->nF;
      szB = ip->pszB;
      J = nfnblks*ip->nb + (JBLK-nfnblks)*ip->pnb;
   }
   rw = iw + szB;
   if (J >= K) /* block is in upper part, kb may extend to upper */
   {
      if (J > K+kb) /* block is all upper */
         cpN(kb, nb, ip->alpB, B+((K+ldb*J)SHIFT), ldb, rw, iw);
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t j, k;
         TYPE *d = D;
         ATL_CUINT kb2=kb+kb;
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (j=0; j < nb; j++, d += kb2)
         {
            const ATL_iptr_t JJ=J+j;
            for (k=0; k < kb; k++)
            {
               const ATL_iptr_t KK=K+k;
               const ATL_iptr_t ii=k+k;
               if (JJ > KK) /* In Upper, not diagonal */
               {            /* just copy imaginary components */
                  const ATL_iptr_t IA = (KK+ldb*JJ)SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = B[IA+1];
               }
               else if (KK > JJ) /* In Lower, not diagonal */
               {                 /* Conjugate imaginary components */
                  const ATL_iptr_t IA = (JJ+ldb*KK)SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = -B[IA+1];
               }
               else              /* On diagonal */
               {                 /* Zero imaginary */
                  const ATL_iptr_t IA = (KK*(ldb+1))SHIFT;
                  d[ii] = B[IA];
                  d[ii+1] = ATL_rzero;
               }
            }
         }
         cpN(kb, nb, ip->alpB, D, kb, rw, iw);
      }
   }
/*
 * The block is actually at (J,K), and block to be copied is nbxkb, so danger
 * is that this block crosses the diagonal (J+kb > K).
 * Therefore, D is nbxkb in this case.
 */
   else if (J+nb < K) /* logical block is wholly contained in upper portion */
      cpT(kb, nb, ip->alpB, B+((J+ldb*K)<<1), ldb, rw, iw);
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t j, k;
      TYPE *d = D;
      ATL_CUINT nb2=nb+nb;
/*
 *    Copy block to D, getting upper elts through reflection
 */
      for (j=0; j < kb; j++, d += nb2)
      {
         for (k=0; k < nb; k++)
         {
            const ATL_iptr_t KK=K+j, JJ=J+k;
            ATL_CUINT ii=k+k;
            if (JJ > KK)      /* In Upper section */
            {                 /* Conj imag, copy will Conj again */
               const ATL_iptr_t IA = (KK+ldb*JJ)SHIFT;
               d[ii] = B[IA];
               d[ii+1] = -B[IA+1];
            }
            else if (KK > JJ) /* In Lower section */
            {                 /* copy imag, copy will Conj as required */
               const ATL_iptr_t IA = (JJ+ldb*KK)SHIFT;
               d[ii] = B[IA];
               d[ii+1] = B[IA+1];
            }
            else              /* On diagonal */
            {                 /* zero imaginary component */
               const ATL_iptr_t IA = ((ldb+1)*KK)SHIFT;
               d[ii] = B[IA];
               d[ii+1] = ATL_rzero;
            }
         }
      }
      cpT(kb, nb, ip->alpB, D, nb, rw, iw);
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_syRU2ipBlk
{
   unsigned int nb, kb;
   const ATL_iptr_t nfnblks = ip->nfnblks, ldb=ip->ldb;
   ATL_iptr_t J, K=KBLK*ip->kb, szB;
   #ifdef TCPLX
      TYPE *rw, *iw=W;

      if (bv&1)
         iw = IdxBw_ip(ip, W, KBLK, JBLK);
      else if (bv&2)
         iw = IdxBw_ip(ip, W, KBLK, 0);
   #else
      TYPE *w=W;

      if (bv&1)
         w = IdxBw_ip(ip, W, KBLK, JBLK);
      else if (bv&2)
         w = IdxBw_ip(ip, W, KBLK, 0);
   #endif
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (JBLK < nfnblks)
   {
      nb = ip->nb;
      szB = ip->szB;
      J = JBLK*nb;
   }
   else
   {
      nb = (JBLK < nfnblks+ip->npnblks-1) ? ip->pnb : ip->nF;
      szB = ip->pszB;
      J = nfnblks*ip->nb + (JBLK-nfnblks)*ip->pnb;
   }
   #ifdef TCPLX
      rw = iw + szB;
   #endif
   if (J >= K) /* block is in upper part, kb may extend to upper */
   {
      if (J >= K+kb) /* block is all upper */
      #ifdef TCPLX
         cpN(kb, nb, ip->alpB, B+((K+ldb*J)SHIFT), ldb, rw, iw);
      #else
         cpN(kb, nb, ip->alpB, B+K+ldb*J, ldb, w);
      #endif
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t j, k;
         TYPE *d = D;
         #ifdef TCPLX
            ATL_CUINT kb2=kb+kb;
         #else
            #define kb2 kb
         #endif
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (j=0; j < nb; j++, d += kb2)
         {
            const ATL_iptr_t JJ=J+j;
            for (k=0; k < kb; k++)
            {
               const ATL_iptr_t KK=K+k;
               const ATL_iptr_t IA = ((JJ >= KK) ? KK+ldb*JJ:JJ+ldb*KK)SHIFT;
               #ifdef TCPLX
                  const ATL_iptr_t ii=k+k;
                  d[ii] = B[IA];
                  d[ii+1] = B[IA+1];
               #else
                  d[k] = B[IA];
               #endif
            }
         }
         #ifdef TCPLX
            cpN(kb, nb, ip->alpB, D, kb, rw, iw);
         #else
            cpN(kb, nb, ip->alpB, D, kb, w);
         #endif
      }
   }
/*
 * The block is actually at (J,K), and block to be copied is nbxkb, so danger
 * is that this block crosses the diagonal (J+kb > K).
 * Therefore, D is nbxkb in this case.
 */
   else if (J+nb <= K) /* logical block is wholly contained in upper portion */
   #ifdef TCPLX
      cpT(kb, nb, ip->alpB, B+((J+ldb*K)<<1), ldb, rw, iw);
   #else
      cpT(kb, nb, ip->alpB, B+J+ldb*K, ldb, w);
   #endif
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t j, k;
      TYPE *d = D;
      #ifdef TCPLX
         ATL_CUINT nb2=nb+nb;
      #else
         #define nb2 nb
      #endif
/*
 *    Copy block to D, getting upper elts through reflection
 */
      for (j=0; j < kb; j++, d += nb2)
      {
         for (k=0; k < nb; k++)
         {
            const ATL_iptr_t KK=K+j, JJ=J+k;
            const ATL_iptr_t IA = ((JJ >= KK) ? KK+ldb*JJ:JJ+ldb*KK)SHIFT;
            #ifdef TCPLX
               ATL_CUINT ii=k+k;
               d[ii] = B[IA];
               d[ii+1] = B[IA+1];
            #else
               d[k] = B[IA];
            #endif
         }
      }
      #ifdef TCPLX
         cpT(kb, nb, ip->alpB, D, nb, rw, iw);
      #else
         cpT(kb, nb, ip->alpB, D, nb, w);
      #endif
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_heLL2ipBlk ATL_heLU2ipBlk ATL_syLL2ipBlk ATL_syLU2ipBlk
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#define ATL_GLOBIDX 1
#include "atlas_amm.h"
#undef ATL_GLOBIDX
/*
 * D is ldd*kb workspace, ldd >= mb
 * This guy will copy a block from col-major symmetric storage (A) to
 * access-major (in W).
 * The coordinates (IBLK,KBLK) are logical, and therefore indicate which
 * W block is being filled in.  Logical entry (I,J) is start of block,
 * with I=mb*IBLK, J=kb*KBLK.
 * If (I,J) is in the accessed triangle, we need to copy an mbxkb block from it,
 * otherwise we copy a transposed block from the accessed triangle to create
 * the reflected block.  The actual block is mbxkb, so the transposed block
 * will be kbxmb.
 *
 * This version has to double copy blocks containing the diagonal so that it
 * can work if mb and kb are not multiples.  It is possible to avoid this
 * double copy if they are multiples, but since large SYMM rarely used, and
 * this is low order cost, we don't currently bother
 */

@ROUT ATL_heLL2ipBlk ATL_heLU2ipBlk 
   @define sy @he@
@ROUT ATL_syLL2ipBlk ATL_syLU2ipBlk
   @define sy @sy@
@ROUT ATL_syLU2ipBlk ATL_heLU2ipBlk 
   @define up @U@
   @define uplo @upper@
@ROUT ATL_syLL2ipBlk ATL_heLL2ipBlk 
   @define up @L@
   @define uplo @lower@
@ROUT ATL_heLL2ipBlk ATL_heLU2ipBlk ATL_syLL2ipBlk ATL_syLU2ipBlk
void Mjoin(PATL,@(sy)L@(up)2ipBlk) /* left, @(uplo) hermitian copy to amm */
(
   ipinfo_t *ip,  /* gemm info to copy to */
   ATL_CUINT bv,  /* 0: wA full mat, 1: wA k-panel */
   cm2am_t cpN,   /* copy to use in Lower triangle */
   cm2am_t cpT,   /* copy to use in upper triangle (transpose of lower) */
   ATL_iptr_t IBLK, ATL_iptr_t KBLK,  /* ip block coordinates to copy */
   const TYPE *A, /* Left, @(uplo) Hermitian matrix to copy */
   TYPE *W,       /* output array for amm A */
   TYPE *D,       /* ldd*kb workspace for handling diagonal blocks */
   ATL_iptr_t ldd /* ldd >= mb */
)
@ROUT ATL_heLL2ipBlk
{
   unsigned int mb, kb;
   const ATL_iptr_t nfmblks = ip->nfmblks, lda=ip->lda;
   ATL_iptr_t I, K=KBLK*ip->kb, szA;
   ATL_iptr_t ldd2=ldd+ldd;
   TYPE *rw, *iw=W;

   if (bv&1)
      iw = IdxAw_ip(ip, W, IBLK, KBLK);
   else if (bv&2)
      iw = IdxAw_ip(ip, W, 0, KBLK);
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (IBLK < nfmblks)
   {
      mb = ip->mb;
      szA = ip->szA;
      I = IBLK*ip->mb;
   }
   else
   {
      mb = (IBLK < nfmblks+ip->npmblks-1) ? ip->pmb : ip->mF;
      szA = ip->pszA;
      I = nfmblks*ip->mb + (IBLK-nfmblks)*ip->pmb;
   }
   rw = iw + szA;
   if (I >= K) /* block is in lower part, kb may extend to upper */
   {
      if (I > K+kb) /* block is all lower */
         cpN(kb, mb, ip->alpA, A+((I+lda*K)SHIFT), lda, rw, iw);
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t i, k;
         TYPE *d = D;
         /* sycp A->D */
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (k=0; k < kb; k++, d += ldd2)
         {
            const ATL_iptr_t KK=K+k;
            for (i=0; i < mb; i++)
            {
               const ATL_iptr_t II=I+i;
               if (II > KK)  /* Still lower, so no need to negate imag */
               {
                  const ATL_iptr_t IA=(II+lda*KK)SHIFT;
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = A[IA+1];
               }
               else if (II < KK) /* Upper, must negate imag */
               {
                  const ATL_iptr_t IA=(KK+lda*II)SHIFT;
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = -A[IA+1];
               }
               else /* II==JJ, diagonal, must zero imag */
               {
                  const ATL_iptr_t IA=II*((1+lda)SHIFT);
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = ATL_rzero;
               }
            }
         }
         cpN(kb, mb, ip->alpA, D, ldd, rw, iw);
      }
   }
/*
 * Block actually at (K,I), and block to be copied is kbxmb, so danger is
 * that this block crosses the diagonal (I+mb > K).
 */
   else if (I+mb < K) /* logical block is wholly contained in upper portion */
      cpT(kb, mb, ip->alpA, A+((K+lda*I)<<1), lda, rw, iw);
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t i, k;
      TYPE *d = D;
      ATL_CUINT kb2=kb+kb;
/*
 *    Copy block to D, getting lower elts through reflection
 */
      for (k=0; k < mb; k++, d += kb2)
      {
         for (i=0; i < kb; i++)
         {
            const ATL_iptr_t KK=K+i, II=I+k;
            if (II > KK)
            {
               const ATL_iptr_t IA = (II+lda*KK)SHIFT;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = -A[IA+1]; /* because cpT will negate! */
            }
            else if (II < KK)
            {
               const ATL_iptr_t IA = (KK+lda*II)SHIFT;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = A[IA+1]; /* cpT will negate as needed for U */
            }
            else /* diagonal, zero imag */
            {
               const ATL_iptr_t IA = ((lda+1)SHIFT)*II;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = ATL_rzero;
            }
         }
      }
      cpT(kb, mb, ip->alpA, D, kb, rw, iw);
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_heLU2ipBlk 
{
   unsigned int mb, kb;
   const ATL_iptr_t nfmblks = ip->nfmblks, lda=ip->lda;
   ATL_iptr_t I, K=KBLK*ip->kb, szA;
   ATL_iptr_t ldd2=ldd+ldd;
   TYPE *rw, *iw=W;

/* printf("B(%lu,%lu)\n", IBLK, KBLK); */
   if (bv&1)
      iw = IdxAw_ip(ip, W, IBLK, KBLK);
   else if (bv&2)
      iw = IdxAw_ip(ip, W, 0, KBLK);
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (IBLK < nfmblks)
   {
      mb = ip->mb;
      szA = ip->szA;
      I = IBLK*ip->mb;
   }
   else
   {
      mb = (IBLK < nfmblks+ip->npmblks-1) ? ip->pmb : ip->mF;
      szA = ip->pszA;
      I = nfmblks*ip->mb + (IBLK-nfmblks)*ip->pmb;
   }
   rw = iw + szA;
   if (K >= I) /* block starts in upper part, mb may extend to lower */
   {
      if (K > I+mb) /* block is all lower */
         cpN(kb, mb, ip->alpA, A+((I+lda*K)SHIFT), lda, rw, iw);
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t i, k;
         TYPE *d = D;
         /* sycp A->D */
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (k=0; k < kb; k++, d += ldd2)
         {
            const ATL_iptr_t KK=K+k;
            for (i=0; i < mb; i++)
            {
               const ATL_iptr_t II=I+i;
               if (KK > II)  /* Still upper, so no need to negate imag */
               {
                  const ATL_iptr_t IA=(II+lda*KK)SHIFT;
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = A[IA+1];
               }
               else if (II > KK) /* Lower, must negate imag */
               {
                  const ATL_iptr_t IA=(KK+lda*II)SHIFT;
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = -A[IA+1];
               }
               else /* II==JJ, diagonal, must zero imag */
               {
                  const ATL_iptr_t IA=II*((1+lda)SHIFT);
                  ATL_CUINT ii = i+i;
                  d[ii] = A[IA];
                  d[ii+1] = ATL_rzero;
               }
            }
         }
         cpN(kb, mb, ip->alpA, D, ldd, rw, iw);
      }
   }
/*
 * This block actually (K,I), and block to be copied is kbxmb, so danger is
 * that this block touches the diagonal (K+kb >= I).
 */
   else if (K+kb < I) /* logical block is wholly contained in lower portion */
      cpT(kb, mb, ip->alpA, A+((K+lda*I)<<1), lda, rw, iw);
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t i, k;
      TYPE *d = D;
      ATL_CUINT kb2=kb+kb;
/*
 *    Copy block to D, getting lower elts through reflection
 */
      for (k=0; k < mb; k++, d += kb2)
      {
         for (i=0; i < kb; i++)
         {
            const ATL_iptr_t KK=K+i, II=I+k;
            if (KK > II)  /* logically in upper, so just copy */
            {
               const ATL_iptr_t IA = (II+lda*KK)SHIFT;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = -A[IA+1]; /* because cpT will negate! */
            }
            else if (KK < II)   /* logically in lower, so conjugate */
            {
               const ATL_iptr_t IA = (KK+lda*II)SHIFT;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = A[IA+1]; /* cpT will negate as needed for U */
            }
            else /* diagonal, zero imag */
            {
               const ATL_iptr_t IA = ((lda+1)SHIFT)*II;
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = ATL_rzero;
            }
         }
      }
      cpT(kb, mb, ip->alpA, D, kb, rw, iw);
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_syLU2ipBlk
{
   unsigned int mb, kb;
   const ATL_iptr_t nfmblks = ip->nfmblks, lda=ip->lda;
   ATL_iptr_t I, K=KBLK*ip->kb, szA;
   #ifdef TCPLX
      ATL_iptr_t ldd2=ldd+ldd;
      TYPE *rw, *iw=W;

      if (bv&1)
         iw = IdxAw_ip(ip, W, IBLK, KBLK);
      else if (bv&2)
         iw = IdxAw_ip(ip, W, 0, KBLK);
   #else
      #define ldd2 ldd
      TYPE *w=W;

      if (bv&1)
         w = IdxAw_ip(ip, W, IBLK, KBLK);
      else if (bv&1)
         w = IdxAw_ip(ip, W, 0, KBLK);
   #endif
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (IBLK < nfmblks)
   {
      mb = ip->mb;
      szA = ip->szA;
      I = IBLK*ip->mb;
   }
   else
   {
      mb = (IBLK < nfmblks+ip->npmblks-1) ? ip->pmb : ip->mF;
      szA = ip->pszA;
      I = nfmblks*ip->mb + (IBLK-nfmblks)*ip->pmb;
   }
   #ifdef TCPLX
      rw = iw + szA;
   #endif
   if (K >= I) /* block starts in upper part, mb may extend to lower */
   {
      if (K >= I+mb) /* block is all upper */
      #ifdef TCPLX
         cpN(kb, mb, ip->alpA, A+((I+lda*K)SHIFT), lda, rw, iw);
      #else
         cpN(kb, mb, ip->alpA, A+I+lda*K, lda, w);
      #endif
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t i, k;
         TYPE *d = D;
         /* sycp A->D */
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (k=0; k < kb; k++, d += ldd2)
         {
            const ATL_iptr_t KK=K+k;
            for (i=0; i < mb; i++)
            {
               const ATL_iptr_t II=I+i;
               const ATL_iptr_t IA = ((KK >= II) ? II+lda*KK:KK+lda*II)SHIFT;
               #ifdef TCPLX
                  const ATL_iptr_t ii=i+i;
                  d[ii] = A[IA];
                  d[ii+1] = A[IA+1];
               #else
                  d[i] = A[IA];
               #endif
            }
         }
         #if 0
            Mjoin(PATL,geprint)("Al", mb, kb, A+I+K*lda, lda);
            Mjoin(PATL,geprint)("Dn", mb, kb, D, ldd);
         #endif
         #ifdef TCPLX
            cpN(kb, mb, ip->alpA, D, ldd, rw, iw);
         #else
            cpN(kb, mb, ip->alpA, D, ldd, w);
         #endif
      }
   }
/*
 * This block actually (K,I), and block to be copied is kbxmb, so danger is
 * that this block crosses the diagonal (K+kb > I).
 */
   else if (K+kb <= I) /* logical block is wholly contained in lower portion */
   #ifdef TCPLX
      cpT(kb, mb, ip->alpA, A+((K+lda*I)<<1), lda, rw, iw);
   #else
      cpT(kb, mb, ip->alpA, A+K+lda*I, lda, w);
   #endif
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t i, k;
      TYPE *d = D;
      #ifdef TCPLX
         ATL_CUINT kb2=kb+kb;
      #else
         #define kb2 kb
      #endif
/*
 *    Copy block to D, getting lower elts through reflection
 */
      for (k=0; k < mb; k++, d += kb2)
      {
         for (i=0; i < kb; i++)
         {
            const ATL_iptr_t KK=K+i, II=I+k;
            const ATL_iptr_t IA = ((II <= KK) ? II+lda*KK:KK+lda*II)SHIFT;
            #ifdef TCPLX
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = A[IA+1];
            #else
               d[i] = A[IA];
            #endif
         }
      }
      #if 0
         Mjoin(PATL,geprint)("AU", kb, mb, A+K+I*lda, lda);
         Mjoin(PATL,geprint)("Dt", kb, mb, D, kb);
      #endif
      #ifdef TCPLX
         cpT(kb, mb, ip->alpA, D, kb, rw, iw);
      #else
         cpT(kb, mb, ip->alpA, D, kb, w);
      #endif
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_syLL2ipBlk 
{
   unsigned int mb, kb;
   const ATL_iptr_t nfmblks = ip->nfmblks, lda=ip->lda;
   ATL_iptr_t I, K=KBLK*ip->kb, szA;
   #ifdef TCPLX
      ATL_iptr_t ldd2=ldd+ldd;
      TYPE *rw, *iw=W;

      if (bv&1)
         iw = IdxAw_ip(ip, W, IBLK, KBLK);
      else if (bv&2)
         iw = IdxAw_ip(ip, W, 0, KBLK);
   #else
      #define ldd2 ldd
      TYPE *w=W;

      if (bv&1)
         w = IdxAw_ip(ip, W, IBLK, KBLK);
      else if (bv&2)
         w = IdxAw_ip(ip, W, 0, KBLK);
   #endif
   kb = (KBLK < ip->nfkblks) ? ip->kb : ip->kb0;
   if (IBLK < nfmblks)
   {
      mb = ip->mb;
      szA = ip->szA;
      I = IBLK*ip->mb;
   }
   else
   {
      mb = (IBLK < nfmblks+ip->npmblks-1) ? ip->pmb : ip->mF;
      szA = ip->pszA;
      I = nfmblks*ip->mb + (IBLK-nfmblks)*ip->pmb;
   }
   #ifdef TCPLX
      rw = iw + szA;
   #endif
   if (I >= K) /* block is in lower part, kb may extend to upper */
   {
      if (I >= K+kb) /* block is all lower */
      #ifdef TCPLX
         cpN(kb, mb, ip->alpA, A+((I+lda*K)SHIFT), lda, rw, iw);
      #else
         cpN(kb, mb, ip->alpA, A+I+lda*K, lda, w);
      #endif
      else           /* block has diagonal in it! */
      {
         ATL_iptr_t i, k;
         TYPE *d = D;
         /* sycp A->D */
/*
 *       Copy block to D, getting upper elts through reflection
 */
         for (k=0; k < kb; k++, d += ldd2)
         {
            const ATL_iptr_t KK=K+k;
            for (i=0; i < mb; i++)
            {
               const ATL_iptr_t II=I+i;
               const ATL_iptr_t IA = ((II >= KK) ? II+lda*KK:KK+lda*II)SHIFT;
               #ifdef TCPLX
                  const ATL_iptr_t ii=i+i;
                  d[ii] = A[IA];
                  d[ii+1] = A[IA+1];
               #else
                  d[i] = A[IA];
               #endif
            }
         }
         #if 0
            Mjoin(PATL,geprint)("Al", mb, kb, A+I+K*lda, lda);
            Mjoin(PATL,geprint)("Dn", mb, kb, D, ldd);
         #endif
         #ifdef TCPLX
            cpN(kb, mb, ip->alpA, D, ldd, rw, iw);
         #else
            cpN(kb, mb, ip->alpA, D, ldd, w);
         #endif
      }
   }
/*
 * This block actually (K,I), and block to be copied is kbxmb, so danger is
 * that this block crosses the diagonal (I+mb > K).
 */
   else if (I+mb <= K) /* logical block is wholly contained in upper portion */
   #ifdef TCPLX
      cpT(kb, mb, ip->alpA, A+((K+lda*I)<<1), lda, rw, iw);
   #else
      cpT(kb, mb, ip->alpA, A+K+lda*I, lda, w);
   #endif
   else        /* block is reflected across diagonal! */
   {
      ATL_iptr_t i, k;
      TYPE *d = D;
      #ifdef TCPLX
         ATL_CUINT kb2=kb+kb;
      #else
         #define kb2 kb
      #endif
/*
 *    Copy block to D, getting lower elts through reflection
 */
      for (k=0; k < mb; k++, d += kb2)
      {
         for (i=0; i < kb; i++)
         {
            const ATL_iptr_t KK=K+i, II=I+k;
            const ATL_iptr_t IA = ((II >= KK) ? II+lda*KK:KK+lda*II)SHIFT;
            #ifdef TCPLX
               ATL_CUINT ii=i+i;
               d[ii] = A[IA];
               d[ii+1] = A[IA+1];
            #else
               d[i] = A[IA];
            #endif
         }
      }
      #if 0
         Mjoin(PATL,geprint)("AU", kb, mb, A+K+I*lda, lda);
         Mjoin(PATL,geprint)("Dt", kb, mb, D, kb);
      #endif
      #ifdef TCPLX
         cpT(kb, mb, ip->alpA, D, kb, rw, iw);
      #else
         cpT(kb, mb, ip->alpA, D, kb, w);
      #endif
   }
   #if 0
   {
      ATL_iptr_t MM=IBLK*ip->mb+mb, KK=KBLK*ip->kb+kb, K4=Mmin(KK,4);
      char nm[64];
      sprintf(nm, "S%lu_%lu", (unsigned long)MM, (unsigned long)KK);
      Mjoin(PATL,ipprint)(stdout, ip, 1, nm, MM, K4, W);
   }
   #endif
}
@ROUT ATL_ipsyGetCopyA
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#include "atlas_amm.h"
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_a1.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_aN.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_aX.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_a1.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_aN.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_aX.h))
#ifdef TCPLX
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromACg_a1.h))
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromACg_aN.h))
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromACg_aX.h))
#endif
#include Mstr(Mjoin(ATLAS_PRE,ipgen_view.h))
cm2am_t Mjoin(PATL,ipsyGetCopyA)(ipinfo_t *ip, ATL_CUINT flg, cm2am_t *CPT)
{
   cm2am_t cpN, cpT;
   ATL_UINT icpA;
   const SCALAR alpha = ip->alpA;

   icpA = ATL_GetViewA2BLK(ip->idx);
   icpA += icpA;
   #ifdef TCPLX
      if (alpha[1] == ATL_rzero)
      {
         const TYPE ralp = *alpha;
         if (ralp == ATL_rone)
         {
            cpN = (cm2am_t) ATL_CpyFromATg_a1[icpA];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromACg_a1[icpA]:ATL_CpyFromANg_a1[icpA]);
         }
         else if (ralp == ATL_rnone)
         {
            cpN = (cm2am_t) ATL_CpyFromATg_aN[icpA];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromACg_aN[icpA]:ATL_CpyFromANg_aN[icpA]);
         }
         else
         {
            cpN = (cm2am_t) ATL_CpyFromATg_aX[icpA];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromACg_aX[icpA]:ATL_CpyFromANg_aX[icpA]);
         }
      }
      else
      {
         cpN = (cm2am_t) ATL_CpyFromATg_aX[icpA];
         cpT = (cm2am_t) ((flg&2) ? 
                          ATL_CpyFromACg_aX[icpA]:ATL_CpyFromANg_aX[icpA]);
      }
   #else /* real */
      if (alpha == ATL_rone)
      {
         cpN = (cm2am_t) ATL_CpyFromATg_a1[icpA];
         cpT = (cm2am_t) ATL_CpyFromANg_a1[icpA];
      }
      else if (alpha == ATL_rnone)
      {
         cpN = (cm2am_t) ATL_CpyFromATg_aN[icpA];
         cpT = (cm2am_t) ATL_CpyFromANg_aN[icpA];
      }
      else
      {
         cpN = (cm2am_t) ATL_CpyFromATg_aX[icpA];
         cpT = (cm2am_t) ATL_CpyFromANg_aX[icpA];
      }
   #endif
   *CPT = cpT;
   return(cpN);
}
@ROUT ATL_ipsymmL_tN
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#define ATL_GLOBIDX 1
#include "atlas_amm.h"
#undef ATL_GLOBIDX

/* #define DEBUG 1 */
#ifdef DEBUG
   #include "atlas_bitvec.h"
   #include "atlas_tst.h"
#endif

void Mjoin(PATL,ipsymmL_tN_wrk)
(
   ipinfo_t *ip,
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM?, 8: wA full?  */
   const TYPE *S, /* symmetric A in lower or upper storage */
   const TYPE *B, /* general matrix B for gemm */
   const SCALAR beta,
   TYPE *C,       /* matrix to write to */
   TYPE *D,       /* mb*kb workspace for handling diagonal blocks */
   TYPE *wA,      /* workspace to cpy A to, mb*kb if bit 8 unset, else full */
   TYPE *wB,      /* spc for B, should be full panel sized */
   TYPE *rC,      /* real portion of C */
   TYPE *iC       /* if complex, imaginary portion of C */
)
{
   cm2am_t cpN, cpT;
   ablk2cmat_t blk2c=ip->blk2c;
   const ATL_iptr_t nfmblks = ip->nfmblks;
   const ATL_iptr_t nmblks = nfmblks + ip->npmblks, nfkblks = ip->nfkblks;
   ATL_iptr_t pszB = ip->pszB, szB = (ip->nfnblks) ? ip->szB : pszB;
   ATL_iptr_t iB, kB; /* block counters */
   ATL_UINT bv = ((flg&256)>>7)|8|16;
   ATL_CUINT cBV=(flg>>8)&1;
   TYPE *wb = wB;
   ATL_UINT mb;
   void (*cpyBlk)
      (ipinfo_t *ip, ATL_CUINT bv, cm2am_t cpN, cm2am_t cpU, ATL_iptr_t IBLK,
       ATL_iptr_t KBLK, const TYPE *A, TYPE *W, TYPE *D, ATL_iptr_t ldd);

   cpN = Mjoin(PATL,ipsyGetCopyA)(ip, flg, &cpT);
   #ifdef TCPLX
      if (flg&1)
         cpyBlk = (flg&2) ? Mjoin(PATL,heLU2ipBlk) : Mjoin(PATL,syLU2ipBlk);
      else
         cpyBlk = (flg&2) ? Mjoin(PATL,heLL2ipBlk) : Mjoin(PATL,syLL2ipBlk);
   #else
      cpyBlk = (flg&1) ? Mjoin(PATL,syLU2ipBlk) : Mjoin(PATL,syLL2ipBlk);
   #endif
   if (nfmblks)
      mb = ip->mb;
   else
      mb = (nmblks == 1) ? ip->mF : ip->pmb;
/*
 * In first pass, we copy both A & B; later passes need only cpy A 
 */
   for (kB=0; kB < nfkblks; kB++)
   {
      cpyBlk(ip, cBV, cpN, cpT, 0, kB, S, wA, D, mb);
      Mjoin(PATL,doAmmBlk)(ip, bv, 0, 0, kB, NULL, B, NULL, wA, wB, rC, iC, 
                           beta, NULL);
      bv &= ~16;
   }
   cpyBlk(ip, cBV, cpN, cpT, 0, kB, S, wA, D, mb);
   Mjoin(PATL,doAmmBlk)(ip, bv, 0, 0, kB, NULL, B, C, wA, wB, rC, iC, 
                        beta, blk2c);
   for (iB=1; iB < nmblks; iB++)
   {
      bv |= 16;
      for (kB=0; kB < nfkblks; kB++)
      {
         cpyBlk(ip, cBV, cpN, cpT, iB, kB, S, wA, D, mb);
         Mjoin(PATL,doAmmBlk)(ip, bv, iB, 0, kB, NULL, NULL, NULL, wA, wB, 
                              rC, iC, beta, NULL);
         bv &= ~16;
      }
      cpyBlk(ip, cBV, cpN, cpT, iB, kB, S, wA, D, mb);
      Mjoin(PATL,doAmmBlk)(ip, bv, iB, 0, kB, NULL, NULL, IdxC_ip(ip, C, iB, 0),
                           wA, wB, rC, iC, beta, blk2c);
   }
}

int Mjoin(PATL,ipsymmL_tN)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_iptr_t  M,
   ATL_iptr_t N,
   const SCALAR alpha,
   const TYPE *S,
   ATL_iptr_t lds,
   const TYPE *G,
   ATL_iptr_t ldg,
   const SCALAR beta,
   TYPE *C,
   ATL_iptr_t ldc
)
{
   #ifdef TCPLX
      TYPE *rC;
   #else
      #define rC wC
   #endif
   ipinfo_t ip;
   ATL_iptr_t sz, szA, szB, ldd, tkblks;
   unsigned int mb, extra;
   void *vp=NULL;
   TYPE *wd, *wA; /* work for diagonal blks, work for copied A */
   TYPE *wB, *wC; /* work for B & C matrices; both aliased with wd */
   #ifdef DEBUG
      ATL_BV_t *bv;
   #endif

   Mjoin(PATL,ipgenInfo)(&ip, 0, AtlasNoTrans, AtlasNoTrans, M, N, M, lds, ldg,
                         ldc, alpha, beta);
/*
 * This code specialized for when B is only a column panel!
 */
   if (N > ip.nb)
      return(1);
/*
 * This routine attempts to malloc space for 1 block of C, 1 column panel of B,
 * and block of A.  Also needs space for mb*kb workspace, which is overlapped
 * with extra space.
 */
   ATL_assert(ip.npmblks < 2);
   if (ip.nfmblks)
   {
      mb = ip.mb;
      szA = ip.szA;
   }
   else
   {
      mb = ip.pmb;
      szA = ip.pszA;
   }
   tkblks = ip.nfkblks+1;
   sz = (ip.nfkblks) ? ip.kb : ip.kb0;
   szB = (ip.nfnblks) ? ip.szB : ip.pszB;
   szB *= tkblks;
   extra = ip.exsz;
   sz *= mb;
   extra = Mmax(sz, extra);
   sz = ATL_MulBySize(extra + szA + szB + ip.szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);
   wA = ATL_AlignPtr(vp);
   wB = wA + (szA SHIFT);
   wB = ATL_AlignPtr(wB);
   wC = wB + (szB SHIFT);
   wC = ATL_AlignPtr(wC);
   #ifdef TCPLX
      rC = wC + ip.szC;
      wd = rC + ip.szC;
   #else
      wd = wC + ip.szC;
   #endif

   Mjoin(PATL,ipsymmL_tN_wrk)(&ip, flg, S, G, beta, C, wd, wA, wB, rC, wC);
   #if defined(DEBUG) && 0
      Mjoin(PATL,geprint)("B", M, N, G, ldg);
      Mjoin(PATL,ipprint)(stdout, &ip, 2, "wB", M, N, wB);
   #endif
   #if defined(DEBUG) && 1
   if (M <= ip.mb && M <= ip.kb)
   {
      #ifdef TCPLX
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 1|((flg&1)<<2)|((flg&2)<<2),
                                    wA, M, S);
      #else
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 1|((flg&1)<<2), wA, M, S);
      #endif
      if (bv)
      {
         ATL_print2dBV(M, M, bv);
         free(bv);
         printf("\nDONE PRINt2DBV\n\n");
      }
      else
         printf("\nNO ERRORS FOUND IN SYCP!\n\n");
   }
   #endif
   free(vp);
   return(0);
}
#undef ONE
@ROUT ATL_ipsymmL
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
/*
 * SYMM involves a symmetric matrix (A) and dense matrix (B).
 * This routine uses normal GEMM to do a SYMM by reflecting the symmetric matrix
 * into dense access-major storage.  The recursive symm divides A
 * which means eventually the shape is dominated by B, and
 * so the double copy of B inherent in recursion becomes a dominant cost.
 * This routine avoids this problem by copying A up front, and then putting
 * the dense A as inner matrix, so that B is copied only once, 1 panel at 
 * a time.
 */
#include "atlas_misc.h"
#define ATL_GLOBIDX 1
#include "atlas_amm.h"
#undef ATL_GLOBIDX
#define ATL_WANT_ILCM 1
#include "atlas_iopt.h"
#undef ATL_WANT_ILCM
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
@skip #include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,ipgen_view.h))
/*
 * inline copy never really wins, and recursion beats symm_tN, so this should
 * always be 1
 */
#define SEP_CPY 1
/*
 * These required for testing only
 */
#define DEBUG 1
#ifdef DEBUG
   #include "atlas_bitvec.h"
   #include "atlas_tst.h"
#endif
static void ATL_cpsy2amm
(
   ipinfo_t *ip,
   ATL_CUINT flg, /* bitvec: 0:Upper?; 1:HEMM? */
   ATL_iptr_t N,                         /* order of A */
   const TYPE *S, ATL_iptr_t lds,        /* symmetric in lower storage */
   TYPE *W, ATL_iptr_t ldW,              /* ldWxkb workspace */
   TYPE *w                               /* spc for entire S in block storage */
)
/*
 * b = alpha * S, b is in access-major storage, S is upper or lower col-major
 * NOTE: this is most general routine, where the LxL workspace W is used
 *       to copy square superblocks from the original matrix.  This allows
 *       us to reflect symmetric matrices to make full, and follow the diagonal
 *       easily even if MB & NB are not multiples.  For the case where MB & NB
 *       are multiples (or equal), we can use less workspace & copies.
 */
{
   ATL_iptr_t j;
   cm2am_t cpN, cpT;
   const unsigned int mb=ip->mb, kb = ip->kb;
   const ATL_iptr_t nmblks = ip->nfmblks + ip->npmblks, nkblks = ip->nfkblks+1;
   ATL_iptr_t iB, kB; /* block counters */
   void (*cpyBlk)
      (ipinfo_t *ip, ATL_CUINT bv, cm2am_t cpN, cm2am_t cpU, ATL_iptr_t IBLK,
       ATL_iptr_t KBLK, const TYPE *A, TYPE *W, TYPE *D, ATL_iptr_t ldd);

   cpN = Mjoin(PATL,ipsyGetCopyA)(ip, flg, &cpT);
   #ifdef TCPLX
      if (flg&1)
         cpyBlk = (flg&2) ? Mjoin(PATL,heLU2ipBlk) : Mjoin(PATL,syLU2ipBlk);
      else
         cpyBlk = (flg&2) ? Mjoin(PATL,heLL2ipBlk) : Mjoin(PATL,syLL2ipBlk);
   #else
      cpyBlk = (flg&1) ? Mjoin(PATL,syLU2ipBlk) : Mjoin(PATL,syLL2ipBlk);
   #endif
   for (kB=0; kB < nkblks; kB++)
      for (iB=0; iB < nmblks; iB++)
         cpyBlk(ip, 1, cpN, cpT, iB, kB, S, w, W, ldW);
   @BEGINSKIP
   #if 0
   {
      ATL_iptr_t MM=ip->nfmblks*ip->mb+ip->npmblks*ip->pmb, 
                 KK=ip->nfkblks*ip->kb+ip->kb0;
      Mjoin(PATL,ipprint)(stdout, ip, 1, "Sa", MM, KK, w);
   }
   #endif
   @ENDSKIP
}

int Mjoin(PATL,ipsymmL)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *S,
   ATL_CSZT lds,
   const TYPE *G,
   ATL_CSZT ldg,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef TCPLX
      TYPE *rC;
   #else
      #define rC wC
   #endif
   ipinfo_t ip;
   ATL_iptr_t sz, szA, szB, ldd, tkblks;
   unsigned int mb, extra;
   void *vp=NULL;
   TYPE *wd, *wA; /* work for diagonal blks, work for copied A */
   TYPE *wB, *wC; /* work for B & C matrices; both aliased with wd */
   #ifdef DEBUG
      ATL_BV_t *bv;
   #endif
   @BEGINSKIP
/*
 * Uncomment to do with gemm via reflection
 */
   #if 0
   {
      TYPE *A;
      A = malloc(M*ATL_MulBySize(M));
      ATL_assert(A);
      Mjoin(PATL,gecopy)(M, M, S, lds, A, M);
      Mjoin(PATL,syreflect)(AtlasLower, M, A, M);
      Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, N, M, alpha, A, M, 
                       G, ldg, beta, C, ldc);
      free(A);
      return(0);
   }
   #endif
   @ENDSKIP
   Mjoin(PATL,ipgenInfo)(&ip, 0, AtlasNoTrans, AtlasNoTrans, M, N, M, lds, ldg,
                         ldc, alpha, beta);
/*
 * This routine attempts to malloc space for 1 block of C, 1 column panel of B,
 * and entire matrix A.  Also needs space for kb*mb workspace, which is
 * cannot be overlapped with any workspace when doing A copy inline
 */
   ATL_assert(ip.npmblks < 2);
   mb = (ip.nfmblks) ? ip.mb : ip.pmb;
   sz = (ip.nfkblks) ? ip.kb : ip.kb0;
   if (mb <= M)
      ldd = mb;
   else
   {
      ldd = ATL_MulBySize(M) + ATL_Cachelen - 1;
      ldd = ATL_MulByCachelen(ATL_DivByCachelen(ldd));
      ldd = ATL_DivBySize(ldd);
   }
   tkblks = ip.nfkblks+1;
   szA = tkblks*(ip.nfmblks*ip.szA + ip.npmblks*ip.pszA);
   szB = (ip.nfnblks) ? ip.szB : ip.pszB;
   szB *= tkblks;
   sz *= ldd;
   #if SEP_CPY
      extra = ip.exsz;
      if (sz > extra+szB+ip.szC)
         extra += sz - extra - szA - ip.szC;
   #else
      extra = Mmax(sz, ip.exsz);
   #endif

   sz = ATL_MulBySize(extra + szA + szB + ip.szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);
    wA = ATL_AlignPtr(vp);
    wB = wA + (szA SHIFT);
    wB = ATL_AlignPtr(wB);
    wC = wB + (szB SHIFT);
    wC = ATL_AlignPtr(wC);
    #ifdef TCPLX
       rC = wC + ip.szC;
       #if !SEP_CPY
          wd = rC + ip.szC
       #endif
    #elif !SEP_CPY
       wd = wC + ip.szC;
    #endif
    #if SEP_CPY
       wd = wB;
    #endif
   @BEGINSKIP
   #if defined(DEBUG) && 0
   {
      ATL_iptr_t i, len=szA SHIFT;
      double mul=10;
      while (mul < len)
         mul *= 10;
      mul = 1.0 / mul;
      for (i=0; i < len; i++)
         wA[i] = (-4.0 - i*mul)*1.0e6;
   }
   #endif
   @ENDSKIP
   #if SEP_CPY
      ATL_cpsy2amm(&ip, flg, N, S, lds, wd, ldd, wA);
   #else
      Mjoin(PATL,ipsymmL_tN_wrk)(&ip, flg+256, S, G, beta, C, wd, wA,wB,rC,wC);
   #endif
   @BEGINSKIP
/* 
 * Uncomment to get 1.cnt sequential numbering
 */
   #if defined(DEBUG) && 0
   {
      int k;
      double mul = 10.0;
      while (szA > mul)
         mul *= 10;
      printf("mul=%f\n", mul);
      mul = 1 / mul;
      for (k=0; k < szA; k++)
         wA[k] = 1.0+k*mul;
   }
   #endif
   @ENDSKIP
   #if defined(DEBUG) && 0
      #ifdef TCPLX
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 1|((flg&1)<<2)|((flg&2)<<2),
                                    wA, M, S);
      #else
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 1|((flg&1)<<2), wA, M, S);
      #endif
      if (bv)
      {
         ATL_print2dBV(M, M, bv);
         free(bv);
         printf("\nDONE PRINt2DBV\n\n");
      }
      else
         printf("\nNO ERRORS FOUND IN SYCP!\n\n");
   #endif
   #if 0
      Mjoin(PATL,ipprint)(stdout, &ip, 1, "SY", M, M, wA);
   #endif
   @BEGINSKIP
/*
 * Uncomment this code to make sure problem isn't in iploopsNMK!
 */
   #if 0
   {
      TYPE *A;
      #ifdef TCPLX
         #define ONE ip.ONE
      #else
         #define ONE ATL_rone
      #endif
      A = malloc(lds*ATL_MulBySize(M));
      ATL_assert(A);
      Mjoin(PATL,gecopy)(M, M, S, lds, A, lds);
      #ifdef TCPLX
      if (flg&2)
      {
         Mjoin(PATL,hereflect)(AtlasLower, M, A, lds);
         Mjoin(PATL,zero)(M, A+1, (lds+1)SHIFT);
      }
      else
      #endif
      Mjoin(PATL,syreflect)(AtlasLower, M, A, lds);
      Mjoin(PATL,iploopsNMK)(&ip, 0, 0, A, G, C, 1|2|4, wA, wB, rC, wC, beta,
                             ip.blk2c);
      free(A);
   }
   #else
   @ENDSKIP
   #if SEP_CPY
      Mjoin(PATL,iploopsNMK)(&ip, 0, 0, NULL, G, C, 1|2|4, wA, wB, rC, wC, beta,
                             ip.blk2c);
   #else
      Mjoin(PATL,iploopsNMK)(&ip, 0, 1, NULL, G, C, 1|2|4, wA, wB, rC, wC, beta,
                             ip.blk2c);
   #endif
   free(vp);
   return(0);
}
#undef ONE
@ROUT ATL_ipsyGetCopyB
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#include "atlas_amm.h"
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_a1.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_aN.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromANg_aX.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_a1.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_aN.h))
#include Mstr(COPY/Mjoin(ATLAS_PRE,FromATg_aX.h))
#ifdef TCPLX
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromAHg_a1.h))
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromAHg_aN.h))
   #include Mstr(COPY/Mjoin(ATLAS_PRE,FromAHg_aX.h))
#endif
#include Mstr(Mjoin(ATLAS_PRE,ipgen_view.h))
cm2am_t Mjoin(PATL,ipsyGetCopyB)
(
   ipinfo_t *ip,
   ATL_CUINT flg, /* bitvec: 0:Upper?; 1:HEMM? */
   cm2am_t *CPT
)
{
   cm2am_t cpN, cpT;
   ATL_UINT icpB;
   const SCALAR alpha = ip->alpB;

   icpB = ATL_GetViewB2BLK(ip->idx);
   icpB += icpB;
   #ifdef TCPLX
      if (alpha[1] == ATL_rzero)
      {
         const TYPE ralp = *alpha;
         if (ralp == ATL_rone)
         {
            cpN = (cm2am_t) ATL_CpyFromANg_a1[icpB];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromAHg_a1[icpB]:ATL_CpyFromATg_a1[icpB]);
         }
         else if (ralp == ATL_rnone)
         {
            cpN = (cm2am_t) ATL_CpyFromANg_aN[icpB];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromAHg_aN[icpB]:ATL_CpyFromATg_aN[icpB]);
         }
         else
         {
            cpN = (cm2am_t) ATL_CpyFromAHg_aX[icpB];
            cpT = (cm2am_t) ((flg&2) ? 
                             ATL_CpyFromAHg_aX[icpB]:ATL_CpyFromATg_aX[icpB]);
         }
      }
      else
      {
         cpN = (cm2am_t) ATL_CpyFromANg_aX[icpB];
         cpT = (cm2am_t) ((flg&2) ? 
                          ATL_CpyFromAHg_aX[icpB]:ATL_CpyFromATg_aX[icpB]);
      }
   #else
      if (alpha == ATL_rone)
      {
         cpN = (cm2am_t) ATL_CpyFromANg_a1[icpB];
         cpT = (cm2am_t) ATL_CpyFromATg_a1[icpB];
      }
      else if (alpha == ATL_rnone)
      {
         cpN = (cm2am_t) ATL_CpyFromANg_aN[icpB];
         cpT = (cm2am_t) ATL_CpyFromATg_aN[icpB];
      }
      else
      {
         cpN = (cm2am_t) ATL_CpyFromANg_aX[icpB];
         cpT = (cm2am_t) ATL_CpyFromATg_aX[icpB];
      }
   #endif
   *CPT = cpT;
   return(cpN);
}

@ROUT ATL_ipsymmR
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
/*
 * SYMM involves a dense matrix (A) and a symmetric matrix (B).
 * This routine uses normal GEMM to do a SYMM by reflecting the symmetric matrix
 * into dense access-major storage.  The recursive symm divides B
 * which means eventually the shape is dominated by A, and
 * so the double copy of A inherent in recursion becomes a dominant cost.
 * This routine avoids this problem by copying B up front, and then putting
 * the reflected B as inner matrix, so that A is copied only once, 1 panel at 
 * a time.
 */
#include "atlas_misc.h"
#define ATL_GLOBIDX 1
#include "atlas_amm.h"
#undef ATL_GLOBIDX
#define ATL_WANT_ILCM 1
#include "atlas_iopt.h"
#undef ATL_WANT_ILCM
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
@skip #include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,ipgen_view.h))
/*
 * These required for testing only
 */
/* #define DEBUG 1 */
#ifdef DEBUG
   #include "atlas_bitvec.h"
   #include "atlas_tst.h"
#endif
static void ATL_cpsy2amm
(
   ipinfo_t *ip,
   ATL_CUINT flg, /* bitvec: 0:Upper?; 1:HEMM? */
   const TYPE *S, ATL_iptr_t lds,        /* symmetric in lower storage */
   TYPE *W,                              /* nbxkb workspace */
   TYPE *w                               /* spc for entire S in block storage */
)
/*
 * w = alpha * S, w is in access-major storage, S is upper or lower col-major
 * NOTE: this is most general routine, where the nbxkb W allows us to reflect
 *       any block containing the diagonal.  For the case where MB & NB
 *       are multiples, we could optimize this by not doing the intermediate
 *       copy to W, but since SYMM is not that important, we have not bothered
 *       to write this special case.
 */
{
   ATL_iptr_t j;
   cm2am_t cpN, cpT;
   const ATL_iptr_t nnblks = ip->nfnblks + ip->npnblks, nkblks = ip->nfkblks+1;
   ATL_iptr_t jB, kB; /* block counters */
   void (*cpyBlk)
      (ipinfo_t *ip, ATL_CUINT, cm2am_t cpN, cm2am_t cpU, ATL_iptr_t KBLK, 
       ATL_iptr_t JBLK, const TYPE *B, TYPE *W, TYPE *D);

   cpN = Mjoin(PATL,ipsyGetCopyB)(ip, flg, &cpT);
   #ifdef TCPLX
      if (flg&1)
         cpyBlk = (flg&2) ? Mjoin(PATL,heRU2ipBlk) : Mjoin(PATL,syRU2ipBlk);
      else
         cpyBlk = (flg&2) ? Mjoin(PATL,heRL2ipBlk) : Mjoin(PATL,syRL2ipBlk);
   #else
      cpyBlk = (flg&1) ? Mjoin(PATL,syRU2ipBlk) : Mjoin(PATL,syRL2ipBlk);
   #endif
   for (jB=0; jB < nnblks; jB++)
      for (kB=0; kB < nkblks; kB++)
         cpyBlk(ip, 1, cpN, cpT, kB, jB, S, w, W);
   @BEGINSKIP
   #if 0
   {
      ATL_iptr_t NN=ip->nfnblks*ip->nb+ip->npnblks*ip->pnb, 
                 KK=ip->nfkblks*ip->kb+ip->kb0;
      Mjoin(PATL,geprint)("S", KK, KK, S, lds);
      Mjoin(PATL,ipprint)(stdout, ip, 2, "Sb", KK, NN, w);
   }
   #endif
   @ENDSKIP
}

int Mjoin(PATL,ipsymmR)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *S,
   ATL_CSZT lds,
   const TYPE *G,
   ATL_CSZT ldg,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   #ifdef TCPLX
      TYPE *rC;
   #else
      #define rC wC
   #endif
   ipinfo_t ip;
   ATL_iptr_t sz, szA, szB, ldd, tkblks;
   unsigned int nb, extra;
   void *vp=NULL;
   TYPE *wd, *wA; /* work for diagonal blks, work for copied A */
   TYPE *wB, *wC; /* work for B & C matrices; both aliased with wd */
   #ifdef DEBUG
      ATL_BV_t *bv;
   #endif
   @BEGINSKIP
/*
 * Uncomment to do with gemm via reflection
 */
   #if 0
   {
      TYPE *A;
      A = malloc(N*ATL_MulBySize(N));
      ATL_assert(A);
      Mjoin(PATL,gecopy)(N, N, S, lds, A, N);
      Mjoin(PATL,syreflect)(AtlasLower, N, A, N);
      Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, M, N, N, alpha, G, ldg, 
                       A, N, beta, C, ldc);
      free(A);
      return(0);
   }
   #endif
   @ENDSKIP
   Mjoin(PATL,ipgenInfo)(&ip, 0, AtlasNoTrans, AtlasNoTrans, M, N, N, ldg, lds,
                         ldc, alpha, beta);
/*
 * This routine attempts to malloc space for 1 block of C, 1 column panel of A,
 * and entire matrix B.  Also needs space for kb*nb workspace, which is 
 * overlapped with all non-B workspace.
 */
   ATL_assert(ip.npmblks < 2);
   nb = (ip.nfnblks) ? ip.nb : ip.pnb;
   sz = (ip.nfkblks) ? ip.kb : ip.kb0;
   tkblks = ip.nfkblks+1;
   szB = tkblks*(ip.nfnblks*ip.szB + ip.npnblks*ip.pszB);
   szA = (ip.nfmblks) ? ip.szA : ip.pszA;
   szA *= tkblks;
   extra = ip.exsz;
   sz *= nb;
   if (sz > extra+szA+ip.szC)
      extra += sz - extra - szA - ip.szC;
   sz = ATL_MulBySize(extra + szA + szB + ip.szC) + 3*ATL_Cachelen;
   if (sz <= ATL_MaxMalloc)
      vp = malloc(sz);
   if (!vp)
      return(1);
    wB = ATL_AlignPtr(vp);
    wA = wB + (szB SHIFT);
    wd = wA = ATL_AlignPtr(wA);
    wC = wA + (szA SHIFT);
    wC = ATL_AlignPtr(wC);
    #ifdef TCPLX
       rC = wC + ip.szC;
    #endif
   @BEGINSKIP
/*
 *  Write known pattern so we can test elt test
 */
   #if defined(DEBUG) && 0
   {
      ATL_iptr_t i, j, cnt=0;
      TYPE *p=(TYPE*)S;
      double div=10, N2=N*N;
      while (div < N2)
         div *= 10;
      div = 1.0 / div;
      for (j=0; j < N; j++, p += lds)
      {
         for (i=j; i < N; i++)
            p[i] = 1.0 + (++cnt)*div;
      }
   }
   #endif
   #if defined(DEBUG) && 0
   {
      ATL_iptr_t i, len=szB SHIFT;
      double mul=10;
      while (mul < len)
         mul *= 10;
      mul = 1.0 / mul;
      for (i=0; i < len; i++)
         wB[i] = (-4.0 - i*mul)*1.0e6;
   }
   #endif
   @ENDSKIP
   ATL_cpsy2amm(&ip, flg, S, lds, wd, wB);
   @BEGINSKIP
/* 
 * Uncomment to get 1.cnt sequential numbering
 */
   #if defined(DEBUG) && 0
   {
      int k;
      double mul = 10.0;
      while (szB > mul)
         mul *= 10;
      printf("mul=%f\n", mul);
      mul = 1 / mul;
      for (k=0; k < szB; k++)
         wB[k] = 1.0+k*mul;
   }
   #endif
   @ENDSKIP
   #if defined(DEBUG) && 1
      #ifdef TCPLX
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 2|((flg&1)<<2)|((flg&2)<<2),
                                    wB, N, S);
      #else
         bv = Mjoin(PATL,ipsycmpBV)(2, 0.0, &ip, 2|((flg&1)<<2), wB, N, S);
      #endif
      if (bv)
      {
         ATL_print2dBV(N, N, bv);
         free(bv);
         printf("\nDONE PRINt2DBV\n\n");
      }
      else
         printf("\nNO ERRORS FOUND IN SYCP!\n\n");
   #endif
   #if 0
      Mjoin(PATL,ipprint)(stdout, &ip, 2, "SY", N, N, wB);
   #endif
   @BEGINSKIP
/*
 * Uncomment this code to make sure problem isn't in iploopsMNK!
 */
   #if 0
   {
      TYPE *A;
      #ifdef TCPLX
         #define ONE ip.ONE
      #else
         #define ONE ATL_rone
      #endif
      A = malloc(lds*ATL_MulBySize(N));
      ATL_assert(A);
      Mjoin(PATL,gecopy)(N, N, S, lds, A, lds);
      #ifdef TCPLX
      if (flg&2)
      {
         Mjoin(PATL,hereflect)(AtlasLower, N, A, lds);
         Mjoin(PATL,zero)(N, A+1, (lds+1)SHIFT);
      }
      else
      #endif
      Mjoin(PATL,syreflect)(AtlasLower, N, A, lds);
      Mjoin(PATL,iploopsMNK)(&ip, 0, 0, G, A, C, 1|2|8, wA, wB, rC, wC, beta,
                             ip.blk2c);
      free(A);
   }
   #else
   @ENDSKIP
   Mjoin(PATL,iploopsMNK)(&ip, 0, 0, G, NULL, C, 1|2|8, wA, wB, rC, wC, beta,
                          ip.blk2c);
   free(vp);
   return(0);
}
#undef ONE
@ROUT ATL_symmL
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#include "atlas_misc.h"
#include "atlas_amm.h"
#include "atlas_level1.h"
#include "atlas_level2.h"
#include "atlas_level3.h"
@skip #include "atlas_kernel3.h"
#include "atlas_reflevel3.h"
#include Mstr(Mjoin(ATLAS_PRE,sysinfo.h))
#include Mstr(Mjoin(ATLAS_PRE,opgen_view.h))
#if 0
   #define USEREF 1
   #include "atlas_reflevel3.h"
#endif

/*
 * On the left, symmetrix matrix is GEMM's A, with K=M
 */
#ifdef Conj_
int Mjoin(PATL,ophemmL)
#else
int Mjoin(PATL,opsymmL)
#endif
(
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aA, *aB, *aC, *bA;
   #ifdef TCPLX
      TYPE *rA, *rC;
   #endif
   opinfo_t oi;
   int Mjoin(PATL,opsymmInfo)
      (opinfo_t *op, ATL_UINT bv,
       ATL_CSZT M, ATL_CSZT N, ATL_CSZT lda, ATL_CSZT ldb, ATL_CSZT ldc,
        const SCALAR alpha, const SCALAR beta);

   if (!M || !N)
      return(0);
   if (M == 1) /* symmetric matrix is dense scalar! */
   {
      #ifdef TCPLX
         const register TYPE ra=(*alpha), ia=alpha[1], rA = *A;
         #ifdef Conj_
            const TYPE X[2] = {ra*rA, ia*rA};
         #else
            const register TYPE  iA=A[1];
            TYPE X[2];
            *X = ra*rA - ia*iA;
            X[1] = ra*iA + ia*rA;
         #endif
         Mjoin(PATL,axpby)(N, X, B, ldb, beta, C, ldc);
      #else
         Mjoin(PATL,axpby)(N, alpha*(*A), B, ldb, beta, C, ldc);
      #endif
      return(0);
   }
   #ifdef Conj_
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?7:5, M, N, lda, ldb,
                              ldc, alpha, beta))
   #else
   if (Mjoin(PATL,opsymmInfo)(&oi, (Uplo == AtlasUpper)?3:1, M, N, lda, ldb,
                              ldc, alpha, beta))
   #endif
      return(1);

   szW = oi.szB;
   szW = Mmax(szW, oi.szA);
   sz = oi.szA + szW + oi.szC;
   sz = ATL_MulBySize(sz) + ATL_Cachelen + oi.exsz;
   vp = malloc(sz);
   ATL_assert(vp);
   aA = ATL_AlignPtr(vp);
   #ifdef TCPLX
      rA = aA + oi.szA;
      aB = rA + oi.szA;
      aC = aB + (szW<<1);
      rC = aC + oi.szC;
   #else
      aB = aA + oi.szA;
      aC = aB + szW;
   #endif
   if (Uplo == AtlasUpper)
   @whiledef up L U
      @mif up = "L
   else /* Uplo == AtlasLower */
      @endmif
   {
      #ifdef TCPLX
         #ifdef Conj_
            #define SYCPY Mjoin(PATL,hecpy@(up)NB)
         #else
            #define SYCPY Mjoin(PATL,sycpy@(up)NB)
         #endif
         if (alpha[1] == ATL_rzero)
         {
            const register TYPE ral=(*alpha);
            if (ral == ATL_rone)
               Mjoin(SYCPY,_a1)(M, alpha, A, lda, aB, M);
            else if (ral == ATL_rnone)
               Mjoin(SYCPY,_an)(M, alpha, A, lda, aB, M);
            else
               Mjoin(SYCPY,_ar)(M, alpha, A, lda, aB, M);
         }
         else
         #ifdef Conj_
            Mjoin(SYCPY,_a1)(M, oi.ONE, A, lda, aB, M);
         #else
            Mjoin(SYCPY,_aX)(M, alpha, A, lda, aB, M);
         #endif
         #if 0
            Mjoin(PATL,geprint)("aG", M, M, A, lda);
            Mjoin(PATL,geprint)("aS", M, M, aB, M);
         #endif
         #undef SYCPY
      #else
         if (alpha == ATL_rone)
            Mjoin(PATL,sycpy@(up)NB_a1)(M, alpha, A, lda, aB, M);
         else if (alpha == ATL_rnone)
            Mjoin(PATL,sycpy@(up)NB_an)(M, alpha, A, lda, aB, M);
         else
            Mjoin(PATL,sycpy@(up)NB_aX)(M, alpha, A, lda, aB, M);
      #endif
   }
   @endwhile
   #ifdef TCPLX
      oi.a2blk(M, M, oi.ONE, aB, M, rA, aA);
      Mjoin(PATL,oploopsN)(&oi, 0, 0, NULL, B, C, 0, aA, aB, rC, aC);
   #else
      oi.a2blk(M, M, ATL_rone, aB, M, aA);
      Mjoin(PATL,oploopsN)(&oi, 0, 0, NULL, B, C, 0, aA, aB, aC, aC);
   #endif
   free(vp);
   return(0);
}

#ifndef Conj_
   #ifdef TCPLX
   #else
      #define ONE ATL_rone
      #define TA AtlasTrans
   #endif
void Mjoin(PATL,symmL_rec)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
/*
 * If the symmetric matrix is smaller than our rank-K GEMM support, use
 * outer product gemm to solve this problem by reflecting block matrix to dense.
 */
   if (M <= ATL_VWopgen_LAST_KB)
   {
      const enum ATLAS_UPLO Uplo = (flg&1) ? AtlasUpper : AtlasLower;
      #ifdef TCPLX
         if (flg&2) /* really HEMM */
         {
            if (!Mjoin(PATL,ophemmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
         }
         else
            if (!Mjoin(PATL,opsymmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                     beta, C, ldc))
               return;
      #else
         if (!Mjoin(PATL,opsymmL)(Uplo, M, N, alpha, A, lda, B, ldb, 
                                  beta, C, ldc))
            return;
      #endif
   }
/*
 * To avoid recurring and redundantly copying matrices as we average various
 * size GEMM's performance, attempt to halt recursion on symmetric dims by
 * allocating enough space to copy entire symmetric matrix to dense, and then
 * call GEMM only one time.  Do not do this if the general matrix consists
 * only of a single K-panel: in this case better to recur down and use opsymm.
 * Reason is copy of symat a big cost, and copying up front brings it through
 * cache twice, wheareas recursion will provide automatic blocking, and avoid
 * this for small problems where it matters.  Unlike more square cases, 
 * due to lack of symmetric block reuse, ipsymm has no performance benefit
 * over continuing recursion.
 */
   else if (N > ATL_VIEW_BEST_NB)
   {
      if (!Mjoin(PATL,ipsymmL)(flg, M, N, alpha,A,lda,B,ldb,beta,C,ldc))
         return;
   }
/*
 * If neither of those work, split along M using recursive steps:
 *    C0 = A00 * B0 + beta*C0 (symm)
 *    C0 = A10^T * B1 + C0    (gemm)
 *    C1 = A10 * B0 + beta*C1 (gemm)
 *    C1 = A11 * B1 + C1      (symm)
 */
   {
      #ifdef TCPLX
         const TYPE ONE[2] = {ATL_rone, ATL_rzero};
         const enum ATLAS_TRANS TA = (flg&2) ? AtlasConjTrans : AtlasTrans;
      #endif
      const int ML=(M>>1), MR = M-ML;
      const TYPE *B1 = B + (ML SHIFT);
      TYPE *C1 = C + (ML SHIFT);

      ATL_assert(ML);  /* debugging, remove later */
      Mjoin(PATL,symmL_rec)(flg, ML, N, alpha, A, lda, B, ldb, 
                            beta, C, ldc);
      if ((flg&1))  /* Upper Matrix */
      {
         const TYPE *A01 = A + ML*(lda SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, ML, N, MR, alpha, 
                          A01, lda, B1, ldb, ONE, C, ldc);
         Mjoin(PATL,ammm)(TA, AtlasNoTrans, MR, N, ML, alpha, 
                          A01, lda, B, ldb, beta, C1, ldc);
      }
      else          /* Lower matrix */
      {
         const TYPE *A10 = A + (ML SHIFT);
         Mjoin(PATL,ammm)(AtlasNoTrans, AtlasNoTrans, MR, N, ML, alpha, 
                          A10, lda, B, ldb, beta, C1, ldc);
         Mjoin(PATL,ammm)(TA, AtlasNoTrans, ML, N, MR, alpha, A10, lda,
                          B1, ldb, ONE, C, ldc);
      }
      Mjoin(PATL,symmL_rec)(flg, MR, N, alpha, A+(ML SHIFT)*(lda+1), 
                            lda, B1, ldb, ONE, C1, ldc);
   }
}
   #ifndef TCPLX
      #undef TA
   #endif
#else
   void Mjoin(PATL,symmL_rec)
      (ATL_CUINT, ATL_CSZT, ATL_CSZT, const SCALAR, const TYPE*, ATL_CSZT, 
       const TYPE*, ATL_CSZT, const SCALAR, TYPE*, ATL_CSZT);
#endif
void Mjoin(PATL,symmR_rec)
(
   ATL_CUINT flg, /* bitvec 0:Upper? 1:HEMM? */
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
);
#ifdef Conj_
void Mjoin(PATL,hemm)
#else
void Mjoin(PATL,symm)
#endif
(
   const enum ATLAS_SIDE  Side,
   const enum ATLAS_UPLO  Uplo,
   ATL_CSZT  M,
   ATL_CSZT N,
   const SCALAR alpha,
   const TYPE *A,
   ATL_CSZT lda,
   const TYPE *B,
   ATL_CSZT ldb,
   const SCALAR beta,
   TYPE *C,
   ATL_CSZT ldc
)
{
   ATL_SZT sz, szW;
   void *vp=NULL;
   TYPE *aA, *aB, *aC, *bA;
   opinfo_t oi;
   #ifdef Conj_
      ATL_UINT bv = (Uplo == AtlasUpper)|2;
   #else
      ATL_UINT bv = (Uplo == AtlasUpper);
   #endif

   #ifdef USEREF
   {
      #ifdef Conj_
         Mjoin(PATL,refhemm)(Side, Uplo, M, N, alpha, A, lda, B, ldb, 
                             beta, C, ldc);
      #else
         Mjoin(PATL,refsymm)(Side, Uplo, M, N, alpha, A, lda, B, ldb, 
                             beta, C, ldc);
      #endif
      return;
   }
   #endif
   if (!M || !N)
      return;
   if (SCALAR_IS_ZERO(alpha))  /* doing nothing but scaling C */
   {
      if (!SCALAR_IS_ONE(beta))  /* if there is scaling of C to do */
         Mjoin(PATL,gescal)(M, N, beta, C, ldc);
     
      return;
   }

   if (Side == AtlasLeft) /* K=M, A is GEMM's A */
   {
      #if defined(Conj_) || !defined(TCPLX)
      if (N == 1) /* really HEMV/SYMV */
      {
         #ifdef Conj_
            Mjoin(PATL,hemv)(Uplo, M, alpha, A, lda, B, 1, beta, C, 1);
         #else
            Mjoin(PATL,symv)(Uplo, M, alpha, A, lda, B, 1, beta, C, 1);
         #endif
         return;
      }
      #endif
      Mjoin(PATL,symmL_rec)(bv, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
   }
   else                   /* Right: K=N, A is GEMM's B */
   {
      #if !defined(TCPLX)
      if (M == 1) /* really HEMV/SYMV */
      {
/*
 *       Form C^H = S^H B^H (getting symm on left for hemv), 
 *       then convert C by conjugating.  This code works, but the
 *       extra work makes usually it slower than refblas or gemm.
 *       So, above outside cpp if doesn't allow this case.
 */
         #ifdef Conj_
         {
            void *vp;
            const TYPE CALP[2]={*alpha,-alpha[1]}, 
                       ONE[3]={ATL_rone, ATL_rzero, ATL_rzero};
            const ATL_iptr_t N2 = N+N;
            TYPE *x, *y;
            vp = malloc(ATL_MulBySize(N2)+ATL_Cachelen*2);
            ATL_assert(vp);
            x = ATL_AlignPtr(vp);
            y = x + N2;
            y = ATL_AlignPtr(y);
            Mjoin(PATL,moveConj)(N, CALP, B, ldb, x, 1);
            Mjoin(PATL,hemv)(Uplo, N, ONE, A, lda, x, 1, ONE+1, y, 1);
            Mjoin(PATL,axpbyConj)(N, ONE, y, 1, beta, C, ldc);
            free(vp);
            return;
         }
         #else
            Mjoin(PATL,symv)(Uplo, N, alpha, A, lda, B, ldb, beta, C, ldc);
            return;
         #endif
      }
      #endif
      Mjoin(PATL,symmR_rec)(bv, M, N, alpha, A, lda, B, ldb, beta, C, ldc);
   }
}
@ROUT trmmview
@extract -b @(topd)/cw.inc lang=C -def cwdate 2018
#define ATL_WANT ILCM 1
#include "atlas_iopt.h"
#include "atlas_cache.h"
#include "atlas_genparse.h"
#include "atlas_mmtesttime.h"

#define BSR_RIGHT  0
#define BSR_UPPER  1
#define BSR_TRANSA 2
void PrintUsage(char *name, int ierr, char *flag)
{
   if (ierr > 0)
      fprintf(stderr, "Bad argument #%d: '%s'\n", ierr,
              flag?flag:"OUT-OF_ARGUMENTS");
   else if (ierr < 0)
      fprintf(stderr, "ERROR: %s\n", flag);
   fprintf(stderr, "USAGE: %s [flags:\n", name);
   fprintf(stderr, "   -p [s,d,c,z]: set type/precision prefix (d) \n");
   fprintf(stderr, "   -S [L/R] : search Left or Right TRMM\n");
   fprintf(stderr, "   -U [U/L] : search Upper or Lower TRMM\n");
   exit(ierr ? ierr : -1);
}

char GetFlags(int nargs, char **args, int *FLG)
{
   char pre = 'd';
   int flg=0;
   int i;

   for (i=1; i < nargs; i++)
   {
      int wch, *ip, **ipp, TST=0;
      if (args[i][0] != '-')
         PrintUsage(args[0], i, args[i]);

      switch(args[i][1])
      {
      case 'S':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'R' || wch == 'r')
           flg |= 1<<BSR_RIGHT;
        else
           flg &= ~(1<<BSR_RIGHT);
        break;
      case 'U':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'U' || wch == 'u')
           flg |= 1<<BSR_UPPER;
        else
           flg &= ~(1<<BSR_UPPER);
        break;
      case 'A':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        wch = args[i][0];
        if (wch == 'T' || wch == 't')
           flg |= 1<<BSR_TRANSA;
        else
           flg &= ~(1<<BSR_TRANSA);
        break;
      case 'p':
        if (++i >= nargs)
            PrintUsage(args[0], i-1, NULL);
        pre = tolower(args[i][0]);
        assert(pre == 's' || pre == 'd' || pre == 'z' || pre == 'c');
        break;
      default:
         PrintUsage(args[0], i, args[i]);
      }
   }
   *FLG = flg;
   return(pre);
}

int main(int nargs, char **args)
{
   ATL_mmnode_t *mb, *tk, *mp, *tb, *tp;
   char *onm;
   int flag, mmflg=0;
   char pre;

   pre = GetFlags(nargs, args, &flag);
   if (flag&(1<<BSR_RIGHT))      /* Right case requires  N=K */
   {
      mmflg = 4;
      mb = ReadMMFileWithPath(pre, "res", "ipnek.sum");
      tk = ReadMMFileWithPath(pre, "res", "trmmKRL.sum");
      tk->flag |= (1<<MMF_RIGHT);
      if (flag&(1<<BSR_UPPER))
      {
         tk->flag |= 1<<MMF_UPPER;
         onm = "trmmRU.sum";
      }
      else
         onm = "trmmRL.sum";
   }
   else
   {
      mb = ReadMMFileWithPath(pre, "res", "ipmek.sum");
      tk = ReadMMFileWithPath(pre, "res", "trmmKLL.sum");
      if (flag&(1<<BSR_UPPER))
      {
         tk->flag |= 1<<MMF_UPPER;
         onm = "trmmLU.sum";
      }
      else
         onm = "trmmLL.sum";
   }
   tk->blask = ATL_KTRMM;
   tb = TimeMMFileWithPath(pre, "res", onm, 0, 0, 0, 1, 0, -1);
   if (tb)
   {
      WriteMMFileWithPath(pre,"res", onm, tb);
      KillAllMMNodes(tp);
      return(0);
   }
/*
 * Time all trmm at block factors forced by gemm to make views
 */
   printf("TRMMK TO BE TIMED FOR SIDE=%c:\n", (flag&(1<<BSR_RIGHT)) ? 'R':'L');
   PrintMMLine(stdout, tk);
   printf("\nTIMING TRMMK FOR ALL GEMM BLOCK FACTORS:\n");
   for (mp=mb; mp; mp = mp->next)
   {
      ATL_mmnode_t *p;
      double mf;
      p = CloneMMNode(tk);
      p->mbB = mp->mbB;
      p->nbB = mp->nbB;
      p->kbB = mp->kbB;
      mf = TimeMMKernel(0, mmflg, p, pre, p->mbB, p->nbB, p->kbB, 1, 0,-1);
      printf("   (%u,%u,%u) = %.2f\n", p->mbB, p->nbB, p->kbB, mf);
      p->mflop[0] = mf;
      if (tb)
         tp->next = p;
      else
         tb = p;
      tp = p;
   }
   KillAllMMNodes(mb);
   KillMMNode(tk);
   WriteMMFileWithPath(pre, "res", onm, tb);
   KillAllMMNodes(tb);
   return(0);
}
